<?php

/**
 * @file
 * Support module for charting flukso measurements.
 *
 * Copyright (c) 2008-2009 jokamajo.org
 *               2010 flukso.net
 *               2010 Fraunhofer Institut ITWM (www.itwm.fraunhofer.de)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

//DEBUG
//error_reporting(E_ALL);
//ini_set('display_errors', TRUE);
//ini_set('display_startup_errors', TRUE);

define('CONSUMPTION_SENSOR_TYPE', 1);
define('PRODUCTION_SENSOR_TYPE',  2);

define('LOGGER_REL_PATH', drupal_get_path('module', 'logger'));
define('LOGGER_PATH', DRUPAL_ROOT . '/' . LOGGER_REL_PATH);
define('LOGGER_DEFAULT_LATITUDE', 49.444710);
define('LOGGER_DEFAULT_LONGITUDE', 7.769031);

define('LOGGER_LEGEND_TABLE_ID', 'logger-legend-table');
define('LOGGER_TIMESTAMP_FORMAT_SQL', '%d-%m-%Y %H:%i:%s');
define('LOGGER_DEVICE_CERT_PATH', '../flukso-api/flukso/var/keys');


function logger_init() {

  check_browser_support();

  //If IE
  if (isset($_SERVER['HTTP_USER_AGENT']) && strpos(strtoupper($_SERVER['HTTP_USER_AGENT']), 'MSIE')) {
    drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/excanvas.js');
  }

  drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/strftime-min.js');
  drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/rgbcolor.js');
  drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/dygraph-canvas.js');
  drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/dygraph.js');

  drupal_add_js(LOGGER_REL_PATH . '/js/jscolor/jscolor.js');
  drupal_add_js(LOGGER_REL_PATH . '/js/charts.js');

  drupal_add_library('system', 'ui.datepicker');
  drupal_add_css(LOGGER_REL_PATH . '/style/ui.datepicker.css');

  drupal_add_js(LOGGER_REL_PATH . '/js/flot/jquery.flot.js');
  drupal_add_js(LOGGER_REL_PATH . '/js/flot/jquery.flot.stack.js');

  drupal_add_css(LOGGER_REL_PATH . '/js/openlayers/theme/default/style.css');
  drupal_add_css(LOGGER_REL_PATH . '/js/openlayers/style.css');
  drupal_add_js(LOGGER_REL_PATH . '/js/openlayers/OpenLayers.js');
  drupal_add_js(LOGGER_REL_PATH . '/js/maps.js');
}

function logger_permission() {

  return array(
    'view logger charts' => array(
      'title' => t('view logger charts'),
      'description' => t('View logger charts.'),
    ),
    'view forecast charts' => array(
      'title' => t('view forecast charts'),
      'description' => t('View forecast charts.'),
    ),
    'set user preferences' => array(
      'title' => t('set user preferences'),
      'description' => t('Set user preferences.'),
    ),
    'list devices' => array(
      'title' => t('list devices'),
      'description' => t('Access the list of user devices.'),
    ),
    'activate devices' => array(
      'title' => t('activate devices'),
      'description' => t('Activate a device.'),
    ),
    'deactivate devices' => array(
      'title' => t('deactivate devices'),
      'description' => t('Deactivate a device.'),
    ),
    'remove devices' => array(
      'title' => t('remove devices'),
      'description' => t('Remove a device and all related data.'),
    ),
    'clone devices' => array(
      'title' => t('clone devices'),
      'description' => t('Clone a device and all its sensors.'),
    ),
    'list sensors' => array(
      'title' => t('list sensors'),
      'description' => t('Access the list of user device sensors.'),
    ),
    'manage sensors' => array(
      'title' => t('manage sensors'),
      'description' => t('Edit sensor properties.'),
    ),
    'request device remote support' => array(
      'title' => t('request device remote support'),
      'description' => t('Request device remote support.'),
    ),
    'attend device remote support requests' => array(
      'title' => t('attend device remote support requests'),
      'description' => t('Attend remote support requests.'),
    ),
  );
}

function logger_menu() {

  // Main operations

  $items['logger'] = array(
    'description' => 'Show the home page',
    'page callback' => 'logger_home_page',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['overview'] = array(
    'title' => 'Overview',
    'description' => 'Show the project overview',
    'page callback' => 'logger_overview_page',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['energy'] = array(
    'title' => 'Your energy consumption and production',
    'description' => 'Show the energy consumption page',
    'page callback' => 'logger_energy_page',
    'page arguments' => array(1),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['energy/relative'] = array(
    'title' => 'Your relative energy consumption',
    'description' => 'Show the relative energy consumption page',
    'page callback' => 'logger_relative_energy_consumption_page',
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['power'] = array(
    'title' => 'Your power consumption and production',
    'description' => 'Show the power consumption page',
    'page callback' => 'logger_power_page',
    'page arguments' => array(1),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['power/user'] = array(
    'title' => 'Power consumption and production',
    'description' => 'Show the power consumption and production of a single user',
    'page callback' => 'logger_user_power_page',
    'page arguments' => array(2),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['logger/setvariable'] = array(
    'title' => 'Sets a logger variable',
    'page callback' => 'logger_set_variable',
    'page arguments' => array(2, 3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['logger/remove/user'] = array(
    'title' => 'Removes a chart series',
    'page callback' => 'logger_remove_user',
    'page arguments' => array(3),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['logger/file'] = array(
    'title' => 'Downloads a chart file',
    'page callback' => 'logger_download_chart_data_file',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['selfconsumption'] = array(
    'title' => 'Your power self consumption',
    'description' => 'Show the power self consumption page',
    'page callback' => 'logger_selfconsumption_page',
    'page arguments' => array(1, 0, t('Your power self consumption')),
    'access callback' => 'logger_producer_access',
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['forecast'] = array(
    'title' => 'Your power production forecast',
    'description' => 'Show the power consumption and production forecast page',
    'page callback' => 'logger_forecast_page',
    'page arguments' => array(1),
    'access callback' => 'logger_forecast_access',
    'access arguments' => array('view forecast charts'),
    'type' => MENU_CALLBACK,
  );

  $items['logger/getappliances'] = array(
    'title' => 'Returns list of appliances',
    'page callback' => 'logger_get_appliances',
    'page arguments' => array(2, 3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );


  //Device operations

  $device_title = 'Devices';
  $items['device/mylist'] = array(
    'title' => $device_title,
    'page callback' => 'logger_userdevices_page',
    'access callback' => 'logger_account_access',
    'access arguments' => array('list devices'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'logger.admin.inc'
  );

  $items['device/activate'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_activate',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('activate devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['device/deactivate'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_deactivate',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('deactivate devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['device/remove'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_remove',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('remove devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc',
  );

  $items['device/clone'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_clone',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('clone devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc',
  );

  $support_title = 'Support Requests';
  $items['device/support/confirm'] = array(
    'title' => $support_title,
    'description' => 'Show the device support request confirmation page',
    'page callback' => 'logger_support_confirmation_page',
    'page arguments' => array(3, 4),
    'access callback' => 'logger_device_access',
    'access arguments' => array('request device remote support', 3),
    'type' => MENU_CALLBACK,
  );

  $items['device/support/request'] = array(
    'title' => $device_title,
    'page callback' => 'logger_request_support',
    'page arguments' => array(3, 4),
    'access callback' => 'logger_device_access',
    'access arguments' => array('request device remote support', 3),
    'type' => MENU_CALLBACK,
  );

  $items['device/support/suspend'] = array(
    'title' => $device_title,
    'page callback' => 'logger_suspend_support',
    'page arguments' => array(3),
    'access callback' => 'logger_device_access',
    'access arguments' => array('request device remote support', 3),
    'type' => MENU_CALLBACK,
  );

  $items['device/support/requests'] = array(
    'title' => $support_title,
    'description' => 'Show the device support requests page',
    'page callback' => 'logger_support_requests_page',
    'access arguments' => array('attend device remote support requests'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['device/support/postpone'] = array(
    'title' => $support_title,
    'page callback' => 'logger_postpone_support',
    'page arguments' => array(3),
    'access arguments' => array('attend device remote support requests'),
    'type' => MENU_CALLBACK,
  );

  $items['device/support/remove'] = array(
    'title' => $support_title,
    'page callback' => 'logger_remove_support',
    'page arguments' => array(3),
    'access arguments' => array('attend device remote support requests'),
    'type' => MENU_CALLBACK,
  );


  //Sensor operations

  $sensor_title = 'Sensors';
  $items['sensor/mylist'] = array(
    'title' => $sensor_title,
    'page callback' => 'logger_usersensors_page',
    'access callback' => 'logger_account_access',
    'access arguments' => array('list sensors'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'logger.admin.inc',
  );

  $items['sensor/register'] = array(
    'title' => 'New Virtual Sensor',
    'page callback' => 'logger_sensor_edition_page',
    'access callback' => 'logger_account_access',
    'access arguments' => array('manage sensors'),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $sensor_edit_title = 'Sensor Edition';
  $items['sensor/edit'] = array(
    'title' => $sensor_edit_title,
    'page callback' => 'logger_sensor_edition_page',
    'page arguments' => array(2),
    'access callback' => 'logger_sensor_access',
    'access arguments' => array('manage sensors', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['sensor/deactivate'] = array(
    'title' => $sensor_title,
    'page callback' => 'logger_sensor_deactivate',
    'page arguments' => array(2),
    'access callback' => 'logger_sensor_access',
    'access arguments' => array('manage sensors', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['sensor/remove'] = array(
    'title' => $sensor_title,
    'page callback' => 'logger_sensor_remove',
    'page arguments' => array(2, "sensor/mylist"),
    'access callback' => 'logger_sensor_access',
    'access arguments' => array('manage sensors', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );


  //Other operations

  $items['admin/config/logger'] = array(
    'title' => 'Logger settings',
    'description' => 'Configure settings for logging metering values.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('logger_admin_settings'),
    'access arguments' => array('administer site configuration'),
  );

  $items['user/%user_uid_optional/privacy'] = array(
    'title' => 'Privacy',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('logger_userprivacy_form'),
    'access arguments' => array('set user preferences'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'logger.admin.inc',
    'weight' => 2,
  );
  return $items;
}

function user_menu_alter(&$items) {
  //Overrides access control to manage visitor's permissions
  $items['user/%user/edit']['access callback'] = 'logger_user_edit_access';
}

/**
 * This function overrides user_edit_access to block user profile edition by visitors (such as the user "guest").
 * 
 * @param $account The user account.
 */
function logger_user_edit_access($account) {

  return !user_has_role('Visitor') && user_edit_access($account);
}

/**
 * Forwards request to a suitable home page.
 *
 * @param $arg  Any page argument.
 * @return the home page.
 */
function logger_home_page($arg = NULL) {

  if ($arg) {
    drupal_goto('logger', array(), 301);
  }

  if (logger_is_mobile_device()) {
    return logger_mobile_page();
  }

  if (user_access('view logger charts')) {
    return logger_energy_page('week');
  }
  else {
    return logger_overview_page('hour');
  }
}

/**
 * Builds the mobile application home page.
 * 
 * @return the mobile home page.
 */
function logger_mobile_page() {

  global $user;

  if ($user->uid) {
    $forecast_access = logger_forecast_access('view forecast charts');

    $output =
      logger_create_mobile_page_icon('energy.png',      t('Energy'),            '/energy') .
      logger_create_mobile_page_icon('power.png',       t('Power'),             '/power') .
      logger_create_mobile_page_icon('comparison.png',  t('Comparison'),        '/energy/relative') .
      ($forecast_access ?
      logger_create_mobile_page_icon('forecast.png',    t('Forecast'),          '/forecast') : '') .
      logger_create_mobile_page_icon('event.png',       t('Events'),            '/notification/list') .
      logger_create_mobile_page_icon('addnode.png',     t('Add Node'),          '/node/add') .
      logger_create_mobile_page_icon('chumby.png',      t('Chumby Image'),      '/chumby') .
      logger_create_mobile_page_icon('dump.png',        t('Dump values'),       '/dump/116/setup') .
      logger_create_mobile_page_icon('myaccount.png',   t('My Account'),        "/users/$user->name") .
      logger_create_mobile_page_icon('device.png',      t('Devices'),           '/device/mylist') .
      logger_create_mobile_page_icon('sensor.png',      t('Sensors'),           '/sensor/mylist');
  }
  else {
    $output =
      logger_create_mobile_page_icon('join.png',        t('Join mySmartGrid'),  '/content/werden-sie-teilnehmer');
  }

  $output .=
    logger_create_mobile_page_icon('project.png',       t('The Project'),       '/content/das-projekt') .
    logger_create_mobile_page_icon('overview.png',      t('Overview'),          '/overview') .
    logger_create_mobile_page_icon('question.png',      t('FAQ'),               '/content/h%C3%A4ufige-fragen-und-antworten') .
    logger_create_mobile_page_icon('installation.png',  t('Installation'),      '/content/installationsanleitung-des-fluksos') .
    logger_create_mobile_page_icon('forum.png',         t('Forums'),            '/forum') .
    logger_create_mobile_page_icon('blog.png',          t('Blog'),              '/blog') .
    logger_create_mobile_page_icon('newsletter.png',    t('Newsletter'),        '/newsletter') .
    logger_create_mobile_page_icon('developer.png',     t('Developer'),         '/content/seiten-f%C3%BCr-entwickler') .
    logger_create_mobile_page_icon('contact.png',       t('Contact'),           '/kontakt');

  return $output;
}

/**
 * Creates a mobile page icon.
 * 
 * @param $image  The icon image file.
 * @param $label  The icon label.
 * @param $target The icon target URL.
 * @return the icon.
 */
function logger_create_mobile_page_icon($image, $label, $target) {
  return '
    <div class="menu-icon">
      <a href="' . $target . '">
        <img src="/sites/all/themes/msgmobile/images/icons/' . $image . '"/>
        <span>' . $label . '</span>
      </a>
    </div> ';
}

/**
 * Checks if the client is a mobile device.
 *
 * @return TRUE if it is; FALSE otherwise.
 */
function logger_is_mobile_device() {
  $check = mobile_tools_is_mobile_device();
  return $check['type'] == 'mobile';
}

/**
 * Builds the power consumption page of a single user.
 * 
 * @param $uid The user id.
 * @return the power consumption page. 
 */
function logger_user_power_page($uid) {
  logger_set_variable('selected_users', array($uid));
  return logger_power_page('hour');
}

/**
 * Builds the power consumption page.
 *
 * @param $interval The time interval.
 * @return the power consumption page.
 */
function logger_power_page($interval) {

  $types = array(CONSUMPTION_SENSOR_TYPE, PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_subscribed_sensors($types);

  return logger_power_chart_page($interval, 'power', t('Your power consumption and production'), $sensors, $types);
}

/**
 * Builds the power production forecast page.
 *
 * @param $interval The time interval.
 * @return the power production forecast page.
 */
function logger_forecast_page($interval) {

  global $user;

  $interval = $interval ? $interval : 'f3days'; 
  $types = array(PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_sensors($types, array($user->uid), TRUE);

  return logger_power_chart_page($interval, 'forecast', t('Your power production forecast'), $sensors, $types);
}

/**
 * Builds the power self consumption page.
 *
 * @param $interval The time interval.
 * @return the power self consumption page.
 */
function logger_selfconsumption_page($interval) {

  global $user;

  $types = array(CONSUMPTION_SENSOR_TYPE, PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_sensors($types, array($user->uid));

  return logger_power_chart_page($interval, 'selfconsumption', t('Your power self consumption'), $sensors, $types);
}

/**
 * Builds a power chart page.
 *
 * @param $interval The time interval.
 * @param $context  The chart context.
 * @param $title    The page title.
 * @param $sernsors The sensors plotted on the chart.
 * @param $types    The types of sensors plotted on the chart.
 * @return the power consumption page.
 */
function logger_power_chart_page($interval, $context, $title, $sensors, $types) {

  module_load_include('inc', 'logger', 'logger.rrd');

  //Sometimes Drupal invokes this function with $interval = ''
  $interval = $interval ? $interval : 'hour';
  if (!logger_get_default_time_window($interval)) {
    drupal_goto('power', array(), 301);
  }

  drupal_set_title($title);

  $xvalue1 = logger_get_xvalue(1);
  $xvalue2 = logger_get_xvalue(2);
  $yvalue1 = logger_get_yvalue(1);
  $yvalue2 = logger_get_yvalue(2);
  $unit = logger_get_variable('powerchart_unit', 'watt');

  $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);
  $price1 = $use_sensor_prices ? NULL : logger_get_variable('price1', 0.18);
  $price2 = $use_sensor_prices ? NULL : logger_get_variable('price2', 0.18);

  $filled = logger_get_variable('filled_graph', 1) == 1;
  $step_plot = logger_get_variable('step_plot', 0) == 1;
  $smooting_level = logger_get_variable('smooting_level', 1);
  $net_production = logger_get_variable('net_production', 1) == 1;

  $chart = logger_create_chart_object($context, $types, $interval, $unit, $sensors, array($xvalue1, $xvalue2), array($yvalue1, $yvalue2), FALSE,
    $price1, $price2, FALSE, $filled, $step_plot, $smooting_level, $net_production);

  $form = drupal_get_form('logger_powerchart_form', $chart);

  return theme('logger_power_chart_area', array('chart' => $chart)) . drupal_render($form);
}

/**
 * Builds the overview page.
 *
 * @param $interval The time interval.
 * @return the overview page.
 */
function logger_overview_page($interval) {

  $interval = $interval ? $interval : 'hour';
  if (!logger_get_default_time_window($interval)) {
    drupal_goto('overview', array(), 301);
  }

  drupal_set_title(t('Overall View'));

  $output = '';
  $cache_id = 'logger_overview';
  $cache = cache_get($cache_id, 'cache_page');

  if (isset($cache->data)) {
    $output = $cache->data;
  }
  else {

    //General explanation
    $output = theme('logger_overview_topic', array('title' => NULL, 'body' =>
      t('<b>mySmartGrid</b> is the smart device control for your home. ' .
      'It enables you to understand your energy consumption and share your ' .
      'experiences with others.'), 'link' => 'content/das-projekt'));

    //Latest blogpost
    $sql = 'SELECT nid FROM {node} WHERE type = :type ORDER BY created DESC';
    $nid = db_query_range($sql, 0, 1, array(':type' => "blogpost"))->fetchField();

    if ($nid) {
      $blog = node_load($nid);

      //TODO: show only the blog teaser
      $output .= theme('logger_overview_topic', array('title' => t('Blog:') . $blog->title,
        'body' => $blog->body['und'][0]['safe_value'], 'link' => 'blog'));
    }

    //Counters
    $sql = "SELECT COUNT(*) FROM {logger_devices} WHERE uid <> :uid";
    $devcounter = db_query($sql, array(':uid' => 0))->fetchField();

    $sql = "SELECT COUNT(*) FROM {users} u WHERE EXISTS(
      SELECT 1 FROM {logger_devices} d WHERE d.uid = u.uid)";

    $usercounter = db_query($sql)->fetchField();

    $output .= theme('logger_overview_topic', array('title' => t('Total Consumption of All Participants'), 'body' =>
      t('Currently, <b>@devcounter</b> Flukso devices are installed ' .
        'in <b>@usercounter</b> households. The following chart shows their ' .
        'aggregate electricity consumption.',
        array(
          '@devcounter' => $devcounter,
          '@usercounter' => $usercounter )))) . '<br>';
  
    cache_set($cache_id, $output, 'cache_page', REQUEST_TIME + 1 * DAY);
  }

  $types = array(CONSUMPTION_SENSOR_TYPE);
  $sensors = logger_get_sensors($types);

  $chart = logger_create_chart_object('overview', $types, $interval, 'watt', $sensors);

  $output .= theme('logger_power_chart_area', array('chart' => $chart));

  return $output;
}

/**
 * Builds the relative energy consumption page.
 *
 * @return the relative energy consumption page.
 */
function logger_relative_energy_consumption_page() {

  global $user;

  $meters = logger_get_variable('selected_meters', array());
  $all_meters = array();

  $types = array(CONSUMPTION_SENSOR_TYPE);
  $all_sensors = logger_get_sensors($types, array($user->uid));
  $unit = logger_get_variable('relativechart_unit', 'kWh');
  $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);
  $price1 = $use_sensor_prices ? NULL : logger_get_variable('price1', 0.18);

  $sensors = array();
  foreach ($all_sensors as $sensor) {
    $all_meters[] = $sensor->meter;
    if (isset($meters[$sensor->meter]) && $meters[$sensor->meter]) {
      $sensors[] = $sensor;
    }
  }

  if (empty($sensors)) {
    $sensors = $all_sensors;
    logger_set_variable('selected_meters', $all_meters);
  }

  $chart = logger_create_chart_object('relative', $types, 'year', $unit, $sensors, array(0, 0), array(0, 0), FALSE, $price1, NULL, TRUE);

  drupal_set_title(t('Your relative energy consumption'));

  $form = drupal_get_form('logger_relativechart_form', $chart);

  return t('The following chart allows you to compare current and previous levels of ' .
    'energy consumption in six different time frames: hour, day, week, month, and year. ' .
    'The bars are explained in the legend bellow.') . '<br><br>' .

    theme('logger_energy_chart_area', array('chart' => $chart)) .

    drupal_render($form);
}

/**
 * Builds the energy consumption page.
 *
 * @param $interval The time interval.
 * @return the energy consumption page.
 */
function logger_energy_page($interval) {

  global $user;

  $interval = $interval ? $interval : 'week';
  $window = logger_get_default_time_window($interval);
  if (!$window) {
    drupal_goto('energy', array(), 301);
  }

  if ($interval == 'year') {
    $start = mktime(0, 0, 0, date('n') - 11, 1);
    $end   = mktime(0, 0, 0, date('n') +  1, 1) - 1;
  }
  else {
    $sub_interval = logger_get_sub_interval($interval);
    $sub_time_window = logger_get_default_time_window($sub_interval);

    $now = REQUEST_TIME;
    //The offset is subtracted here to assure the hour 00:00 on the user timezone, and not on UTC
    $start = $now - (round($window / $sub_time_window) - 1) * $sub_time_window - ($now % $sub_time_window) - get_timezone_offset();
    $start -= $interval == 'month' ? 3 * DAY : 0;
    $end = $start + round($window / $sub_time_window) * $sub_time_window;
  }

  $all_types_options = logger_get_sensor_types_options($user->uid);
  $selected_types_options = logger_get_variable('selected_sensor_types', $all_types_options);

  //User can change sensor types any time
  foreach ($selected_types_options as $type => $selected) {
    if ($selected && isset($all_types_options[$type])) {
      $types[] = $type;
    }
  }
  if (empty($types)) {
    $types = array_keys($all_types_options);
    logger_set_variable('selected_sensor_types', $all_types_options);
  }

  $sensors = logger_get_sensors($types, array($user->uid));
  $aggregate_sensors = logger_get_variable('aggregate_sensors', 1);
  $unit = logger_get_variable('energychart_unit', 'kWh');
  $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);
  $price1 = $use_sensor_prices ? NULL : logger_get_variable('price1', 0.18);
  $price2 = $use_sensor_prices ? NULL : logger_get_variable('price2', 0.18);

  $chart = logger_create_chart_object('energy', $types, $interval, $unit, $sensors, array($start, $end), array(0, 0), $aggregate_sensors, $price1, $price2);

  //TODO: refactor
  $consumed = isset($chart->data['last'][CONSUMPTION_SENSOR_TYPE]) ? $chart->data['last'][CONSUMPTION_SENSOR_TYPE] : 0;
  $produced = isset($chart->data['last'][PRODUCTION_SENSOR_TYPE]) ? $chart->data['last'][PRODUCTION_SENSOR_TYPE] : 0;

  drupal_set_title(t('Your energy consumption and production'));

  $today = array(
    'day' => 'In the last 6 hours',
    'week' => 'Today',
    'month' => 'This week',
    'year' => 'This month',
  );
  
  $form = drupal_get_form('logger_energychart_form', $chart);

  return t("!today you have consumed %consumed %unit and produced %produced %unit so far. " .
    "The following chart shows your energy consumption and production !interval.",
    array(
      '!today' => t($today[$interval]),
      '%consumed' => number_format($consumed, 2, '.', ''),
      '%produced' => number_format($produced, 2, '.', ''),
      '%unit' => t($unit),
      '!interval' => t("along the $interval"),
    )) . '<br><br>' .

    theme('logger_energy_chart_area', array('chart' => $chart)) .

    drupal_render($form);
}

/**
 * Creates an object to hold chart parameters.
 *
 * @param $context            The page where the chart is going to be placed (overview or logger).
 * @param $types              The array of sensor types.
 * @param $interval           The time interval.
 * @param $unit               The chart unit.
 * @param $sensors            The sensors whose values are plotted on the chart.
 * @param $xaxis              An array containing the minimum and maximum timestamps of the x axis.
 * @param $yaxis              An array containing the minimum and maximum values of the y axis.
 * @param $aggregate_sensors  Whether the sensors series should be aggregated.
 * @param $price1             The price of KWh, for sensor type 'consumption', used when the unit is 'eur' or 'eur/year'.
 * @param $price2             The price of KWh, for sensor type 'production', used when the unit is 'eur' or 'eur/year'.
 * @param $stacked            Whether the chart has stacked bars or not.
 * @param $filled             Whether the chart lines should be filled.
 * @param $step_plot          Whether the chart lines should be stepped.
 * @param $smooting_level     The smoothing level of the chart lines.
 * @param $net_production     Whether the chart should show net production.
 * @return the chart object.
 */
function logger_create_chart_object($context, $types, $interval, $unit, $sensors, $xaxis = array(0, 0), $yaxis = array(0, 0), $aggregate_sensors = FALSE, $price1 = NULL, $price2 = NULL, $stacked = FALSE, $filled = FALSE, $step_plot = FALSE, $smooting_level = 1, $net_production = FALSE) {

  $chart = new stdClass();
  $chart->context = $context;
  $chart->types = $types;
  $chart->interval = $interval;
  $chart->unit = $unit;
  $chart->resolution = logger_get_resolution($interval);
  $chart->offset = get_timezone_offset();
  $chart->colors = logger_get_series_colors($context);
  $chart->sensors = $sensors;
  $chart->aggregate_sensors = $aggregate_sensors;
  $chart->price1 = $price1;
  $chart->price2 = $price2;
  $chart->prices = array(CONSUMPTION_SENSOR_TYPE => $price1, PRODUCTION_SENSOR_TYPE => $price2);
  $chart->stacked = $stacked;
  $chart->filled = $filled;
  $chart->step_plot = $step_plot;
  $chart->smooting_level = $smooting_level;
  $chart->net_production = $net_production;

  if (!($xaxis[0] > 0 && $xaxis[1] > 0)) {

    $window = logger_get_default_time_window($interval, FALSE);

    if ($window > 0) {//future
      $xaxis[0] = REQUEST_TIME - (REQUEST_TIME % DAY) - $chart->offset;
      $xaxis[1] = $xaxis[0] + $window;
    }
    else {//past
      $xaxis[1] = REQUEST_TIME;
      $xaxis[0] = $xaxis[1] + $window;
    }
  }
  $chart->yaxis = $yaxis;
  $chart->xaxis = $xaxis;
  $chart->period = logger_get_period($interval, $chart->resolution, $xaxis[0], $xaxis[1]);

  $lifetime = MINUTE;
  $t1 = $chart->period['start'] - ($chart->period['start'] % $lifetime);
  $t2 = $chart->period['end']   - ($chart->period['end']   % $lifetime);
  $unique_id = "$context " . implode(',', $types) . " $unit $price1 $price2 $chart->resolution $t1 $t2 $aggregate_sensors $net_production";
  foreach ($chart->sensors as $sensor) {
    $unique_id .= " $sensor->meter $sensor->type $sensor->forecast";
  }

  $chart->id = 'logger_' . $interval . '_chart_data_' . md5($unique_id);
  $cache = cache_get($chart->id, 'cache_page');
  $chart->data = $cache ? $cache->data : FALSE;
  $chart->file_url = 'logger/file/' . $chart->id;

  if (!$chart->data) {
    $get_data = 'logger_get_' . $chart->context . '_chart_data';

    if (!empty($types)) {
      $chart->data = $get_data($chart);
      cache_set($chart->id, $chart->data, 'cache_page', REQUEST_TIME + $lifetime);
    }
  }
  return $chart;
}

/**
 * Downloads a chart data file.
 *
 * @param $cache_id  The chart cache id.
 */
function logger_download_chart_data_file($cache_id) {

  $header = '';
  $lines = '';

  $cache = cache_get($cache_id, 'cache_page');
  if ($cache->data) {
    $values = array();
    $s = 1;
    $header = t('Serie');

    foreach ($cache->data['series'] as $uid => $userdata) {
      foreach ($userdata as $username => $sensors) {
        foreach ($sensors as $sensor => $typedata) {
          foreach ($typedata as $type => $measurements) {
            $header .= ',S' . $s++;

            foreach ($measurements as $timestamp => $value) {
              //TODO: simplify
              $values[$timestamp] = (isset($values[$timestamp]) ? $values[$timestamp] : '') . ',' . $value;
            }
          }
        }
      }
    }

    foreach ($values as $timestamp => $values_list) {
      $lines .= str_replace(array('&nbsp;', '<br>'), ' ', $timestamp); //Removes HTML tags
      $lines .= $values_list . "\r\n"; //These characters work both in Linux and Windows
    }
  }
  download_chart_data_file('chart-data-file', $header, $lines);
}

/**
 * Returns an array containing all relative energy consumption chart data.
 *
 * @return the chart data.
 */
function logger_get_relative_chart_data($chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.rrd');

  $now = getdate();
  $extra_days['month'] = $now['mday'] - 1; //Days since 1st day of the month
  $extra_days['year'] = $now['yday']; //Days since 1st day of the year
  $extra_days['week'] = $now['wday'] > 0 ? $now['wday'] - 1 : 6; //Days since last Monday

  $intervals = array(
    'hour' => t('Hour'),
    'day' => t('Day'),
    'week' => t('Week'),
    'month' => t('Month'),
    'year' => t('Year'),
  );

  $legend = array(
    array('Serie' => '<b>' . t('Current') . '</b>' . ' - ' . t('How much has been consumed so far in the current time frame.')),
    array('Serie' => '<b>' . t('Previous') . '</b>' . ' - ' . t('How much was consumed in the previous time frame.')),
    array('Serie' => '<b>' . t('Excess') . '</b>' . ' - ' . t('How much the current consumption has exceeded the previous one.')),
  );

  foreach ($intervals as $interval => $label) {

    $resolution = logger_get_resolution($interval);
    $adjustment = isset($extra_days[$interval]) ? $extra_days[$interval] * DAY : 0;
    //offset is used here to assure hour 00:00 on the user timezone and not on UTC.
    $adjustment += (($now[0] + $chart->offset) % ($interval == 'hour' ? HOUR : DAY));

    if ($interval == 'month') {
      $last_day = getdate($now[0] - $adjustment - 12 * HOUR);
      $window = $last_day['mday'] * DAY; //Consider exactly 1 month, and not simply 30 days
    }
    else {
      $window = logger_get_default_time_window($interval);
    }

    $time1 = $now[0] - $adjustment - $window;
    $time2 = $time1 + $window;
    $time3 = $time2 + $window;

    $period1 = array('start' => $time1, 'end' => $time2);
    $period2 = array('start' => $time2, 'end' => $time3);

    $current  = logger_rrd_query_energy($chart->sensors, $chart->unit, $interval, $period2, $resolution, $chart->prices);
    $previous = logger_rrd_query_energy($chart->sensors, $chart->unit, $interval, $period1, $resolution, $chart->prices);

    $so_far    = min($previous, $current);
    $remaining = max($previous - $current, 0);
    $excess    = max($current - $previous, 0);

    //Percentages
    $series['current'][$label]  = @($so_far / $previous) * 100;
    $series['previous'][$label] = @($remaining / $previous) * 100;
    $series['excess'][$label]   = @($excess / ($previous ? $previous : $excess)) * 100;

    //Actual values
    $data_labels['current'][0][$label]  = $so_far;
    $data_labels['previous'][0][$label] = $previous;
    $data_labels['excess'][0][$label]   = $excess ? $previous + $excess : 0;

    //Until the last second
    $period1['end'] -= 1;
    $period2['end'] -= 1;

    $legend[0][$label] = logger_format_period($interval, $period2);
    $legend[1][$label] = logger_format_period($interval, $period1);
    $legend[2][$label] = logger_format_period($interval, $period2);
  }
  $data['series'][$user->uid][$user->name][] = $series;
  $data['labels'] = $data_labels;
  $data['legend'] = $legend;

  return $data;
}

/**
 * Formats a period of time array for exhibition.
 * 
 * @param $interval  The time interval name.
 * @param $period    The pair of timestamps (start, end) that define the period.
 * @return the period of time as a string.
 */
function logger_format_period($interval, $period) {

  $start = $period['start'];
  $end   = $period['end'];

  switch ($interval) {
    case 'hour':
      return date('H:i', $start);

    case 'dayquarter':
      return logger_format_long_period($start, $end, 'H:i');

    case 'day':
      return date('d/m', $start);

    case 'week':
      return logger_format_long_period($start, $end, 'd/m');

    case 'month':
      return t(date('F', $start));

    case 'year':
      return t(date('Y', $start)) . '<br>';
  }
}

/**
 * Formats a long period of time for exhibition.
 * 
 * @param $start   The timestamp when the period begins.
 * @param $end     The timestamp when the period ends.
 * @param $format  The timestamp format to be used.
 * @return the long period of time as a string.
 */
function logger_format_long_period($start, $end, $format) {

  return t('from:') . '&nbsp;&nbsp;' . date($format, $start) . '<br>' .
         t('to:') . '&nbsp;&nbsp;' . date($format, $end);
}

/**
 * Returns an array containing all energy consumption chart data.
 * 
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_energy_chart_data(&$chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.rrd');
  $last = array();

  $groups = array();
  foreach ($chart->sensors as &$sensor) {
    $key = $chart->aggregate_sensors ? $sensor->type : $sensor->meter;
    $groups[$key][] = $sensor;
  }

  $sub_interval = logger_get_sub_interval($chart->interval);
  $sub_time_window = logger_get_default_time_window($sub_interval);

  foreach ($groups as $key => &$series_sensors) {

    $min_day = 0;
    $max_day = 0;
    $min = NULL;
    $max = NULL;
    $sum = 0;
    $total = 0;
    $series = array();
    $data_labels = array();

    $from = $chart->xaxis[0];
    $to = $chart->xaxis[1] - $sub_time_window;
    for ($time = $from; $time <= $to; $time += $sub_time_window) {

      if ($chart->interval == 'year') {
        $start = mktime(0, 0, 0, date('n', $time + WEEK),     1, date('Y', $time + WEEK));
        $end   = mktime(0, 0, 0, date('n', $time + WEEK) + 1, 1, date('Y', $time + WEEK));
      }
      else {
        $start = $time;
        $end = $time + $sub_time_window;
      }

      $period = array('start' => $start, 'end' => $end);
      $value = logger_rrd_query_energy($series_sensors, $chart->unit, $sub_interval, $period, $chart->resolution, $chart->prices);

      $end -= 1; //from 00:00:00 until 23:59:59 on user timezone
      $period['end'] = $end;

      switch ($chart->interval) {
        case 'day':
          $formatted_time = t(date('l', $start)) . ' ' . t('day quarter ' . (ceil(date("H", $end) / 6)));
          $complement = logger_format_period('dayquarter', $period);
          break;
        case 'week':
          $formatted_time = t(date("l", $start));
          $complement = date("d", $start) . '-' . t(date("M", $start));
          break;
        case 'month':
          $formatted_time = t('Week') . ' ' . date("W", $start);
          $complement = logger_format_period('week', $period);
          break;
        case 'year':
          $formatted_time = t(date("M", $start));
          $complement = date("Y", $start);
          break;
      }
      $title = $formatted_time . '<br>' . $complement;

      if (!$min || ($value < $min && $time < $to)) {
        $min = $value;
        $min_day = $formatted_time;
      }

      if (!$max || $value > $max) {
        $max = $value;
        $max_day = $formatted_time;
      }

      $sum += $value;
      $total++;

      $series[$title] = $value;
      $data_labels[$title] = $value;
    }

    $sensor = $series_sensors[0];
    $type_id = $sensor->type_id;
    $last[$type_id] = (isset($last[$type_id]) ? $last[$type_id] : 0) + $value;

    if ($chart->aggregate_sensors) {
      $sensor = new stdClass();
      $sensor->uid = $user->uid;
      $sensor->username = $user->name;
      $sensor->function = t('All');
      $sensor->meter = 'All';
      $sensor->type = t($key);
    }

    $data['series'][$sensor->uid][$sensor->username][$sensor->meter][t($sensor->type)] = $series;
    $data['labels'][$sensor->meter][t($sensor->type)] = $data_labels;
    $data['legend'][] = logger_create_energy_legend_line($sensor, $min, $max, $total, $sum, $min_day, $max_day, $chart->interval);
  }
  $data['last'] = $last;

  return $data;
}

/**
 * Creates a line for the energy consumption chart legend.
 * 
 * @param $sensor      The sensor object.
 * @param $min         The minimum value on the period.
 * @param $max         The maximum value on the period.
 * @param $total       The number of values.
 * @param $sum         The total consumption on the period.
 * @param $min_time    The sub period (eg. day of the week) with the minimum consumption.
 * @param $max_time    The sub period (eg. day of the week) with the maximum consumption.
 * @param $interval    The chart time interval name.
 * @return the legend line.
 */
function logger_create_energy_legend_line(&$sensor, $min, $max, $total, $sum, $min_time, $max_time, $interval) {

  return array(
    t('User') => $sensor->username,
    t('Sensor') => $sensor->function,
    t('Type') => t($sensor->type),
    t('Min') => $total > 0 ? logger_format_energy_legend_record($min, $min_time, $interval) : '',
    t('Max') => $total > 0 ? logger_format_energy_legend_record($max, $max_time, $interval) : '',
    t('Avg') => $total > 0 ? $sum / $total : '',
    t('Sum') => $total > 0 ? $sum : '',
  );
}

/**
 * Formats a record consumption (either min or max) to be shown on a cell of 
 * the energy consumption chart legend.
 *  
 * @param $min         The record value.
 * @param $record_time The record time.
 * @param $interval    The chart time interval name.
 * @return the formatted record.
 */
function logger_format_energy_legend_record($value, $record_time, $interval) {

  $prep = $interval == 'year' ? 'in' : 'am';

  return t("%value $prep %day", array(
    '%value' => number_format($value, 2, '.', ''),
    '%day' => $record_time,
  ));
}

/**
 * Returns an array containing all power consumption chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_power_chart_data($chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.rrd');

  $is_visitor = user_has_role('Visitor');
  $data = array();
  $i = 0;

  foreach ($chart->sensors as &$sensor) {

    $price = ($sensor->type_id == CONSUMPTION_SENSOR_TYPE) ? $chart->price1 : $chart->price2;
    $price = $price ? $price : $sensor->price;

    //TODO: make a single call
    if ($sensor->virtual) {
      $aggregated = logger_get_aggregated_sensors($sensor->meter);
      $measurements = logger_rrd_query_agg($chart->interval, $aggregated, $chart->unit, $chart->period, $chart->resolution, $price);
    }
    else {
      $measurements = logger_rrd_query_sensor($chart->interval, $sensor, $chart->unit, $chart->period, $chart->resolution, $price);
    }

    $data['series'][$sensor->uid][$sensor->username][$sensor->meter][$sensor->type] = logger_format_power_series_data($chart, $measurements);

    //Hide usernames for Visitors
    $username = $sensor->uid != $user->uid && $is_visitor ? t('User') . ' ' . str_pad($sensor->uid, 3, '0', STR_PAD_LEFT) : $sensor->username;

    $operations = logger_create_remove_power_series_link($sensor->uid, $i, $username);

    $data['legend'][] = logger_create_power_legend_line($username, $sensor->function, t($sensor->type), $i++, $operations);
  }
  return $data;
}

/**
 * Returns an array containing all self consumption chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_selfconsumption_chart_data($chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.rrd');

  $groups = array(PRODUCTION_SENSOR_TYPE => array(), CONSUMPTION_SENSOR_TYPE => array());
  foreach ($chart->sensors as &$sensor) {
    $groups[$sensor->type_id][] = $sensor;
  }

  $type_names = array();
  $all_values = array();
  foreach ($groups as $type_id => $sensors) {

    if (!empty($sensors)) {
      $type_names[$type_id] = $sensors[0]->type;
      $price = ($type_id == CONSUMPTION_SENSOR_TYPE) ? $chart->price1 : $chart->price2;

      $measurements[$type_id] = logger_rrd_query_agg($chart->interval, $sensors, $chart->unit, $chart->period, $chart->resolution, $price);
    }
  }

  if ($chart->net_production) {
    $measurements = logger_get_net_production_consumption($measurements, $chart->resolution);
    $type_names[PRODUCTION_SENSOR_TYPE] = 'Power Grid Supply';
    $type_names[CONSUMPTION_SENSOR_TYPE] = 'Power Grid Demand';
  }

  $data = array();
  $i = 0;
  foreach ($measurements as $type_id => $values) {

    $type_name = t($type_names[$type_id]);
    $data['series'][$user->uid][$user->name][t('All')][$type_name] = logger_format_power_series_data($chart, $values);
    $data['legend'][] = logger_create_power_legend_line($user->name, t('All'), $type_name, $i++);
  }
  return $data;
}

function logger_get_net_production_consumption($measurements, $resolution) {

  $net_production = array();
  foreach ($measurements as $type_id => $values) {
    foreach ($values as $time => $value) {

      $net_production[$time] = isset($net_production[$time]) ? $net_production[$time] : 0;
      $net_production[$time] += $value * ($type_id == CONSUMPTION_SENSOR_TYPE ? -1 : 1);
    }
  }

  $negative = FALSE;
  $net_consumption = array();
  foreach ($net_production as $time => $value) {

    if ($value < 0 && !$negative || $value > 0 && $negative) {
      $interception_time = $time - (int) ($resolution / 2);
      $net_production[$interception_time] = 0;
      $net_consumption[$interception_time] = 0;
      $negative = !$negative;
    }

    $net_consumption[$time] = $value > 0 ? NULL : $net_production[$time];
    $net_production[$time] = $value < 0 ? NULL : $net_production[$time];
  }
  ksort($net_production);
  ksort($net_consumption);

  return array(PRODUCTION_SENSOR_TYPE => $net_production, CONSUMPTION_SENSOR_TYPE => $net_consumption);
}

/**
 * Returns an array containing all power production forecast chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_forecast_chart_data($chart) {
  
  global $user;

  $is_visitor = user_has_role('Visitor');
  $data = logger_get_power_chart_data($chart);
  $total = count($chart->sensors);
  $i = $total;

  foreach ($chart->sensors as &$sensor) {

    $forecast = pvcast_get_forecast($sensor->meter, $chart->period['start'], $chart->period['end']);

    //Hide usernames for Visitors
    $username = $sensor->uid != $user->uid && $is_visitor ? t('User') . ' ' . str_pad($sensor->uid, 3, '0', STR_PAD_LEFT) : $sensor->username;

    $operations = logger_create_remove_power_series_link($sensor->uid, $i, $username);

    $data['series'][$sensor->uid][$sensor->username]["$sensor->meter Forecast"][$sensor->type] =
      logger_format_power_series_data($chart, $forecast);

    $data['legend'][] =
      logger_create_power_legend_line($username, $sensor->function . '  (' . t('Forecast') . ')', t($sensor->type), $i++, $operations);
  }
  return $data;
}

/**
 * Creates a link to remove power chart series.
 *
 * @param $uid      The user id.
 * @param $username The user name.
 * @param $i        The series number.
 * @return the link code.
 */
function logger_create_remove_power_series_link($uid, $i, $username) {
  return $uid > 0 ?
    '<a href="javascript: void(0)"
      OnClick="javascript: removePowerSeries(' . "$uid, $i, '$username', '" . LOGGER_LEGEND_TABLE_ID . "'" . ');">' .
      t('Remove') . '</a>' : '';
}

/**
 * Returns an array containing all overview chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_overview_chart_data($chart) {

  module_load_include('inc', 'logger', 'logger.rrd');

  $measurements = logger_rrd_query_agg($chart->interval, $chart->sensors, $chart->unit, $chart->period, $chart->resolution);

  $values = logger_format_power_series_data($chart, $measurements);
  $type = $chart->sensors[0]->type; //For instance, just consumption

  $data['series'][0][t('All')][t('All')][$type] = $values;
  $data['legend'][] = logger_create_power_legend_line(t('All'), t('All'), t($type), 0);

  return $data;
}

/**
 * Formats power consumption chart data series.
 * 
 * @param $measurements  The array of timestamp / value that form the data series.
 * @param $chart         The chart object with the format parameters.
 * @return the formatted data series.
 */
function logger_format_power_series_data($chart, $measurements) {

  $diff = $chart->offset / HOUR;
  $tz = 'GMT' . ($diff < 0 ? '-' : '+') . (abs($diff) > 9 ? '' : '0') . abs($diff) . '00';

  //Complete data points
  $start = $chart->period['start'] - $chart->period['start'] % $chart->resolution;
  $end   = $chart->period['end']   - $chart->period['end']   % $chart->resolution;

  for ($timestamp = $start; $timestamp <= $end; $timestamp += $chart->resolution) {
    $measurements[$timestamp] = isset($measurements[$timestamp]) ? $measurements[$timestamp] : NULL;
  }

  //Not all timestamps are multiples of $chart->resolution
  $formatted = array();
  foreach ($measurements as $timestamp => $value) {

    $key = date('Y-m-d H:i:s', $timestamp) . " $tz";
    $formatted[$key] = isset($value) ? number_format($value, 3, '.', '') : '';
  }
  return $formatted;
}

/**
 * Creates a line for the power consumption chart legend.
 * 
 * @param $username    The sensor user name.
 * @param $function    The sensor object.
 * @param $type        The sensor type.
 * @param $i           The line index.
 * @param $operations  The list of links that affect the sensor.
 * @return the legend line.
 */
function logger_create_power_legend_line($username, $function, $type, $i, $operations = NULL) {

  $line = array(
    t('User') => $username,
    t('Sensor') => $function,
    t('Type') => $type,
    t('Max') => "<div id='max$i'/>",
    t('Min') => "<div id='min$i'/>",
    t('Avg') => "<div id='avg$i'/>",
    t('Last') => "<div id='last$i'/>",
  );

  if ($operations) {
    $line[t('Operations')] = $operations;
  }
  return $line;
}

/**
 * Returns an array containing sensors owned by the informed users.
 *
 * @param $types         The types of sensors to be returned (default: all).
 * @param $user_ids      The user ids of sensor owners (default: all).
 * @param $virtual       Whether virtual sensors should be returned (default: false).
 * @param $only_forecast Whether only forecast sensors should be returned (default: false).
 * @return the array of sensors.
 */
function logger_get_sensors($types = NULL, $user_ids = NULL, $include_virtual = FALSE, $only_forecast = FALSE) {

  global $user;

  $query = db_select('logger_meters', 'm')
    ->fields('m', array('uid', 'meter', 'function', 'unit', 'virtual', 'forecast', 'price'))
    ->isNotNull('m.function');

  $query->join('logger_meter_type', 't', 't.id = m.type');
  $query->addField('t', 'name', 'type');
  $query->addField('t', 'id', 'type_id');

  if (user_has_role('Techniker')) {
    $query->addExpression('FALSE', 'private');
  }
  else {
    $query->join('logger_users', 'lu', 'lu.uid = m.uid');
    $query->addField('lu', 'private', 'private');
  }

  $query->join('users', 'u', 'u.uid = m.uid');
  $query->addField('u', 'name', 'username');

  if (!empty($types)) {
    $query->condition('m.type', $types, 'IN');
  }
  if (!empty($user_ids)) {
    $query->condition('u.uid', $user_ids, 'IN');
  }
  if (!$include_virtual) {
    $query->condition('m.virtual', 0);
  }
  if ($only_forecast) {
    $query->condition('m.forecast', 1);
  }

  $query->orderBy('u.name');
  $query->orderBy('m.function');

  $result = $query->execute();

  $sensors = array();
  foreach ($result as $sensor) {
    $sensors[] = $sensor;
  }
  return $sensors;
}

/**
 * Returns an array containing all sensors from other users, selected to be plotted on the chart.
 *
 * @param $types  The types of sensors to be returned.
 * @return the array of user sensors.
 */
function logger_get_subscribed_sensors($types) {

  global $user;

  $selected_users = logger_get_variable('selected_users', array());

  if (empty($selected_users)) {
    $selected_users = array($user->uid);
    logger_set_variable('selected_users', $selected_users);
  }

  return logger_get_sensors($types, $selected_users, TRUE);
}

/**
 * Returns an array containing the sensors aggregated by a virtual sensor.
 * 
 * @param $virtual_meter The virtual sensor id.
 * @return the array of aggregated sensors.
 */
function logger_get_aggregated_sensors($virtual_meter) {

  if ($virtual_meter) {

    $query = db_select('logger_aggregated_meters', 'm')
    ->fields('m', array('meter'))
    ->condition('m.virtual_meter', $virtual_meter, '=');

    return db_query_objects($query);
  }
  else {
    return array();
  }
}

/**
 * Returns an array of user devices' serial numbers indexed by their respective
 * hash codes.
 *
 * @return the array of devices.
 */
function logger_get_devices_options() {

  global $user;

  $devices = array();
  if ($user->uid) {

    $sql = "SELECT serial, device FROM {logger_devices} WHERE uid = :uid ORDER BY serial";
    $result = db_query($sql, array(':uid' => $user->uid));

    foreach ($result as $row) {
      $devices[$row->device] = $row->serial;
    }
  }
  return $devices;
}

function logger_theme() {

  return array(
    'logger_power_chart_area' => array(
      'variables' => array(
        'chart' => NULL,
      ),
    ),
    'logger_energy_chart_area' => array(
      'variables' => array(
        'chart' => NULL,
      ),
    ),
    'logger_overview_topic' => array(
      'variables' => array(
        'title' => NULL,
        'body' => NULL,
        'link' => NULL,
      ),
    ),
    'logger_chart_tabs' => array(
      'items' => array()
    ),
    'logger_smoothing_level' => array(
      'render element' => 'element',
    ),
    'logger_value_range' => array(
      'render element' => 'element',
    ),
    'logger_time_period' => array(
      'render element' => 'element',
    ),
    'logger_geo_location' => array(
      'render element' => 'element',
    ),
    'logger_color_picker' => array(
      'variables' => array(
        'chartId' => NULL,
        'index' => NULL,
        'colors' => NULL,
      ),
    )
  );
}

/**
 * Builds a topic of the Overview page.
 *
 * @param $title  The topic title.
 * @param $body   The topic body.
 * @param $link   The topic link.
 * @return the topic.
 */
function theme_logger_overview_topic($variables) {

  $title = $variables['title'];
  $body = $variables['body'];
  $link = $variables['link'];
  $output = '';

  if ($title) {
    $output .= '<br><h3 class="node-headline">' . $title . '</h3>';
  }
  $output .= "<p> $body </p>";

  if ($link) {
    $output .= '<p>' . l(t('read more'), $link) . '</p>';
  }
  return $output;
}

/**
 * Builds the power chart area.
 *
 * @param $chart   The power chart object.
 * @return the power chart area output.
 */
function theme_logger_power_chart_area($variables) {

  $chart = $variables['chart'];

  //TODO: create a proper argument in function create_chart_object
  $chart->show_slider = ($chart->context != "forecast");

  $xvalue1 = $chart->xaxis[0] * 1000;
  $xvalue2 = $chart->xaxis[1] * 1000;
  $yvalue1 = $chart->yaxis[0] + 0;
  $yvalue2 = $chart->yaxis[1] + 0;

  $chart_properties = array(
    'dateWindow' => "[$xvalue1, $xvalue2]",
    'drawCallback' => 'updatePowerChartForm',
    //'zoomCallback' => 'updateSliderChart',
    'pointClickCallback' => 'addPowerAnnotation',
    'stepPlot' => $chart->step_plot ? 'true' : 'false' ,
    'rollPeriod' => $chart->smooting_level,
    'fillGraph' => $chart->filled ? 'true' : 'false' 
  );

  if ($yvalue1 >= 0 && $yvalue2 > 0) {
    $chart_properties['valueRange'] = "[$yvalue1, $yvalue2]";
  }

  $options = logger_get_power_units_options();
  $unit = $options[$chart->unit];

  $icons = "<a href='javascript: expandPowerChart();'><img src='/" . LOGGER_REL_PATH . "/img/expand.png'></a>";

  $output = logger_create_interval_menu($chart->context) .
    '<div style="float: right;">' . $icons . '</div>' .
    '<div>' . t($unit) . '</div>' .
    logger_create_dygraph($chart, TRUE, $chart_properties);

  if ($chart->show_slider) {

    $slider_properties = array(
      'gridLineColor' => '"transparent"',
      'yValueFormatter' => 'hideZero',
      'zoomCallback' => 'updatePowerChart',
      'clickCallback' => 'slidePowerChart',
      'underlayCallback' => 'highlightPowerChart',
      'stepPlot' => $chart_properties['stepPlot'],
      'rollPeriod' => $chart_properties['rollPeriod'],
      'fillGraph' => $chart_properties['fillGraph']
    );

    $output .= logger_create_dygraph($chart, FALSE, $slider_properties, TRUE);
  }

  $output .= logger_create_chart_legend($chart);

  return $output;
}

/**
 * Builds the energy consumption chart area.
 *
 * @param $chart   The energy consumption chart object.
 * @return the chart area output.
 */
function theme_logger_energy_chart_area($variables) {

  $chart = $variables['chart'];
  $data_labels = array();
  $series = array();
  $names = array();

  if ($chart->data['series'] && $chart->data['labels']) {

    foreach ($chart->data['series'] as $uid => $userdata) {
      foreach ($userdata as $username => $sensors) {
        foreach ($sensors as $sensor => $sensordata) {
          foreach ($sensordata as $type => $values) {
            $series[] = implode(', ', $values);
          }
        }
      }
    }
    $names = array_keys($values);

    foreach ($chart->data['labels'] as $function => $typedata) {
      foreach ($typedata as $type => $values) {
        $data_labels[] = implode(', ', $values);
      }
    }
  }

  $id = 'barChart';
  $menu = $chart->context == 'energy' ? logger_create_interval_menu($chart->context) : '';

  return " $menu
    <div id='$id' class='chart'></div>
    <script type='text/javascript'>
      createBarChart('$id',
        [ [ " . implode('], [', $series) . " ] ],
        ['" . implode("', '", $names) . "'],
        ['" . implode("', '", $chart->colors) . "'],
        [ [ " . implode('], [', $data_labels) . " ] ], " .
        ($chart->stacked ? 'true' : 'false') . ");
    </script>" .

    '<br>' . t('Unit') . ': ' . t($chart->unit) .

    '<br><br>' . logger_create_chart_legend($chart);
}

/**
 * Creates a Dygraph chart.
 *
 * @param $chart          The chart object.
 * @param $create_labels  If a div needs to be created to show labels.
 * @param $properties     The Dygraph properties.
 * @param $slider         If the chart is a slider.
 * @return the Dygraph output.
 */
function logger_create_dygraph($chart, $create_labels, $properties = array(), $slider = FALSE) {

  $properties = array_merge($properties, array(
      'labelsDiv' => '"chartLabels"',
      'colors' => '["' . implode('","', $chart->colors) . '"]',
      'includeZero' => 'true',
    )
  );

  $labels_output = isset($create_labels) ? '<div id=' . $properties['labelsDiv'] . ' class="legend"></div>' : '';

  foreach ($properties as $key => $value) {
    $pairs[] = "$key: $value";
  }

  $cssClass = $slider ? 'slider' : 'chart';
  $id = $slider ? 'sliderChart' : 'lineChart';

  return '<div id="' . $id . '" class="' . $cssClass . '"></div><br>' .
    $labels_output .
    '<script type="text/javascript">
       createLineChart("' . $id . '", "' . $chart->file_url . '", {' . implode(', ', $pairs) . ' });
    </script> ';
}

/**
 * Creates the chart intervals' horizontal menu.
 *
 * @param $context  The page where the menu is going to be placed.
 * @return the list of intervals' menus.
 */
function logger_create_interval_menu($context) {

  if ($context == 'energy') {
    $items = array(
      l(t('Day'),     "$context/day"),
      l(t('Week'),    "$context/week"),
      l(t('Month'),   "$context/month"),
      l(t('Year'),    "$context/year")
    );
  }
  elseif ($context == 'forecast') {
    $items = array(
      l(t('3 Days'), "$context/f3days"),
      l(t('2 Days'), "$context/f2days"),
      l(t('Today'),  "$context/f1day")
    );
  }
  else {
    $items = array(
      l(t('Hour'),    "$context/hour"),
      l(t('Day'),     "$context/day"),
      l(t('3 Days'),  "$context/3days"),
      l(t('Week'),    "$context/week"),
      l(t('Month'),   "$context/month"),
      l(t('Year'),    "$context/year")
    );
  }
  return theme('logger_chart_tabs', $items);
}

/**
 * Builds the chart legend.
 *
 * @param $chart  The chart object.
 * @return the chart legend table.
 */
function logger_create_chart_legend($chart) {

  if (!isset($chart->data['legend'])) {
    return '';
  }
  $data = $chart->data['legend'];

  $lines = array();
  $header = array(
    array('data' => ''),
  );

  foreach ($data as $line_id => $cells) {

    $mark = theme('logger_color_picker', array('chartId' => $chart->context, 'index' => $line_id, 'colors' => $chart->colors));

    $lines[$line_id] = array(
      array('data' => $mark),
    );

    foreach ($cells as $title => $value) {

      if (is_numeric($value)) {
        $value = $value > 0 ? number_format($value, 2) : '';
        $align = 'right';
      }
      else {
        $align = 'left';
      }

      $lines[$line_id][] = array(
        'data' => $value,
        'align' => $align,
      );
      $header[$title] = array('data' => t($title));
    }
  }
  $options = array('type' => 'inline', 'scope' => 'header');

  drupal_add_js("jQuery(window).resize( function() { resizeLegend('" . LOGGER_LEGEND_TABLE_ID . "'); resizeCharts(); } );", $options);
  drupal_add_js("jQuery(document).ready( function() { resizeLegend('" . LOGGER_LEGEND_TABLE_ID . "'); } );", $options);

  return theme_table(array('header' => $header, 'rows' => $lines, 'attributes' => array('id' => LOGGER_LEGEND_TABLE_ID, 'class' => 'resizable'),
    'caption' => '', 'empty' => '', 'sticky' => FALSE, 'colgroups' => array())) .
    '<p align="right">' . l(t('Save Data'), $chart->file_url) . '</p>';
}

/**
 * Returns the list of colors used in chart series.
 *
 * @param $chart_id   The chart id.
 * @return array of colors.
 */
function logger_get_series_colors($chart_id) {

  $palettes['power'] = array(
    '#0000FC', //BLUE
    '#C11700', //RED
    '#4D7060', //GREEN4
    '#B54FC6', //PINK
    '#F37E2B', //ORANGE
    '#809090', //GREY
    '#665C00', //BROWN
    '#050305', //BLACK
    '#0080FF', //SKYBLUE
    '#00FF00', //GREEN2
    '#DED00F', //BROWN2
    '#377037', //GREEN
    '#F27D79', //PINK2
    '#00ffff', //CYAN
    '#FBEB0D', //YELLOW
    '#5DA3CF', //BLUE2
    '#C0C0C0', //GRAY2
    '#BFD9D3', //GREEN5
    '#4D7060'  , //GREEN4
  );
  $palettes['energy'] = array_reverse($palettes['power']);
  $palettes['overview'] = $palettes['power'];
  $palettes['relative'] = $palettes['energy'];

  $palette = isset($palettes[$chart_id]) ? $palettes[$chart_id] : $palettes['power'];

  for ($i = 0; $i < count($palette); $i++) {
    $default = $palette[$i % count($palette)];
    $user_palette[$i] = logger_get_variable("series_color_$chart_id" . "_$i", $default);
  }
  return $user_palette;
}

function logger_block_info() {
  $blocks['posts']['info'] = t('Recent blog posts');
  $blocks['posts']['status'] = TRUE;
  $blocks['posts']['region'] = 'right';
  $blocks['posts']['weight'] = 3;
  $blocks['posts']['pages'] = '<front>\nlogger/\nlogger/*';
  $blocks['posts']['cache'] = 0x0008;
  return $blocks;
}

function logger_block_view($delta) {
  
  $block = array();
  if ($delta == 'posts' && user_access('access content')) {

    $sql = "
      SELECT
        n.nid,
        n.title,
        n.created
      FROM
        {node} n
      WHERE
        n.type = :type AND
        n.status = :status
      ORDER BY
        n.created DESC";

    $result = db_query_range($sql, 0, 5, array('type' => 'blogpost', ':status' => 1));
    
    $node_title_list = node_title_list($result);

    if ($node_title_list) {
      $block['subject'] = t('Recent blog posts');
      $block['content'] = $node_title_list;
      $block['content'] .= theme('more_link', array('url' => url('blog'), 'title' => t('Read the latest blog entries.')));
    }
  }
  return $block;
}

function logger_mail_alter(&$message) {

  global $base_url;

  switch ($message['id']) {
    case 'contact_page_mail':

      //Completes the user contact e-mail with a link to his list of devices
      $message['body'][] = l(t("User Devices:"), "$base_url/deployment/list?user_name=" . $message['params']['name']);
      break;
  }
}

function logger_energychart_form($form, &$form_state, $chart) {

  global $user;

  $types_options = logger_get_sensor_types_options($user->uid);
  $selected_types = logger_get_variable('selected_sensor_types', array_keys($types_options));

  $form['#validate'] = array('logger_chartform_validate');

  $form['aggregate_sensors'] = array(
    '#type' => 'checkbox',
    '#title' => t("Sum of sensor readings"),
    '#description' => t('Do you want to sum up all sensors?'),
    '#default_value' => logger_get_variable('aggregate_sensors', 1),
    '#return_value' => 1,
    '#attributes' => array('onclick' => 'submitEnergyChartForm(this)'), //In IE, onchange does not work
  );

  $form['selected_sensor_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Sensor types'),
    '#description' => t('Select the types of sensors to be shown on the chart.'),
    '#default_value' => $selected_types,
    '#options' => $types_options,
    '#required' => TRUE,
    '#attributes' => array('onclick' => 'submitEnergyChartForm(this)'), //In IE, onchange does not work
  );

  $form['unit'] = array(
    '#type' => 'select',
    '#title' => t('Unit'),
    '#description' => t('Select the chart unit.'),
    '#options' => logger_get_energy_units_options(),
    '#default_value' => $chart->unit,
    '#required' => TRUE,
    '#attributes' => array('onchange' => 'submitEnergyChartForm(this)'),
  );

  //TODO: enable these fields for experts
  /*
  if (strpos(" $chart->unit", 'eur') > 0) {
    $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);

    $form['use_sensor_prices'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use sensor prices'),
      '#description' => t('Do you want the chart series to use the prices defined for each sensor?'),
      '#default_value' => $use_sensor_prices,
      '#return_value' => 1,
      '#attributes' => array('onclick' => 'submitEnergyChartForm()'), //In IE, onchange does not work
    );

    if (!$use_sensor_prices) {

      if (in_array(CONSUMPTION_SENSOR_TYPE, $selected_types)) {
        $form['price1'] = array(
          '#type' => 'textfield',
          '#title' => t('Energy Consumption Price'),
          '#description' => t("Enter the energy consumption price."),
          '#maxlength' => 6,
          '#field_prefix' => ' ',
          '#default_value' => $chart->price1,
          '#field_suffix' => ' / kWh',
        );
      }
      if (in_array(PRODUCTION_SENSOR_TYPE, $selected_types)) {
        $form['price2'] = array(
          '#type' => 'textfield',
          '#title' => t('Energy Production Price'),
          '#description' => t("Enter the energy production price."),
          '#maxlength' => 6,
          '#field_prefix' => ' ',
          '#default_value' => $chart->price2,
          '#field_suffix' => ' / kWh',
        );
      }
    }
  }
  */

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Refresh'),
  );
  return $form;
}

function logger_relativechart_form($form, &$form_state, $chart) {

  $meter_options = logger_get_meters_options($chart->types);

  $form['#validate'] = array('logger_chartform_validate');

  $form['selected_meters'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Sensors'),
    '#description' => t('Select the sensors you want to plot on the chart.'),
    '#default_value' => logger_get_variable('selected_meters', array_keys($meter_options)),
    '#options' => $meter_options,
    '#required' => TRUE,
    '#attributes' => array('onclick' => 'submitRelativeChartForm(this)'), //In IE, onchange does not work
  );

  $form['unit'] = array(
    '#type' => 'select',
    '#title' => t('Unit'),
    '#description' => t('Select the chart unit.'),
    '#options' => logger_get_energy_units_options(),
    '#default_value' => $chart->unit,
    '#required' => TRUE,
    '#attributes' => array('onchange' => 'submitRelativeChartForm(this)'),
  );

  //TODO: enable these fields for experts
  /*
  if (strpos(" $chart->unit", 'eur') > 0) {
    $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);

    $form['use_sensor_prices'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use sensor prices'),
      '#description' => t('Do you want the chart series to use the prices defined for each sensor?'),
      '#default_value' => $use_sensor_prices,
      '#return_value' => 1,
      '#attributes' => array('onclick' => 'submitRelativeChartForm()'), //In IE, onchange does not work
    );

    if (!$use_sensor_prices) {
      $form['price1'] = array(
        '#type' => 'textfield',
        '#title' => t('Energy Consumption Price'),
        '#description' => t("Enter the energy consumption price."),
        '#maxlength' => 6,
        '#size' => 6,
        '#field_prefix' => ' ',
        '#default_value' => $chart->price1,
        '#field_suffix' => ' / kWh',
      );
    }
  }
  */

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Refresh'),
  );
  return $form;
}

function logger_powerchart_form($form, &$form_state, $chart) {

  global $base_path;

  if ($chart->context == 'power') {

    $form['new_user'] = array(
      '#type' => 'select',
      '#title' => t('Add User'),
      '#description' => t('Select a user to be added to the chart.'),
      '#options' => logger_get_users_options(),
      '#default_value' => 0,
      '#attributes' => array('onchange' => 'submitPowerChartForm(true)'),
    );
  }

  $form['unit'] = array(
    '#type' => 'select',
    '#title' => t('Unit'),
    '#description' => t('Select the chart unit.'),
    '#options' => logger_get_power_units_options(),
    '#default_value' => $chart->unit,
    '#required' => TRUE,
    '#attributes' => array('onchange' => 'submitPowerChartForm(true)'),
  );

  //TODO: enable these fields for an expert role
  /*
  if (strpos(" $chart->unit", 'eur') > 0) {
    $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);

    $form['use_sensor_prices'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use sensor prices'),
      '#description' => t('Do you want the chart series to use the prices defined for each sensor?'),
      '#default_value' => $use_sensor_prices,
      '#return_value' => 1,
      '#attributes' => array('onclick' => 'submitPowerChartForm()'), //In IE, onchange does not work
    );

    if (!$use_sensor_prices) {

      if ($chart->price1) {
        $form['price1'] = array(
          '#type' => 'textfield',
          '#title' => t('Energy Consumption Price'),
          '#description' => t("Enter the energy consumption price."),
          '#maxlength' => 6,
          '#field_prefix' => ' ',
          '#default_value' => $chart->price1,
          '#field_suffix' => ' / kWh',
        );
      }
      if ($chart->price2) {
        $form['price2'] = array(
          '#type' => 'textfield',
          '#title' => t('Energy Production Price'),
          '#description' => t("Enter the energy production price."),
          '#maxlength' => 6,
          '#field_prefix' => ' ',
          '#default_value' => $chart->price2,
          '#field_suffix' => ' / kWh',
        );
      }
    }
  }
  */

  $form['smoothing_level'] = array(
    '#type' => 'textfield',
    '#theme' => 'logger_smoothing_level',
    '#title' => t('Smoothing Level'),
    '#description' => t("Increase this number to smooth the series' lines and make the chart more readable."),
    '#maxlength' => 3,
    '#size' => 3,
    '#text-align' => 'center',
    '#default_value' => logger_get_variable('smooting_level', 1),
    '#required' => TRUE,
  );

  $form['step_plot'] = array(
    '#type' => 'checkbox',
    '#title' => t('Stepped Lines'),
    '#description' => t('Do you want the chart series to use stepped lines?'),
    '#default_value' => logger_get_variable('step_plot', 0),
    '#return_value' => 1,
    '#attributes' => array('onclick' => 'submitPowerChartForm()'), //In IE, onchange does not work
  );

  $form['filled_graph'] = array(
    '#type' => 'checkbox',
    '#title' => t('Filled Lines'),
    '#description' => t('Do you want the chart series to use filled lines?'),
    '#default_value' => logger_get_variable('filled_graph', 0),
    '#return_value' => 1,
    '#attributes' => array('onclick' => 'submitPowerChartForm()'), //In IE, onchange does not work
  );

  //TODO: enable this field for experts
  /*
  if ($chart->context == 'selfconsumption') {
    $form['net_production'] = array(
      '#type' => 'checkbox',
      '#title' => t('Net Energy Production'),
      '#description' => t('Do you want the chart series to show your net energy production?'),
      '#default_value' => logger_get_variable('net_production', 1),
      '#return_value' => 1,
      '#attributes' => array('onclick' => 'enableFilledGraph(); submitPowerChartForm(true);'), //In IE, onchange does not work
    );
  }
  */

  $form['yvalue'] = array(
    '#type' => 'textfield',
    '#theme' => 'logger_value_range',
    '#title' => t('Value Range'),
    '#description' => t("Enter the value range shown on the Y axis, and click the Refresh button."),
    '#maxlength' => 12,
    '#size' => 12,
    '#text-align' => 'right',
  );

  $form['xvalue'] = array(
    '#type' => 'textfield',
    '#theme' => 'logger_time_period',
    '#title' => t('Time Period'),
    '#description' => t("Enter the time period shown on the X axis, and click the Refresh button."),
    '#text-align' => 'center',
  );

  $options = $chart->context == 'forecast' ? array(HOUR => t('Hour')) : //TODO: include other resolutions
    logger_get_resolutions_options();
  
  $form['resolution'] = array(
    '#type' => 'select',
    '#title' => t('Time Resolution'),
    '#description' => t('Select the amount of time represented by each point on the chart.'),
    '#options' => $options,
    '#attributes' => array('onchange' => 'submitPowerChartForm()'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Refresh'),
  );
  return $form;
}

/**
 * Builds the chart tabs list.
 *
 * @param $items The tabs list items.
 * @return the tabs HTML code.
 */
function theme_logger_chart_tabs($items = array()) {

  $output = '<div class="tabs"><ul>';
  foreach ($items as $item) {
    $output .= "<li>$item</li>";
  }
  $output .= "</ul></div>";
  return $output;
}

/**
 * Builds the smoothing level field.
 *
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_smoothing_level($variables) {

  $element = $variables['element'];
  $id = $element['#id'];
  $value = check_plain($element['#value']);

  return
    logger_create_smoothing_button($id, '<<', -10) .
    logger_create_smoothing_button($id, '<',   -1) .

    logger_create_custom_field($element, '', $value) .

    logger_create_smoothing_button($id, '>',    1) .
    logger_create_smoothing_button($id, '>>',   10);
}

/**
 * Creates a button to update the chart smoothing level.
 *
 * @param $field_id  The smoothing level field id.
 * @param $caption   The button caption text.
 * @param $step      The smoothing steps to be triggered when the button is pressed.
 * @return the button HTML code.
 */
function logger_create_smoothing_button($field_id, $caption, $step) {
  return '<input type="button" value="' . $caption . '" ' .
    'onClick="javascript: return updateSmoothingLevel(' . "'$field_id', " . $step . ');"/>';
}

/**
 * Creates a composite field for informing geographic location.
 * 
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_geo_location($variables) {

  $element = $variables['element'];
  $coordinates = check_plain($element['#value']);
  $latitude = strtok($coordinates, ',');
  $longitude = strtok(',');

  drupal_add_js("jQuery(document).ready(function(){createMap($latitude, $longitude);});", array('type' => 'inline', 'scope' => 'header'));

  $latitude_field = logger_create_custom_field($element, '_latitude', $latitude, 11, 11);
  $longitude_field = logger_create_custom_field($element, '_longitude', $longitude, 11, 11);

  return '<div>' .
    t('Latitude') . ": $latitude_field &nbsp;&nbsp;" .
    t('Longitude') . ": $longitude_field </div>" .
    '<div id="map" class="map"></div>';
}

/**
 * Builds the group of fields for informing value range.
 *
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_value_range($variables) {

  $element = $variables['element'];
  $field1 = logger_create_custom_field($element, 1, '');
  $field2 = logger_create_custom_field($element, 2, '');

  return logger_compose_range_fields($element, $field1, $field2);
}

/**
 * Builds the group of fields for informing a time period.
 *
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_time_period($variables) {

  $element = $variables['element'];
  $field1 = logger_create_time_fields($element, 1);
  $field2 = logger_create_time_fields($element, 2);

  return logger_compose_range_fields($element, $field1, $field2);
}

/**
 * Builds a color picker component.
 *
 * @param $i          The color index.
 * @param $colors     The array of colors.
 * @param $picker_id  The picker id.
 * @return the picker HTML code.
 */
function theme_logger_color_picker($variables) {

  $chart_id = $variables['chartId'];
  $i = $variables['index'];
  $colors = $variables['colors'];
  $id = 'series_color' . $i;

  return '
    <input
      class="color {valueElement:' . "'$id'" . '}
      type="button"
      style="width: 10px; height: 10px; color: transparent;"/>

    <input
      id="' . $id . '"
      type="hidden"
      value="' . $colors[$i % count($colors)] . '"
      onchange="javascript: ' . "setSeriesColor('$chart_id', $i, this.value)" . ';"/>';
}

/**
 * Creates two fields to represent a timestamp: one for date and another for time.
 *
 * @param $element  The Drupal form field element.
 * @param $suffix   A suffix for the field id and name.
 * @return the fields HTML code.
 */
function logger_create_time_fields($element, $suffix) {

  $picker_properties = "{
      yearRange: '-1:+0',
      showAnim: 'fadeIn',
      dateFormat: 'dd/mm/yy',
      currentText: '" . t('Today') . "',
      nextText: '" . t('Next Month') . "',
      prevText: '" . t('Previous Month') . "',
      dayNamesMin: [" . t("'Su','Mo','Tu','We','Th','Fr','Sa'") . "],
      monthNames: ['" . t('January') . "', '" . t('February') . "', '" . t('March') . "', '" . t('April') . "', '" . t('May') . "', '" . t('June') . "', '" . t('July') . "', '" . t('August') . "', '" . t('September') . "', '" . t('October') . "', '" . t('November') . "', '" . t('December') . "']
    }";

  drupal_add_js('jQuery(document).ready(function(){jQuery("#edit-xvalue' . $suffix . 'date").datepicker(' . $picker_properties . ');});', array('type' => 'inline', 'scope' => 'header'));

  return logger_create_custom_field($element, $suffix . 'date', '', 10, 10) .
    logger_create_custom_field($element, $suffix . 'time', '', 5, 5);
}

/**
 * Arranges fields to represent a range.
 *
 * @param $element  The Drupal form field element.
 * @param $field1   The field that contains the lowest value.
 * @param $field2   The field that contains the highest value.
 * @return the fields HTML code.
 */
function logger_compose_range_fields($element, $field1, $field2) {

  return '<span style="white-space:nowrap;">' .
    t('from:') . $field1 . '&nbsp;&nbsp;&nbsp;' . '</span>' .
    '<span style="white-space:nowrap;">' .
    t('to:') . '&nbsp;&nbsp;' . $field2 . '</span>';
}

/**
 * Creates a customized form field.
 *
 * @param $element     The Drupal form field element.
 * @param $suffix      A suffix for the field id and name.
 * @param $value       The field value.
 * @param $size        The field size.
 * @param $maxlength   The field maximum length.
 * @return the field HTML code.
 */
function logger_create_custom_field($element, $suffix, $value, $size = 0, $maxlength = 0) {

  $name = $element['#name'] . $suffix;
  $id = $element['#id'] . $suffix;
  $align = $element['#text-align'] . ';';
  $size = $size > 0 ? $size : $element['#size'];
  $maxlength = $maxlength > 0 ? $maxlength : $element['#maxlength'];

  $attributes = isset($element['#attributes']) ? drupal_attributes($element['#attributes']) : '';

  return '<input type="text" ' .
    'name="' . $name . '" ' .
    'id="' . $id . '" ' .
    'maxlength="' . $maxlength . '" ' .
    'size="' . $size . '" ' .
    'value="' . $value . '" ' .
    'style="text-align: ' . $align . '" ' .
    $attributes . ' />';
}

function logger_powerchart_form_validate($form, &$form_state) {

  if ($form_state['values']['smoothing_level'] < 1) {
    form_set_error('smoothing_level', t('The smoothing level must be greater than 0.'));
  }
  if ($form_state['values']['step_plot'] != 1 && $form_state['values']['step_plot'] != 0) {
    form_set_error('step_plot', t('The stepped lines option must be either 0 or 1.'));
  }
  if ($form_state['values']['filled_graph'] != 1 && $form_state['values']['filled_graph'] != 0) {
    form_set_error('filled_graph', t('The filled lines option must be either 0 or 1.'));
  }

  $yvalue1 = logger_get_yvalue(1);
  $yvalue2 = logger_get_yvalue(2);

  if (!($yvalue1 == '' && $yvalue2 == '') && !($yvalue2 > $yvalue1)) {
    form_set_error('yvalue', t('The value range is invalid.'));
  }

  $xvalue1 = logger_get_xvalue(1);
  $xvalue2 = logger_get_xvalue(2);

  if (!($xvalue2 > $xvalue1)) {
    form_set_error('xvalue', t('Time period is invalid.'));
  }

  logger_chartform_validate($form, $form_state);
}

function logger_chartform_validate($form, &$form_state) {

  if (isset($form_state['values']['price1']) && !is_numeric($form_state['values']['price1'])) {
    form_set_error('price1', t('The price is invalid.'));
  }

  if (isset($form_state['values']['price2']) && !is_numeric($form_state['values']['price2'])) {
    form_set_error('price2', t('The price is invalid.'));
  }
}

function logger_energychart_form_submit($form, &$form_state) {

  if (isset($form_state['values']['use_sensor_prices'])) {
    logger_set_variable('use_sensor_prices', $form_state['values']['use_sensor_prices']);
  }
  if (isset($form_state['values']['price1'])) {
    logger_set_variable('price1', $form_state['values']['price1']);
  }
  if (isset($form_state['values']['price2'])) {
    logger_set_variable('price2', $form_state['values']['price2']);
  }

  logger_set_variable('aggregate_sensors', $form_state['values']['aggregate_sensors']);
  logger_set_variable('selected_sensor_types', $form_state['values']['selected_sensor_types']);
  logger_set_variable('energychart_unit', $form_state['values']['unit']);
}

function logger_powerchart_form_submit($form, &$form_state) {

  if ($form_state['values']['new_user'] > 0) {
    logger_add_user($form_state['values']['new_user']);
  }
  if (isset($form_state['values']['use_sensor_prices'])) {
    logger_set_variable('use_sensor_prices', $form_state['values']['use_sensor_prices']);
  }
  if (isset($form_state['values']['price1'])) {
    logger_set_variable('price1', $form_state['values']['price1']);
  }
  if (isset($form_state['values']['price2'])) {
    logger_set_variable('price2', $form_state['values']['price2']);
  }
  if (isset($form_state['values']['net_production'])) {
    logger_set_variable('net_production', $form_state['values']['net_production']);
  }

  logger_set_variable('powerchart_unit', $form_state['values']['unit']);
  logger_set_variable('step_plot', $form_state['values']['step_plot']);
  logger_set_variable('filled_graph', $form_state['values']['filled_graph']);
  logger_set_variable('smooting_level', $form_state['values']['smoothing_level']);

  //FIXME: get rid of this redirection
  $form_state['redirect'] = array($_GET['q'], array('query' => $_REQUEST));
}

function logger_relativechart_form_submit($form, &$form_state) {

  if (isset($form_state['values']['use_sensor_prices'])) {
    logger_set_variable('use_sensor_prices', $form_state['values']['use_sensor_prices']);
  }
  if (isset($form_state['values']['price1'])) {
    logger_set_variable('price1', $form_state['values']['price1']);
  }

  logger_set_variable('selected_meters', $form_state['values']['selected_meters']);
  logger_set_variable('relativechart_unit', $form_state['values']['unit']);
}

/**
 * Returns a list of all sensor types.
 * 
 * @param $uid  The user id.
 * @return an array of sensor types.
 */
function logger_get_sensor_types_options($uid = NULL) {

  $query = db_select('logger_meter_type', 't');

  if (isset($uid)) {
    $query->join('logger_meters', 'm', 't.id = m.type');
    $query->condition('uid', $uid, '=');
  }

  $result = $query->fields('t', array('id', 'name'))
    ->distinct(TRUE)
    ->orderBy('id')
    ->execute();

  $options = array();
  foreach ($result as $type) {
    $options[$type->id] = t($type->name);
  }
  return $options;
}

/**
 * Returns a list of all meters of the informed type.
 *
 * @param $types    The sensor types.
 * @param $virtual  Whether virtual sensors should be returned.
 * @return an array of meters.
 */
function logger_get_meters_options($types, $virtual = FALSE) {

  global $user;

  $sensors = logger_get_sensors($types, array($user->uid), $virtual);
  $options = array();
  foreach ($sensors as $sensor) {
    $options[$sensor->meter] = $sensor->function;
  }
  return $options;
}

/**
 * Returns an array of power units indexed by their respective acronym.
 *
 * @return the array of units.
 */
function logger_get_power_units_options() {

  return array(
    'watt' => t('watt'),
    'kWh/year' => t('kWh/year'),
    'eur/year' => t('euro/year'),
  );
}

/**
 * Returns an array of energy units to be used as options of HTML select fields.
 */
function logger_get_energy_units_options() {

  return array(
    'kWh' => t('kWh'),
    'eur' => t('eur'),
  );
}

/**
 * Returns either the lowest or the highest value shown on the Y axis.
 *
 * @param $index Inform 1 for the lowest, 2 for the highest.
 * @return the value.
 */
function logger_get_yvalue($index) {

  return isset($_REQUEST['yvalue' . $index]) ? $_REQUEST['yvalue' . $index] : 0;
}

/**
 * Returns either the lowest or the highest value shown on the X axis.
 *
 * @param $index Inform 1 for the lowest, 2 for the highest.
 * @return the value.
 */
function logger_get_xvalue($index) {

  //Both need to be set
  if (!(isset($_REQUEST['xvalue' . $index . 'date']) && isset($_REQUEST['xvalue' . $index . 'time']))) {
    return 0;
  }

  $formatted = $_REQUEST['xvalue' . $index . 'date'] . ' ' . $_REQUEST['xvalue' . $index . 'time'];

  //Parses a datetime string formatted as dd/mm/yyyy hh:mm to a Unix timestamp.
  $str = "$formatted:00 GMT+00:00";
  $d = strtok($str, '/');
  $m = strtok('/');
  $r = strtok('/');
  $timestamp = strtotime("$m/$d/$r");
  $timestamp -= get_timezone_offset();

  return $timestamp > 0 ? $timestamp : 0;
}

/**
 * Returns the chart resolution of a time interval menu option.
 *
 * @param $interval  The time interval menu option.
 * @return the chart resolution.
 */
function logger_get_resolution($interval) {

  $resolution = isset($_REQUEST['resolution']) ? $_REQUEST['resolution'] : 0;
  if ($resolution > 0) {
    return $resolution;
  }

  $options = array(
    'hour' => 1 * MINUTE,
    'day' => 15 * MINUTE,
    '3days' => 15 * MINUTE,
    'week' => 15 * MINUTE,
    'month' => 1 * DAY,
    'year' => 1 * WEEK,
    'f3days' => 1 * HOUR,
    'f2days' => 1 * HOUR,
    'f1day' => 1 * HOUR
  );
  return $options[$interval];
}

/**
 * Returns an array of chart resolutions.
 *
 * @return the array of chart resolutions.
 */
function logger_get_resolutions_options() {

  return array(
    1 * MINUTE => 1 . ' ' . t('Minute'),
    15 * MINUTE => 15 . ' ' . t('Minutes'),
    1 * HOUR => 1 . ' ' . t('Hour'),
    1 * DAY => 1 . ' ' . t('Day'),
    1 * WEEK => 1 . ' ' . t('Week')
  );
}

/**
 * Returns the default time window associated with a time interval menu option.
 *
 * @param $interval  The time interval menu option.
 * @param $absolute  Whether the absolute value of the time window is to be returned.
 * @return the amount of seconds of the time window.
 */
function logger_get_default_time_window($interval, $absolute = TRUE) {

  $windows = array(
    'hour' => -1 * HOUR,
    'dayquarter' => -6 * HOUR,
    'day' => -1 * DAY,
    '3days' => -3 * DAY,
    'week' => -7 * DAY,
    'month' => -30 * DAY,
    'year' => -365 * DAY,
    'f3days' => 3 * DAY,
    'f2days' => 2 * DAY,
    'f1day' => 1 * DAY
  );
  $window = $windows[$interval];
  return ($absolute ? abs($window) : $window);
}

/**
 * Returns the sub parts that compose a time interval.
 * 
 * @param $interval  The time interval.
 * @return the sub interval name.
 */
function logger_get_sub_interval($interval) {

  $windows = array(
    'dayquarter' => 'hour',
    'day' => 'dayquarter',
    '3days' => 'day',
    'week' => 'day',
    'month' => 'week',
    'year' => 'month',
    'f3days' => 'day',
    'f2days' => 'day',
    'f1day' => 'hour'
  );
  return $windows[$interval];
}

/**
 * Returns an array containing two timestamps representing period of time of
 * the slider chart.
 *
 * @param $interval    The time interval menu option.
 * @param $resolution  The time resolution.
 * @param $start       The initial timestamp, if known.
 * @param $end         The final timestamp, if known.
 * @return the period of time as an array.
 */
function logger_get_period($interval, $resolution, $start = 0, $end = 0) {

  module_load_include('inc', 'logger', 'logger.rrd');
  $storage_period = logger_rrd_get_storage_period($resolution);

  //If period not informed, consider default time window
  $window = $start > 0 && $end > 0 ? $end - $start : logger_get_default_time_window($interval);

  $now = REQUEST_TIME;
  if ($end < ($now - $storage_period)) {
    $end = $now;
  }

  //Expand window to fill slider
  $window *= 7;

  //RRD requires the time window to be covered by RRD
  $max_window = $storage_period - ($now - $end);
  $window = min($window, $max_window);

  return array('start' => ($end - $window), 'end' => $end);
}

/**
 * Returns an array of fluksonian users indexed by their respective user id.
 * Only users not yet plotted on the chart are returned.
 *
 * @return the array of fluksonian users.
 */
function logger_get_users_options() {

  global $user;

  $selected_users = logger_get_variable('selected_users', array($user->uid));
  $is_visitor = user_has_role('Visitor');

  $sql = "
    SELECT
      u.uid,
      u.name
    FROM
      {users} u,
      {logger_meters} m
    WHERE
      m.function IS NOT NULL AND
      m.uid = u.uid AND
      u.uid NOT IN (:selected_users) AND
      u.uid > 0
    GROUP BY
      u.uid
    ORDER BY " .
      ($is_visitor ? 'u.uid' : 'u.name');

  $fluksonians = db_query($sql, array(':selected_users' => $selected_users));

  $options = array(0 => '');
  foreach ($fluksonians as $fluksonian) {

    //Hide user names for Visitors
    $username = $fluksonian->uid != $user->uid && $is_visitor ? t('User') . ' ' . str_pad($fluksonian->uid, 3, '0', STR_PAD_LEFT) : $fluksonian->name;
    $options[$fluksonian->uid] = $username;
  }
  return $options;
}

/**
 * Adds an user to the chart.
 *
 * @param $uid  The id of the user to be added.
 */
function logger_add_user($uid) {

  global $user;

  $selected_users = logger_get_variable('selected_users', array($user->uid));
  if (!in_array($uid, $selected_users)) {
    $selected_users[] = $uid;
    logger_set_variable('selected_users', $selected_users);
  }
}

/**
 * Removes an user from the chart.
 *
 * @param $uid  The id of the user to be removed.
 */
function logger_remove_user($uid) {

  $selected_users = logger_get_variable('selected_users', array());
  for ($i = 0; $i < count($selected_users); $i++) {
    if ($selected_users[$i] == $uid) {
      unset($selected_users[$i]);
    }
  }
  logger_set_variable('selected_users', array_values($selected_users));
}

/**
 * Returns the value of a persistent variable.
 *
 * @param $id            The variable id.
 * @param $default_value The value to be returned if the variable is not yet defined.
 * @return the variable value.
 */
function logger_get_variable($id, $default_value) {

  global $user;

  $id = "logger_$id";

  if (isset($user->uid)) {

    //Visitors must use cookies
    if (user_has_role('Visitor')) {
      return isset($_SESSION[$id]) ? $_SESSION[$id] : $default_value;
    }
    else {
      $id .= '_' . $user->uid;
      return variable_get($id, $default_value);
    }
  }
  else {

    $value = isset($_COOKIE[$id]) ? $_COOKIE[$id] : $default_value;
    if (strpos(" $value", 'ARR') == 1) {
      $value = explode(',', substr($value, 3));
    }
    return $value;
  }
}

/**
 * Sets the value of a persistent variable.
 *
 * @param $id     The variable id.
 * @param $value  The variable value.
 */
function logger_set_variable($id, $value) {

  global $user;

  $id = "logger_$id";

  if ($user->uid) {

    //Visitors must use cookies
    if (user_has_role('Visitor')) {
      $_SESSION[$id] = $value;
    }
    else {
      $id .= '_' . $user->uid;
      variable_set($id, $value);
    }
  }
  else {
    if (is_array($value)) {
      $value = 'ARR' . implode(',', $value);
    }
    setcookie($id, $value, REQUEST_TIME + WEEK, '/');
  }
}

function logger_request_appliance_detection($meter, $measurements) {

  $data = json_encode(array($meter => $measurements));

  //jobqueue_produce('appdetect', $data);
}

/**
 * Returns list detected appliances at a specific moment in time.
 *
 * @param $meter      The sensor id.
 * @param $timestamp  The timestamp.
 */
function logger_get_appliances($meter, $timestamp) {

  drupal_add_http_header('Content-Type', 'application/json;');

  $appliances = array();

  if (user_has_role('Techniker')) { 
    $appliances = array(1, 2, 3, 4);
  }

  print json_encode($appliances);

  exit(0);
}

function logger_form_alter(&$form, &$form_state, $form_id) {

  if ($form_id == 'user_login') {
    $form_state['#redirect'] = 'logger';
    $form['name']['#size'] = 20;
    $form['pass']['#size'] = 20;
  }
}

function logger_account_access($permission) {

  global $user;

  return $user->uid == $GLOBALS['user']->uid && user_access($permission);
}

/**
 * Access callback ensuring the sensor is accessible only to the owner.
 */
function logger_sensor_access($permission, $meter) {

  if ($GLOBALS['user']->uid == 1) {
    return TRUE;
  }

  $uid = db_select('logger_meters', 'm')
    ->fields('m', array('uid'))
    ->condition('m.meter', $meter, '=')
    ->execute()
    ->fetchField();

  return $uid == $GLOBALS['user']->uid && user_access($permission);
}

/**
 * Access callback ensuring the device is accessible only to the owner.
 */
function logger_device_access($permission, $device) {
  
  if ($GLOBALS['user']->uid == 1) {
    return TRUE;
  }

  $uid = db_select('logger_devices', 'd')
    ->fields('d', array('uid'))
    ->condition('d.device', "$device%", 'LIKE')
    ->execute()
    ->fetchField();

  if ($permission == 'activate devices') {
    $rid = get_role_id('Visitor');
    return $uid == 0 && empty($GLOBALS['user']->roles[$rid]);
  }
  else {
    return $uid == $GLOBALS['user']->uid && user_access($permission);
  }
}

/**
 * Access callback ensuring the producer pages are accessible only to users who have production sensors.
 */
function logger_producer_access($permission) {

  if ($GLOBALS['user']->uid == 1) {
    return TRUE;
  }

  $sensor = db_select('logger_meters', 'm')
    ->fields('m', array('uid'))
    ->condition('m.uid', $GLOBALS['user']->uid, '=')
    ->condition('m.type', PRODUCTION_SENSOR_TYPE)
    ->execute()
    ->fetchObject();

  return $sensor && user_access($permission);
}

/**
 * Access callback ensuring the sensor forecast page is accessible only to users who have requested forecasts.
 */
function logger_forecast_access($permission) {

  if ($GLOBALS['user']->uid == 1) {
    return TRUE;
  }

  $sensor = db_select('logger_meters', 'm')
    ->fields('m', array('uid'))
    ->condition('m.uid', $GLOBALS['user']->uid, '=')
    ->condition('m.forecast', 1, '=')
    ->execute()
    ->fetchObject();

  return $sensor && user_access($permission);
}

/**
 * Queries the databases for measurements reported by sensors of a single device.
 *
 * @param $interval The time interval.
 * @param $device   The device's hash code.
 * @return the array of sensors' measurements, formatted as [meter][function][ [timestamp, value] ].
 */
function logger_query_device_measurements($interval, $device) {

  module_load_include('inc', 'logger', 'logger.rrd');

  $sql = "SELECT meter, function, price FROM {logger_meters} WHERE device = :device";
  $sensors = db_query($sql, array(':device' => $device));

  $resolution = logger_get_resolution($interval);
  $period = logger_get_period($interval, $resolution);

  $measurements = array();
  foreach ($sensors as $sensor) {

    $measurements[$sensor->meter][$sensor->function] = logger_rrd_query_sensor($interval, $sensor, 'watt', $period, $resolution);
  }
  return $measurements;
}

function logger_cron() {

  logger_remove_expired_support_requests();
  logger_bind_support_ports();

  logger_update_support_authorized_keys();

  logger_update_pvcast_models();
}

/**
 * Removes expired device support requests.
 */
function logger_remove_expired_support_requests() {

  //Remove old requests
  $timeout = REQUEST_TIME - 2 * DAY;

  db_delete('device_support_request')
    ->condition('requested', $timeout, '<')
    ->execute();

  $sql = "
    SELECT
      device
    FROM
      {device_support_slot}
    WHERE
      device IS NOT NULL AND
      NOT EXISTS(
        SELECT
          1
        FROM
          {device_support_request} r
        WHERE
          r.device = device_support_slot.device
      )";

  $result = db_query($sql);

  foreach ($result as $device) {

    db_update('device_support_slot')
      ->fields(array(
      'device' =>  NULL,
    ))
    ->condition('device', $device->device)
    ->execute();

    logger_remove_support_key($device->device);
  }
}

/**
 * Binds device support requests with available hosts/ports for reverse SSH connections.
 */
function logger_bind_support_ports() {

  //Find devices with pending support requests
  //The clause GROUP BY is used here only as a precaution against duplicated requests
  $sql = "
    SELECT
      device
    FROM
      {device_support_request}
    WHERE
      NOT EXISTS (
        SELECT
          1
        FROM
          {device_support_slot} s
        WHERE
          s.device = device_support_request.device
      )
    GROUP BY
      device
    ORDER BY
      requested";

  $result = db_query($sql);

  $bindings = array();
  foreach ($result as $device) {

    //Find an available port
    $sql = "SELECT host, tunnel_port, username FROM {device_support_slot} WHERE device IS NULL";
    $slots = db_query_range($sql, 0, 1);

    //Only 1
    foreach ($slots as $slot) {

      db_update('device_support_slot')
        ->fields(array('device' => $device->device ))
        ->condition('host', $slot->host)
        ->condition('tunnel_port', $slot->tunnel_port)
        ->execute();

      $bindings[$slot->host] = $slot->username;

      logger_create_support_key($slot->host, $device->device);
    }
  }
}

/**
 * Builds the device support requests page.
 *
 * @return the device support requests page.
 */
function logger_support_requests_page() {

  $sql = "
    SELECT
      d.device,
      u.name AS requester,
      d.serial,
      s.host,
      s.tunnel_port,
      FROM_UNIXTIME(r.requested + u.timezone, :time_format) AS requested
    FROM
      {users} u,
      {device_support_slot} s,
      {device_support_request} r,
      {logger_devices} d
    WHERE
      d.uid = u.uid AND
      s.device = d.device AND
      d.device = r.device AND
      r.requested > 0";

  $result = db_query($sql, array(':time_format' => LOGGER_TIMESTAMP_FORMAT_SQL));

  $header = array(
    array(
      'data' => t('Requested'),
      'field' => 'requested',
    ),
    array(
      'data' => t('Requester'),
      'field' => 'requester',
    ),
    array(
      'data' => t('Serial'),
      'field' => 'serial',
    ),
    array(
      'data' => t('Host'),
      'field' => 'host',
    ),
    array(
      'data' => t('Command'),
      'field' => 'command',
    ),
    array(
      'data' => t('Operations'),
      'field' => 'operations',
    ),
  );

  $rows = array();
  foreach ($result as $req) {

    $operations =
      l(t('Remove'), "device/support/remove/$req->device") . '<br>' .
      l(t('Postpone'), "device/support/postpone/$req->device");

    $command = "ssh root@localhost -p $req->tunnel_port -i $req->device" . "_tech_id";

    $rows[] = array(
      'requested' => $req->requested,
      'requester' => $req->requester,
      'serial' => $req->serial,
      'host' => $req->host,
      'command' => "<input type='text' value='$command' style='width: 130px;'>",
      'operations' => $operations,
    );
  }
  return theme_table(array('header' => $header, 'rows' => $rows, 'caption' => '', 'empty' => '', 'sticky' => FALSE,
    'attributes' => array(), 'colgroups' => array()));
}

/**
 * Builds the device support request confirmation page.
 *
 * @param $device     The device id.
 * @param $serial     The device serial number.
 * @return the device support requests page.
 */
function logger_support_confirmation_page($device, $serial) {

  return t('You are about to request remote support for your Flukso device (Serial Number %serial). ' .
      'If so, the device will open a reverse SSH connection with our ' .
      'server that enables our technicians to log into it ' .
      'in order to check and possibly fix configuration issues.', array('%serial' => $serial)) . '<br><br>' .

    t('This authorization lasts until either you suspend it on the ' .
      'previous page or the period of 2 days is elapsed.') . '<br><br>' .

    t('Do you allow our technicians to log into your Flukso device?') . '<br><br>' .

    l(t('Yes'), "device/support/request/$device/$serial") . ' ' .
    l(t('No'), "device/mylist");
}

/**
 * Creates a device support request.
 * Any existing request of the same device is previously removed.
 *
 * @param $device The device id.
 * @param $serial The device serial number. 
 */
function logger_request_support($device, $serial) {

  db_update('device_support_slot')
    ->fields(array(
      'device' =>  NULL,
    ))
    ->condition('device', $device)
    ->execute();

  db_delete('device_support_request')
    ->condition('device', $device)
    ->execute();

  db_insert('device_support_request')
    ->fields(array(
      'device' => $device,
      'requested' => REQUEST_TIME 
    ))
    ->execute();

  logger_send_remote_support_email($device, $serial);

  return t('Thank you! Your support request has been registered.' .
      'Our technicians are going to contact you as soon as possible via email.') . '<br><br>' .

      l(t('Return to the devices page.'), "device/mylist");
}

/**
 * Removes the a device support request and its port association, and returns
 * to the user devices page.
 *
 * @param $device The device id.
 */
function logger_suspend_support($device) {

  db_update('device_support_slot')
    ->fields(array(
      'device' =>  NULL,
    ))
    ->condition('device', $device)
    ->execute();

  db_delete('device_support_request')
    ->condition('device', $device)
    ->execute();

  logger_remove_support_key($device);

  drupal_goto("device/mylist");
}

/**
 * Removes the port association of a device support request and returns
 * to the support requests page.
 *
 * @param $device The device id.
 */
function logger_postpone_support($device) {

  db_update('device_support_slot')
    ->fields(array(
      'device' =>  NULL,
    ))
    ->condition('device', $device)
    ->execute();

  logger_remove_support_key($device);

  drupal_goto('device/support/requests');
}

/**
 * Removes the a device support request and its port association, and returns
 * to the support requests page.
 *
 * @param $device The device id.
 */
function logger_remove_support($device) {

  db_update('device_support_slot')
    ->fields(array(
      'device' =>  NULL,
    ))
    ->condition('device', $device)
    ->execute();

  db_delete('device_support_request')
    ->condition('device', $device)
    ->execute();

  logger_remove_support_key($device);

  drupal_goto('device/support/requests');
}

/**
 * Send an email to the mySmartGrid ticket system.
 *
 * @param $device The device id.
 * @param $serial The device serial number.
 */
function logger_send_remote_support_email($device, $serial) {

  global $user;
  global $base_url;

  $variables = array(
    "!device" => $device,
    "%serial" => $serial,
    "%username" => $user->name,
    "!base_url" => $base_url
  );

  $subject = t('Remote Support') . ' - ' . t('Device') . ": $serial";
  $body = t(
    'Dear technician,' . '<br><br>' .
    'The user %username has requested remote support for the device %serial.' . '<br>' .
    "Click <a href='!base_url/deployment/checkup/device/!device '>here</a> to see the device status page." . '<br><br>' .
    'Best regards' . '<br>' .
    'mySmartGrid System',
    $variables
  );

  jobqueue_send_email('msg-support@itwm.fhg.de', $subject, $body);
}

/**
 * Generates a private DSS key to be used by a device to open reverse
 * SSL connections that enable remote support.
 *
 * @param $host   The host to be connected by the device.
 * @param $device The device id.
 */
function logger_create_support_key($host, $device) {
  system(LOGGER_DEVICE_CERT_PATH . "/gen-keys.sh $host $device");
}

/**
 * Removes a private DSS key used by a device to open reverse SSL connections
 * that enable remote support.
 *
 * @param $device The device id.
 */
function logger_remove_support_key($device) {
  rmfiles(LOGGER_DEVICE_CERT_PATH . "/*/$device*");
}

/**
 * Creates the file authorized_keys that contains a list of device DSS keys
 * authorized to open reverse SSL connections for remote support.
 */
function logger_update_support_authorized_keys() {

  $query = db_select('device_support_slot', 's')
    ->fields('s', array('host', 'port'));
  $query->groupBy('host');
  $query->groupBy('port');
  $accounts = $query->execute();

  foreach ($accounts as $account) {
    system(LOGGER_DEVICE_CERT_PATH . "/gen-authorized-keys.sh $account->host $account->port");
  }
}

/**
 * Updates PVCast plants with sensor measurements.
 */
function logger_update_pvcast_models() {

  module_load_include('inc', 'logger', 'logger.rrd');

  $last = variable_get('logger_last_pvcast_model_update', 0);
  $now = time();

  if ($now - $last >= DAY) {
    $sensors = logger_get_sensors(array(PRODUCTION_SENSOR_TYPE), NULL, FALSE, TRUE);
    $period = logger_get_period('day', HOUR, $now - 4 * WEEK, $now);

    foreach ($sensors as $sensor) {
      $measurements = logger_rrd_query_sensor('day', $sensor, 'watt', $period, HOUR);
      if (!empty($measurements)) {
        pvcast_update_model($sensor->meter, $measurements);
      }
    }
    variable_set('logger_last_pvcast_model_update', $now);
  }
}

function logger_xmlrpc() {
  return array(
    array(
      'logger.auth', // External method name.
      'logger_auth', // Drupal callback function to run + api version 1
      array('string', 'array'), // Return value's type, then any parameter types (accept, auth)
      'Authenticate a device'   , // Description.
    ),
    array(
      'logger.heartbeat',
      'logger_heartbeat',
      array('array', 'array', 'array'),
      'Send a heartbeat to the logger.',
    ),
    array(
      'logger.measurementAdd',
      'logger_measurement_add',
      array('string', 'array', 'array'),
      'Submit measurements to the logger.',
    ),
    array(
      'logger.brownout',
      'logger_brownout',
      array('string', 'array', 'array'),
      'Send a brownout message to the logger.',
    ),
  );
}

/**
 * Authenticates a device version 1.
 * 
 * @return the authentication response.
 */
function logger_auth($auth) {

  return logger_authenticate_hmac_sha1($auth) ? 'authenticated!' :

    xmlrpc_error(-31000, t('Authentication failed.'));
}

/**
 * Forwards device heartbeat message to the RESTful API.
 *
 * @param $auth    The authentication data.
 * @param $monitor The device properties.
 * @return the heartbeat response.
 */
function logger_heartbeat($auth, $monitor) {

  return logger_forward_api_request($auth, 'device', $auth['device'], $monitor);
}

/**
 * Forwards device measurement messages to the RESTful API.
 * 
 * @param $auth  The authentication data.
 * @param $logs  The measurements array.
 * @return the measurement response.
 */
function logger_measurement_add($auth, $logs) {

  $keys = array_keys($logs);
  $meter = $keys[0];

  $values = array();
  foreach ($logs[$meter] as $timestamp => $value) {
    $values[] = array($timestamp, $value);
  }

  return logger_forward_api_request($auth, 'sensor', $meter, array('measurements' => $values), $logs);
}

/**
 * Forwards brownout event messages to the RESTful API.
 *
 * @param $auth     The authentication data.
 * @param $message  The event message.
 * @return the event response.
 */
function logger_brownout($auth, $message) {

  return logger_forward_api_request($auth, 'event', BROWNOUT_EVENT_ID, $message);
}

/**
 * Forwards XMLRPC API requests to the RESTful API.
 *
 * @param $auth         The authentication data.
 * @param $object       The entity being affected by the invocation.
 * @param $id           The object id.
 * @param $body         The request body, as a PHP object.
 * @param $signed_body  The body of the XMLRPC request that has been signed (for authentication).
 * @return the server response.
 */
function logger_forward_api_request($auth, $object, $id, $body, $signed_body = NULL) {

  $signed_body = isset($signed_body) ? $signed_body : $body;

  if (logger_authenticate_hmac_sha1(&$auth, $signed_body)) {

    $url = variable_get('logger_msg_service_url') . "/$object/$id";
    $body = json_encode($body);

    $response = drupal_http_request($url, array(
      'method' => 'POST',
      'data' => $body,
      'headers' => array(
        'X-Version' => '1.0',
        'X-Digest' => hash_hmac('sha1', $body, $auth['key'])
      )));

    return json_decode($response->data);
  }
  else {
    return xmlrpc_error(-31000, t('Authentication failed.'));
  }
}

/**
 * Authenticates a device version 1.
 *
 * @param $auth     The authentication data.
 * @param $message  The message string.
 * @return TRUE if the authentication succeeds, FALSE otherwise.
 */
function logger_authenticate_hmac_sha1($auth, $message) {

  //Check API version
  if ($_REQUEST['version'] != 1) {
    xmlrpc_error(-32601, t('Server error. Requested method version (@version) not specified.', array("@version" => $_REQUEST['version'])));
    return FALSE;
  }    

  $auth['key'] = db_select('logger_devices', 'd')
    ->fields('d', array('sha'))
    ->condition('device', $auth['device'])
    ->execute()
    ->fetchField();

  $hash = hash_hmac('sha1', $auth['timestamp'] . ':' . logger_serialise($message) . ':' . $auth['key'], $auth['key']);

  if ($auth['signature'] == $hash && $auth['timestamp'] > REQUEST_TIME - 300) {
    return TRUE;
  }
  else {
    watchdog('logger.auth', 'HMAC-SHA1 authentication failed for device: %device', array('%device' => $auth['device']), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Converts an array into a string.
 * 
 * @param data The data to be serialized.
 * @return the resulting string.
 */
function logger_serialise($data) {

  if (is_array($data)) {

    $sequence = '';
    foreach ($data as $key => $value) {
      $sequence .= (string) $key . logger_serialise($value);
    }
    return $sequence;
  }
  else {
    return (string) $data;
  }
}
