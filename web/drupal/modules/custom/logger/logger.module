<?php

/**
 * @file
 * Support module for charting flukso measurements.
 *
 * Copyright (c) 2008-2009 jokamajo.org
 *               2010 flukso.net
 *               2010 Fraunhofer Institut ITWM (www.itwm.fraunhofer.de)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

//DEBUG
#error_reporting(E_ALL);
#ini_set('display_errors', TRUE);
#ini_set('display_startup_errors', TRUE);

define('CONSUMPTION_SENSOR_TYPE', 1);
define('PRODUCTION_SENSOR_TYPE',  2);

define('SUN_WEATHER_ID',  1);
define('RAIN_WEATHER_ID', 2);
define('MOON_WEATHER_ID', 3);

define('FRIDGE_APPLIANCE_ID',      1);
define('SHOWER_APPLIANCE_ID',      2);
define('DISH_WASHER_APPLIANCE_ID', 3);
define('KETTLE_APPLIANCE_ID',      4);

define('LOGGER_REL_PATH', drupal_get_path('module', 'logger'));
define('LOGGER_PATH', DRUPAL_ROOT . '/' . LOGGER_REL_PATH);
define('LOGGER_DEFAULT_LATITUDE', 49.444710);
define('LOGGER_DEFAULT_LONGITUDE', 7.769031);

define('LOGGER_TABLE_ID', 'logger-table');
define('LOGGER_TIMESTAMP_FORMAT_SQL', '%d-%m-%Y %H:%i:%s');
define('LOGGER_DEVICE_CERT_PATH', LOGGER_PATH . '/keys');

define('LIBKLIO_DEVICE_TYPE_ID', 4);


function logger_init() {

  check_browser_support();

  drupal_add_js(LOGGER_REL_PATH . '/js/logger-min.js', array('type' => 'file', 'scope' => 'header', 'group' => JS_LIBRARY, 'weight' => 100, 'defer' => TRUE));
}

function logger_permission() {

  return array(
    'view logger charts' => array(
      'title' => t('view logger charts'),
      'description' => t('View logger charts.'),
    ),
    'view forecast charts' => array(
      'title' => t('view forecast charts'),
      'description' => t('View forecast charts.'),
    ),
    'detect anomalies' => array(
      'title' => t('detect anomalies'),
      'description' => t('Detect anomalous measurements'),
    ),
    'set user preferences' => array(
      'title' => t('set user preferences'),
      'description' => t('Set user preferences.'),
    ),
    'list devices' => array(
      'title' => t('list devices'),
      'description' => t('Access the list of user devices.'),
    ),
    'activate devices' => array(
      'title' => t('activate devices'),
      'description' => t('Activate a device.'),
    ),
    'deactivate devices' => array(
      'title' => t('deactivate devices'),
      'description' => t('Deactivate a device.'),
    ),
    'remove devices' => array(
      'title' => t('remove devices'),
      'description' => t('Remove a device and all related data.'),
    ),
    'edit devices' => array(
      'title' => t('edit devices'),
      'description' => t('Edit device properties.'),
    ),
    'clone devices' => array(
      'title' => t('clone devices'),
      'description' => t('Clone a device and all its sensors.'),
    ),
    'list sensors' => array(
      'title' => t('list sensors'),
      'description' => t('Access the list of user device sensors.'),
    ),
    'manage sensors' => array(
      'title' => t('manage sensors'),
      'description' => t('Edit sensor properties.'),
    ),
    'request device remote support' => array(
      'title' => t('request device remote support'),
      'description' => t('Request device remote support.'),
    ),
    'attend device remote support requests' => array(
      'title' => t('attend device remote support requests'),
      'description' => t('Attend remote support requests.'),
    ),
  );
}

function logger_menu() {

  // Main operations

  $items['logger'] = array(
    'description' => 'Show the home page',
    'page callback' => 'logger_home_page',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['overview'] = array(
    'title' => 'Overview',
    'description' => 'Show the project overview',
    'page callback' => 'logger_overview_page',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['energy'] = array(
    'title' => 'Your energy consumption and production',
    'description' => 'Show the energy consumption page',
    'page callback' => 'logger_energy_page',
    'page arguments' => array(1),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['energy/relative'] = array(
    'title' => 'Your relative energy consumption',
    'description' => 'Show the relative energy consumption page',
    'page callback' => 'logger_relative_energy_consumption_page',
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['power'] = array(
    'title' => 'Your power consumption and production',
    'description' => 'Show the power consumption page',
    'page callback' => 'logger_power_page',
    'page arguments' => array(1),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['power/user'] = array(
    'title' => 'Power consumption and production',
    'description' => 'Show the power consumption and production of a single user',
    'page callback' => 'logger_user_power_page',
    'page arguments' => array(2),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['balance'] = array(
    'title' => 'Your power balance',
    'description' => 'Show the power balance page',
    'page callback' => 'logger_balance_page',
    'page arguments' => array(1),
    'access callback' => 'logger_producer_access',
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['onsite'] = array(
    'title' => 'Your on-site energy consumption',
    'description' => 'Show the on-site energy consumption page',
    'page callback' => 'logger_onsite_page',
    'page arguments' => array(1),
    'access callback' => 'logger_producer_access',
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['logger/setvariable'] = array(
    'title' => 'Sets a logger variable',
    'page callback' => 'logger_set_variable',
    'page arguments' => array(2, 3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['logger/remove/sensor'] = array(
    'title' => 'Removes a chart series',
    'page callback' => 'logger_remove_sensor_series',
    'page arguments' => array(3, 4),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['logger/hide/sensor'] = array(
    'title' => 'Hides a chart series',
    'page callback' => 'logger_hide_sensor_series',
    'page arguments' => array(3, 4),
    'access arguments' => array('view logger charts'),
    'type' => MENU_CALLBACK,
  );

  $items['logger/file'] = array(
    'title' => 'Downloads a chart file',
    'page callback' => 'logger_download_chart_data_file',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['forecast'] = array(
    'title' => 'Your power production forecast',
    'description' => 'Show the power consumption and production forecast page',
    'page callback' => 'logger_forecast_page',
    'page arguments' => array(1),
    'access callback' => 'logger_forecast_access',
    'access arguments' => array('view forecast charts'),
    'type' => MENU_CALLBACK,
  );

  $items['anomaly'] = array(
    'title' => 'Your Power Production Anomalies',
    'description' => 'Show power production anomalies page',
    'page callback' => 'logger_anomaly_page',
    'page arguments' => array(1),
    'access callback' => 'logger_producer_access',
    'access arguments' => array('detect anomalies'),
    'type' => MENU_CALLBACK,
  );

  $items['logger/getappliances'] = array(
    'title' => 'Returns list of appliances',
    'page callback' => 'logger_get_appliances',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );


  //Device operations

  $device_title = 'Devices';
  $items['device/mylist'] = array(
    'title' => $device_title,
    'page callback' => 'logger_userdevices_page',
    'access callback' => 'logger_account_access',
    'access arguments' => array('list devices'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'logger.admin.inc'
  );

  $items['device/activate'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_activate',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('activate devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['device/deactivate'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_deactivate',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('deactivate devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['device/edit'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_edition_page',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('edit devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['device/remove'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_remove',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('remove devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc',
  );

  $items['device/clone'] = array(
    'title' => $device_title,
    'page callback' => 'logger_device_clone',
    'page arguments' => array(2),
    'access callback' => 'logger_device_access',
    'access arguments' => array('clone devices', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc',
  );

  $support_title = 'Support Request';

  $items['device/support/confirm'] = array(
    'title' => $support_title,
    'description' => 'Show the device support request confirmation page',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('logger_supportrequest_form', 3, 4),
    'access callback' => 'logger_device_access',
    'access arguments' => array('request device remote support', 3),
    'type' => MENU_CALLBACK,
  );

  $items['device/support/requested'] = array(
    'title' => $support_title,
    'page callback' => 'logger_support_requested_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['device/support/suspend'] = array(
    'title' => $device_title,
    'page callback' => 'logger_suspend_support',
    'page arguments' => array(3),
    'access callback' => 'logger_device_access',
    'access arguments' => array('request device remote support', 3),
    'type' => MENU_CALLBACK,
  );

  $support_title = 'Support Requests';

  $items['device/support/requests'] = array(
    'title' => $support_title,
    'description' => 'Show the device support requests page',
    'page callback' => 'logger_support_requests_page',
    'access arguments' => array('attend device remote support requests'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['device/support/postpone'] = array(
    'title' => $support_title,
    'page callback' => 'logger_postpone_support',
    'page arguments' => array(3),
    'access arguments' => array('attend device remote support requests'),
    'type' => MENU_CALLBACK,
  );

  $items['device/support/remove'] = array(
    'title' => $support_title,
    'page callback' => 'logger_remove_support',
    'page arguments' => array(3),
    'access arguments' => array('attend device remote support requests'),
    'type' => MENU_CALLBACK,
  );


  //Sensor operations

  $sensor_title = 'Sensors';
  $items['sensor/mylist'] = array(
    'title' => $sensor_title,
    'page callback' => 'logger_usersensors_page',
    'access callback' => 'logger_account_access',
    'access arguments' => array('list sensors'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'logger.admin.inc',
  );

  $items['sensor/register'] = array(
    'title' => 'New Virtual Sensor',
    'page callback' => 'logger_sensor_edition_page',
    'access callback' => 'logger_account_access',
    'access arguments' => array('manage sensors'),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $sensor_edit_title = 'Sensor Edition';
  $items['sensor/edit'] = array(
    'title' => $sensor_edit_title,
    'page callback' => 'logger_sensor_edition_page',
    'page arguments' => array(2),
    'access callback' => 'logger_sensor_access',
    'access arguments' => array('manage sensors', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['sensor/deactivate'] = array(
    'title' => $sensor_title,
    'page callback' => 'logger_sensor_deactivate',
    'page arguments' => array(2),
    'access callback' => 'logger_sensor_access',
    'access arguments' => array('manage sensors', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );

  $items['sensor/remove'] = array(
    'title' => $sensor_title,
    'page callback' => 'logger_sensor_remove',
    'page arguments' => array(2, "sensor/mylist"),
    'access callback' => 'logger_sensor_access',
    'access arguments' => array('manage sensors', 2),
    'type' => MENU_CALLBACK,
    'file' => 'logger.admin.inc'
  );


  //Other operations

  $items['admin/config/logger'] = array(
    'title' => 'Logger settings',
    'description' => 'Configure settings for logging metering values.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('logger_admin_settings'),
    'access arguments' => array('administer site configuration'),
  );

  $items['user/%user_uid_optional/privacy'] = array(
    'title' => 'Privacy',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('logger_userprivacy_form'),
    'access arguments' => array('set user preferences'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'logger.admin.inc',
    'weight' => 2,
  );
  return $items;
}

function user_menu_alter(&$items) {
  //Overrides access control to manage visitor's permissions
  $items['user/%user/edit']['access callback'] = 'logger_user_edit_access';
}

function logger_js_alter(&$scripts) {

  foreach ($scripts as $key => $value) {
    $scripts[$key]['defer'] = TRUE;
  }
}

/**
 * This function overrides user_edit_access to block user profile edition by visitors (such as the user "guest").
 * 
 * @param $account The user account.
 */
function logger_user_edit_access($account) {

  return !user_has_role('Visitor') && user_edit_access($account);
}

/**
 * Forwards request to a suitable home page.
 *
 * @param $arg  Any page argument.
 * @return the home page.
 */
function logger_home_page($arg = NULL) {

  if ($arg) {
    drupal_goto('logger', array(), 301);
  }

  if (logger_is_mobile_device()) {
    return logger_mobile_page();
  }

  if (user_access('view logger charts')) {
    return logger_energy_page('week');
  }
  else {
    return logger_overview_page('hour');
  }
}

/**
 * Builds the mobile application home page.
 * 
 * @return the mobile home page.
 */
function logger_mobile_page() {

  global $user;

  drupal_add_http_header('Vary', 'User-Agent');
  drupal_add_http_header('Cache-Control', 'private');

  if ($user->uid) {
    $forecast_access = logger_forecast_access('view forecast charts');

    $output =
      logger_create_mobile_page_icon('energy.png',      t('Energy'),            '/energy') .
      logger_create_mobile_page_icon('power.png',       t('Power'),             '/power') .
      logger_create_mobile_page_icon('comparison.png',  t('Comparison'),        '/energy/relative') .
      ($forecast_access ?
      logger_create_mobile_page_icon('forecast.png',    t('Forecast'),          '/forecast') .
      logger_create_mobile_page_icon('balance.png',     t('Balance'),           '/balance') : '') .
      logger_create_mobile_page_icon('event.png',       t('Events'),            '/notification/list') .
      logger_create_mobile_page_icon('addnode.png',     t('Add Node'),          '/node/add') .
      logger_create_mobile_page_icon('chumby.png',      t('Chumby Image'),      '/chumby1') .
      logger_create_mobile_page_icon('dump.png',        t('Dump values'),       '/dump/setup') .
      logger_create_mobile_page_icon('myaccount.png',   t('My Account'),        '/user/' . $user->uid) .
      logger_create_mobile_page_icon('device.png',      t('Devices'),           '/device/mylist') .
      logger_create_mobile_page_icon('sensor.png',      t('Sensors'),           '/sensor/mylist');
  }
  else {
    $output =
      logger_create_mobile_page_icon('join.png',        t('Join mySmartGrid'),  '/content/werden-sie-teilnehmer');
  }

  $output .=
    logger_create_mobile_page_icon('project.png',       t('The Project'),       '/content/das-projekt') .
    logger_create_mobile_page_icon('overview.png',      t('Overview'),          '/overview') .
    logger_create_mobile_page_icon('question.png',      t('FAQ'),               '/content/h%C3%A4ufige-fragen-und-antworten') .
    logger_create_mobile_page_icon('installation.png',  t('Installation'),      '/content/installationsanleitung-des-fluksos') .
    logger_create_mobile_page_icon('forum.png',         t('Forums'),            '/forum') .
    logger_create_mobile_page_icon('blog.png',          t('Blog'),              '/blog') .
    logger_create_mobile_page_icon('newsletter.png',    t('Newsletter'),        '/newsletter') .
    logger_create_mobile_page_icon('developer.png',     t('Developer'),         '/content/seiten-f%C3%BCr-entwickler') .
    logger_create_mobile_page_icon('contact.png',       t('Contact'),           '/kontakt');

  return $output;
}

/**
 * Creates a mobile page icon.
 * 
 * @param $image  The icon image file.
 * @param $label  The icon label.
 * @param $target The icon target URL.
 * @return the icon.
 */
function logger_create_mobile_page_icon($image, $label, $target) {
  return
    '<div class="menu-icon">' .
      '<a href="' . $target . '">' .
        '<img src="/sites/all/themes/msgmobile/images/icons/' . $image . '"/>' .
        '<span>' . $label . '</span>' .
      '</a>' .
    '</div>';
}

/**
 * Checks if the client is a mobile device.
 *
 * @return TRUE if it is; FALSE otherwise.
 */
function logger_is_mobile_device() {
  $check = mobile_tools_is_mobile_device();
  return $check['type'] == 'mobile';
}

/**
 * Builds the power consumption page of a single user.
 * 
 * @param $uid The user id.
 * @return the power consumption page. 
 */
function logger_user_power_page($uid) {

  logger_set_variable('power_selected_sensors', array());
  logger_add_user_series($uid, 'power');

  return logger_power_page('hour');
}

/**
 * Builds the power consumption page.
 *
 * @param $interval The time interval.
 * @return the power consumption page.
 */
function logger_power_page($interval) {

  $interval = logger_check_interval($interval, 'hour');
  $types = array(CONSUMPTION_SENSOR_TYPE, PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_subscribed_sensors($types, 'power');

  return logger_line_chart_page($interval, 'power', t('Your power consumption and production'), $sensors, $types, 'W');
}

/**
 * Builds the power production forecast page.
 *
 * @param $interval The time interval.
 * @return the power production forecast page.
 */
function logger_forecast_page($interval) {

  global $user;

  $interval = logger_check_interval($interval, 'f3days');
  $types = array(PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_subscribed_sensors($types, 'forecast');

  return logger_line_chart_page($interval, 'forecast', t('Your power production forecast'), $sensors, $types, 'W', NULL, FALSE);
}

/**
 * Builds the power production anomalies page.
 * 
 * @param $interval The time interval.
 * @return the power production anomalies page.
 */
function logger_anomaly_page($interval) {

  global $user;

  $interval = logger_check_interval($interval, 'hour');
  $types = array(PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_subscribed_sensors($types, 'anomaly');

  return logger_line_chart_page($interval, 'anomaly', t('Power production anomalies'), $sensors, $types, 'W');
}

/**
 * Builds the power balance page.
 *
 * @param $interval The time interval.
 * @return the power balance page.
 */
function logger_balance_page($interval) {

  global $user;

  $interval = logger_check_interval($interval, '3days');
  $types = array(CONSUMPTION_SENSOR_TYPE, PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_sensors($types, array($user->uid));

  return logger_line_chart_page($interval, 'balance', t('Your power balance'), $sensors, $types, 'W');
}

/**
 * Builds the overview page.
 *
 * @param $interval The time interval.
 * @return the overview page.
 */
function logger_overview_page($interval) {

  $interval = logger_check_interval($interval, 'hour');

  $introduction = '';
  $cache_id = 'logger_overview';
  $cache = cache_get($cache_id, 'cache_page');

  if (isset($cache->data)) {
    $introduction = $cache->data;
  }
  else {

    //General explanation
    $introduction = theme('logger_overview_topic', array('title' => NULL, 'body' =>
      t('<b>mySmartGrid</b> is the smart device control for your home. ' .
      'It enables you to understand your energy consumption and share your ' .
      'experiences with others.'), 'link' => 'content/das-projekt'));

    //Latest blogpost
    $sql = 'SELECT nid FROM {node} WHERE type = :type ORDER BY created DESC';
    $nid = db_query_range($sql, 0, 1, array(':type' => "blogpost"))->fetchField();

    if ($nid) {
      $blog = node_load($nid);
      $introduction .= theme('logger_overview_topic', array('title' => t('Blog:') . $blog->title,
        'body' => $blog->body['und'][0]['safe_value'], 'link' => 'blog'));
    }

    //Counters
    $sql = "SELECT COUNT(*) FROM {logger_devices} WHERE uid <> :uid";
    $devcounter = db_query($sql, array(':uid' => 0))->fetchField();

    $sql = "SELECT COUNT(*) FROM {users} u WHERE EXISTS(
      SELECT 1 FROM {logger_devices} d WHERE d.uid = u.uid)";

    $usercounter = db_query($sql)->fetchField();

    $introduction .= theme('logger_overview_topic', array('title' => t('Total Consumption of All Participants'), 'body' =>
      t('Currently, <b>@devcounter</b> Flukso devices are installed in <b>@usercounter</b> households. ' .
        'The following chart shows their aggregate electricity consumption.',
        array(
          '@devcounter' => $devcounter,
          '@usercounter' => $usercounter ))));
  
    cache_set($cache_id, $introduction, 'cache_page', REQUEST_TIME + 1 * DAY);
  }

  $types = array(CONSUMPTION_SENSOR_TYPE);
  $sensors = logger_get_sensors($types);

  return logger_line_chart_page($interval, 'overview', t('Overall View'), $sensors, $types, 'W', $introduction);
}

/**
 * Builds the relative energy consumption page.
 *
 * @return the relative energy consumption page.
 */
function logger_relative_energy_consumption_page() {

  $types = array(CONSUMPTION_SENSOR_TYPE);
  $sensors = logger_get_selected_sensors($types);

  $introduction = t('The following chart allows you to compare current and previous levels of ' .
    'energy consumption in six different time frames: hour, day, week, month, and year. ' .
    'The bars are explained in the legend bellow.');

  return logger_bar_chart_page('year', 'relative', t('Your relative energy consumption'), $sensors, $types, 'kWh', $introduction, TRUE);
}

/**
 * Builds the energy consumption page.
 *
 * @param $interval The time interval.
 * @return the energy consumption page.
 */
function logger_energy_page($interval) {

  global $user;

  $interval = logger_check_interval($interval, 'week');
  $all_types_options = logger_get_sensor_types_options($user->uid);
  $selected_types_options = logger_get_variable('selected_sensor_types', $all_types_options);

  //User can change sensor types any time
  foreach ($selected_types_options as $type => $selected) {
    if ($selected && isset($all_types_options[$type])) {
      $types[] = $type;
    }
  }
  if (empty($types)) {
    $types = array_keys($all_types_options);
    logger_set_variable('selected_sensor_types', $all_types_options);
  }

  $sensors = logger_get_sensors($types, array($user->uid));

  $introduction = t("The following chart shows your energy consumption and production !interval.", array('!interval' => t("along the $interval")));

  return logger_bar_chart_page($interval, 'energy', t('Your energy consumption and production'), $sensors, $types, 'kWh', $introduction);
}

/**
 * Builds the on-site energy consumption page.
 *
 * @param $interval The time interval.
 * @return the on-site energy consumption page.
 */
function logger_onsite_page($interval) {

  $types = array(CONSUMPTION_SENSOR_TYPE, PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_selected_sensors($types);
  $interval = logger_check_interval($interval, 'week');
  $title = t('Your on-site energy consumption');

  return strrpos($interval, 'hour') === FALSE ?
    logger_bar_chart_page($interval, 'onsite', $title, $sensors, $types, 'kWh') :
    logger_line_chart_page($interval, 'onsite', $title, $sensors, $types, 'kWh');
}

/**
 * Builds a line chart page.
 *
 * @param $interval     The time interval.
 * @param $context      The chart context.
 * @param $title        The page title.
 * @param $sensors      The sensors plotted on the chart.
 * @param $types        The types of sensors plotted on the chart.
 * @param $default_unit The default chart unit.
 * @param $introduction A paragraph that introduces the user to the page (optional).
 * @param $show_slider  Whether or not the chart has a slider (optional).
 * @return the line consumption page.
 */
function logger_line_chart_page($interval, $context, $title, $sensors, $types, $default_unit, $introduction = NULL, $show_slider = TRUE) {

  $xvalue1 = logger_get_xvalue(1);
  $xvalue2 = logger_get_xvalue(2);
  $yvalue1 = logger_get_yvalue(1);
  $yvalue2 = logger_get_yvalue(2);

  $filled = logger_get_variable('filled_graph', 1) == 1;
  $step_plot = logger_get_variable('step_plot', 0) == 1;
  $smoothing_level = logger_get_variable('smoothing_level', 1);
  $unit_type = logger_get_unit_type($default_unit);
  $unit = logger_get_variable($unit_type . "_unit", $default_unit);

  $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);
  $prices = $use_sensor_prices ? array() : array(
    CONSUMPTION_SENSOR_TYPE => logger_get_variable('price1', 0.18),
    PRODUCTION_SENSOR_TYPE => logger_get_variable('price2', 0.18));

  $chart = logger_create_chart_object($context, $types, $interval, $unit, $sensors, array($xvalue1, $xvalue2),
    array($yvalue1, $yvalue2), FALSE, $prices, $filled, $step_plot, $smoothing_level, $show_slider);

  drupal_set_title($title);

  $form = drupal_get_form('logger_linechart_form', $chart);

  return (empty($introduction) ? '' : $introduction . '<br><br>') .
  
    theme('logger_line_chart_area', array('chart' => $chart)) . drupal_render($form);
}

/**
 * Builds an bar chart page.
 *
 * @param $interval      The time interval.
 * @param $context       The chart context.
 * @param $title         The page title.
 * @param $sensors       The sensors plotted on the chart.
 * @param $types         The types of sensors plotted on the chart.
 * @param $default_unit  The default chart unit.
 * @param $introduction  A paragraph that introduces the user to the page (optional).
 * @param $percentual    Whether the chart shows percentual values.
 * @return the bar chart page.
 */
function logger_bar_chart_page($interval, $context, $title, $sensors, $types, $default_unit, $introduction = NULL, $percentual = FALSE) {

  //FIXME: refactor this
  if ($interval == 'year') {
    $start = mktime(0, 0, 0, date('n') - 11, 1);
    $end   = mktime(0, 0, 0, date('n') +  1, 1) - 1;
  }
  else {
    $sub_interval = logger_get_sub_interval($interval);
    $sub_time_window = logger_get_default_time_window($sub_interval);

    $now = REQUEST_TIME;
    $window = logger_get_default_time_window($interval);
    //The offset is subtracted here to assure the hour 00:00 on the user timezone, and not on UTC
    $start = $now - (round($window / $sub_time_window) - 1) * $sub_time_window - ($now % $sub_time_window) - get_timezone_offset();
    $start -= $interval == 'month' ? 3 * DAY : 0;
    $end = $start + round($window / $sub_time_window) * $sub_time_window;
  }

  $aggregate_sensors = logger_get_variable('aggregate_sensors', 1);
  $unit_type = logger_get_unit_type($default_unit);
  $unit = logger_get_variable($unit_type . "_unit", $default_unit);

  $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);
  $prices = $use_sensor_prices ? array() : array(
    CONSUMPTION_SENSOR_TYPE => logger_get_variable('price1', 0.18),
    PRODUCTION_SENSOR_TYPE => logger_get_variable('price2', 0.18));

  $chart = logger_create_chart_object($context, $types, $interval, $unit, $sensors, array($start, $end),
    array(0, 0), $aggregate_sensors, $prices, FALSE, 1, FALSE, FALSE, $percentual);

  drupal_set_title($title);

  $form = drupal_get_form('logger_barchart_form', $chart);

  return (empty($introduction) ? '' : $introduction . '<br><br>') .

    theme('logger_bar_chart_area', array('chart' => $chart)) . drupal_render($form);
}

/**
 * Checks whether the interval exists.
 *
 * @param $interval         The interval to be checked.
 * @param $default_interval The interval to use, if $interval is blank.
 * @return the interval, if it is valid. Otherwise, go to the default page.
 */
function logger_check_interval($interval, $default_interval) {

  $interval = $interval ? $interval : $default_interval;
  if (!logger_get_default_time_window($interval)) {
    drupal_goto('logger', array(), 301);
  }
  return $interval;
}

/**
 * Creates an object to hold chart parameters.
 *
 * @param $context            The page where the chart is going to be placed.
 * @param $types              The array of sensor types.
 * @param $interval           The time interval.
 * @param $unit               The chart unit.
 * @param $sensors            The sensors whose values are plotted on the chart.
 * @param $xaxis              An array containing the minimum and maximum timestamps of the x axis.
 * @param $yaxis              An array containing the minimum and maximum values of the y axis.
 * @param $aggregate_sensors  Whether the sensors series should be aggregated.
 * @param $prices             The prices of KWh, for each sensor type.
 * @param $filled             Whether the chart lines should be filled.
 * @param $step_plot          Whether the chart lines should be stepped.
 * @param $smoothing_level    The smoothing level of the chart lines.
 * @param $show_slider        Whether or not the chart has a slider.
 * @param $percentual         Whether the chart shows percentual values.
 * @return the chart object.
 */
function logger_create_chart_object($context, $types, $interval, $unit, $sensors, $xaxis = array(0, 0), $yaxis = array(0, 0), $aggregate_sensors = FALSE, $prices = array(), $filled = FALSE, $step_plot = FALSE, $smoothing_level = 1, $show_slider = TRUE, $percentual = FALSE) {

  $chart = new stdClass();
  $chart->context = $context;
  $chart->types = $types;
  $chart->interval = $interval;
  $chart->unit = $unit;
  $chart->resolution = logger_get_resolution($interval);
  $chart->offset = get_timezone_offset();
  $chart->colors = logger_get_series_colors($context);
  $chart->sensors = $sensors;
  $chart->aggregate_sensors = $aggregate_sensors;
  $chart->filled = $filled;
  $chart->step_plot = $step_plot;
  $chart->smoothing_level = $smoothing_level;
  $chart->show_slider = $show_slider;
  $chart->percentual = $percentual;
  $chart->prices = array(
    CONSUMPTION_SENSOR_TYPE => isset($prices[CONSUMPTION_SENSOR_TYPE]) ? $prices[CONSUMPTION_SENSOR_TYPE] : NULL,
    PRODUCTION_SENSOR_TYPE => isset($prices[PRODUCTION_SENSOR_TYPE]) ? $prices[PRODUCTION_SENSOR_TYPE] : NULL);

  if (!($xaxis[0] > 0 && $xaxis[1] > 0)) {

    $window = logger_get_default_time_window($interval, FALSE);

    if ($window > 0) {//future
      $xaxis[0] = REQUEST_TIME - (REQUEST_TIME % DAY) - $chart->offset;
      $xaxis[1] = $xaxis[0] + $window;
    }
    else {//past
      $xaxis[1] = REQUEST_TIME;
      $xaxis[0] = $xaxis[1] + $window;
    }
  }
  $chart->yaxis = $yaxis;
  $chart->xaxis = $xaxis;
  $chart->period = logger_get_period($interval, $xaxis[0], $xaxis[1], $show_slider);

  $lifetime = MINUTE;
  $t1 = $chart->period['start'] - ($chart->period['start'] % $lifetime);
  $t2 = $chart->period['end']   - ($chart->period['end']   % $lifetime);
  $unique_id = "$context $interval" . implode(',', $types) . " $unit " . implode(',', $prices) . " $chart->resolution $t1 $t2 $aggregate_sensors";
  foreach ($chart->sensors as $sensor) {
    $unique_id .= " $sensor->meter $sensor->function $sensor->type $sensor->forecast $sensor->price $sensor->visible";
  }

  $i = strpos($context, '_');
  $module = $i == FALSE ? 'logger' : substr($context, 0, $i);

  $chart->id = $module . '_chart_data_' . md5($unique_id);
  $cache = safe_cache_get($chart->id);
  $chart->data = $cache ? $cache->data : FALSE;
  $chart->file_url = "$module/file/" . $chart->id;

  if (!$chart->data && !empty($types)) {

    $get_data = 'logger_get_' . $chart->context . '_chart_data';
    $chart->data = $get_data($chart);

    safe_cache_set($chart->id, $chart->data, $lifetime);
  }
  return $chart;
}

/**
 * Downloads a chart data file.
 *
 * @param $cache_id  The chart cache id.
 */
function logger_download_chart_data_file($cache_id) {

  //TODO: simplify this function

  $header = t('Serie');
  $lines = '';
  $cache = safe_cache_get($cache_id);

  if (isset($cache->data) && isset($cache->data['series'])) {

    $series = array();
    $values = array();
    $s = 1;

    foreach ($cache->data['series'] as $uid => $userdata) {
      foreach ($userdata as $username => $sensors) {
        foreach ($sensors as $sensor => $typedata) {
          foreach ($typedata as $type => $measurements) {
            foreach ($measurements as $timestamp => $value) {
              $values[$timestamp] = '';
            }
            $series[] = $measurements;
          }
        }
      }
    }
    ksort($values);//Sorted CSV increases the performance of JS libraries and avoid warnings

    foreach ($series as $measurements) {
      $header .= ',S' . $s++;

      foreach ($values as $timestamp => &$list) {
        $list .= ',';
        if (isset($measurements[$timestamp])) {
          $list .= $measurements[$timestamp];
        }
      }
    }

    foreach ($values as $timestamp => $values_list) {
      $lines .= $timestamp . $values_list . "\r\n"; //These characters work both in Linux and Windows
    }
    $lines = str_replace(array('&nbsp;', '<br>', '<nobr>', '</nobr>'), ' ', $lines); //Removes HTML tags
  }
  download_chart_data_file('chart-data-file.csv', $header, $lines);
}

/**
 * Returns an array containing all relative energy consumption chart data.
 *
 * @return the chart data.
 */
function logger_get_relative_chart_data($chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.rrd');

  $now = getdate();
  $extra_days['month'] = $now['mday'] - 1; //Days since 1st day of the month
  $extra_days['year'] = $now['yday']; //Days since 1st day of the year
  $extra_days['week'] = $now['wday'] > 0 ? $now['wday'] - 1 : 6; //Days since last Monday

  $intervals = array(
    'hour' => t('Hour'),
    'day' => t('Day'),
    'week' => t('Week'),
    'month' => t('Month'),
    'year' => t('Year'),
  );

  $legend = array(
    array('Serie' => '<b>' . t('Current') . '</b>' . ' - ' . t('How much has been consumed so far in the current time frame.')),
    array('Serie' => '<b>' . t('Previous') . '</b>' . ' - ' . t('How much was consumed in the previous time frame.')),
    array('Serie' => '<b>' . t('Excess') . '</b>' . ' - ' . t('How much the current consumption has exceeded the previous one.')),
  );

  foreach ($intervals as $interval => $label) {

    $resolution = logger_get_resolution($interval);
    $adjustment = isset($extra_days[$interval]) ? $extra_days[$interval] * DAY : 0;
    //offset is used here to assure hour 00:00 on the user timezone and not on UTC.
    $adjustment += (($now[0] + $chart->offset) % ($interval == 'hour' ? HOUR : DAY));

    if ($interval == 'month') {
      $last_day = getdate($now[0] - $adjustment - 12 * HOUR);
      $window = $last_day['mday'] * DAY; //Consider exactly 1 month, and not simply 30 days
    }
    else {
      $window = logger_get_default_time_window($interval);
    }

    $time1 = $now[0] - $adjustment - $window;
    $time2 = $time1 + $window;
    $time3 = $time2 + $window;

    $period1 = array('start' => $time1, 'end' => $time2);
    $period2 = array('start' => $time2, 'end' => $time3);

    $current  = logger_rrd_query_total_energy($chart->sensors, $chart->unit, $period2, $resolution, $chart->prices);
    $previous = logger_rrd_query_total_energy($chart->sensors, $chart->unit, $period1, $resolution, $chart->prices);

    $so_far    = min($previous, $current);
    $remaining = max($previous - $current, 0);
    $excess    = max($current - $previous, 0);

    //Percentages
    $series['current'][$label]  = @($so_far / $previous) * 100;
    $series['previous'][$label] = @($remaining / $previous) * 100;
    $series['excess'][$label]   = @($excess / ($previous ? $previous : $excess)) * 100;

    //Actual values
    $data_labels['current'][0][$label]  = $so_far;
    $data_labels['previous'][0][$label] = $previous;
    $data_labels['excess'][0][$label]   = $excess ? $previous + $excess : 0;

    //Until the last second
    $period1['end'] -= 1;
    $period2['end'] -= 1;

    $legend[0][$label] = logger_format_period($interval, $period2);
    $legend[1][$label] = logger_format_period($interval, $period1);
    $legend[2][$label] = logger_format_period($interval, $period2);
  }
  $data['series'][$user->uid][$user->name][] = $series;
  $data['labels'] = $data_labels;
  $data['legend'] = $legend;
  $data['stacks'] = array(0, 0, 0);

  return $data;
}

/**
 * Formats a chart series period, to be shown as a series title.
 * 
 * @param $interval The chart time interval. 
 * @param $period   The series period of time.
 * @param $offset   The timezone offset.
 * @return the series title.
 */
function logger_format_series_period($interval, $period, $offset = 0) {

  $start = $period['start'];
  $end = $period['end'] - 1; //from 00:00:00 until 23:59:59 on user timezone

  //daylight savings
  $start += date('I', $start) == "0" ? HOUR : 0;
  $end += date('I', $end) == "0" ? HOUR : 0;

  $period['start'] = $start;
  $period['end'] = $end;

  switch ($interval) {
    case 'day':
      $formatted_time = t(date('l', $start)) . ' ' . t('day quarter ' . (ceil(date("H", $end) / 6)));
      $complement = logger_format_period('dayquarter', $period, TRUE);
      break;
    case 'week':
      $formatted_time = t(date("l", $start));
      $complement = date("d", $start) . '-' . t(date("M", $start));
      break;
    case 'month':
      $formatted_time = t('Week') . ' ' . date("W", $start);
      $complement = logger_format_period('week', $period, TRUE);
      break;
    case 'year':
      $formatted_time = t(date("M", $start));
      $complement = date("Y", $start);
      break;
    default :
      return $end + 1;
  }
  return $formatted_time . (empty($complement) ? '' : "<br>$complement");
}

/**
 * Formats a period of time array for exhibition.
 * 
 * @param $interval      The time interval name.
 * @param $period        The pair of timestamps (start, end) that define the period.
 * @param $dst_adjusted  Whether daylight saving offset has been removed from dates.
 * @return the period of time as a string.
 */
function logger_format_period($interval, $period, $dst_adjusted = FALSE) {

  $start = $period['start'];
  $end   = $period['end'];

  if (!$dst_adjusted) {
    //daylight savings
    $start += date('I', $start) == "0" ? HOUR : 0;
    $end += date('I', $end) == "0" ? HOUR : 0;
  }

  switch ($interval) {
    case 'hour':
      return date('H:i', $start);

    case 'dayquarter':
      return logger_format_long_period($start, $end, 'H:i');

    case 'day':
      return '<nobr>' . date('d-m', $start) . '</nobr>';

    case 'week':
      return logger_format_long_period($start, $end, 'd-m');

    case 'month':
      return t(date('F', $start));

    case 'year':
      return t(date('Y', $end)) . '<br>';
  }
}

/**
 * Formats a long period of time for exhibition.
 * 
 * @param $start   The timestamp when the period begins.
 * @param $end     The timestamp when the period ends.
 * @param $format  The timestamp format to be used.
 * @return the long period of time as a string.
 */
function logger_format_long_period($start, $end, $format) {

  return t('from:') . '&nbsp;&nbsp;<nobr>' . date($format, $start) . '</nobr><br>' .
         t('to:') . '&nbsp;&nbsp;<nobr>' . date($format, $end) . '</nobr>';
}

/**
 * Returns an array containing all energy consumption chart data.
 * 
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_energy_chart_data(&$chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.rrd');

  $groups = array();
  foreach ($chart->sensors as &$sensor) {
    $key = $chart->aggregate_sensors ? $sensor->type : $sensor->meter;
    $groups[$key][] = $sensor;
  }

  $sub_interval = logger_get_sub_interval($chart->interval);
  $sub_time_window = logger_get_default_time_window($sub_interval);
  $line_id = 0;

  foreach ($groups as $key => &$series_sensors) {

    $min_time = 0;
    $max_time = 0;
    $min = NULL;
    $max = NULL;
    $sum = 0;
    $total = 0;
    $series = array();
    $data_labels = array();

    $from = $chart->xaxis[0];
    $to = $chart->xaxis[1] - $sub_time_window;
    for ($time = $from; $time <= $to; $time += $sub_time_window) {

      if ($chart->interval == 'year') {
        $day = $time + WEEK; //A day surelly in the current month
        $start = mktime(0, 0, 0, date('n', $day),     1, date('Y', $day));
        $end   = mktime(0, 0, 0, date('n', $day) + 1, 1, date('Y', $day));
      }
      else {
        $start = $time;
        $end = $time + $sub_time_window;
      }

      $period = array('start' => $start, 'end' => $end);
      $value = logger_rrd_query_total_energy($series_sensors, $chart->unit, $period, $chart->resolution, $chart->prices);

      $title = logger_format_series_period($chart->interval, $period);

      if (!$min || ($value < $min && $time < $to)) {
        $min = $value;
        $min_time = $title;
      }

      if (!$max || $value > $max) {
        $max = $value;
        $max_time = $title;
      }

      $sum += $value;
      $total++;

      $series[$title] = $value;
      $data_labels[$title] = $value;
    }
    $avg = $total > 0 ? $sum / $total : '';

    $sensor = $series_sensors[0];
    $type_id = $sensor->type_id;

    if ($chart->aggregate_sensors) {
      $sensor = new stdClass();
      $sensor->uid = $user->uid;
      $sensor->username = $user->name;
      $sensor->function = t('All');
      $sensor->meter = 'All';
      $sensor->type = t($key);
    }

    $data['series'][$sensor->uid][$sensor->username][$sensor->meter][t($sensor->type)] = $series;
    $data['labels'][$sensor->meter][t($sensor->type)] = $data_labels;

    $data['legend'][$line_id] = logger_create_legend_line($sensor->username, $sensor->function, t($sensor->type), $line_id, array(
      'Min' => logger_format_legend_record($min, $min_time, $chart->interval),
      'Max' => logger_format_legend_record($max, $max_time, $chart->interval),
      'Avg' => $avg, 'Sum' => $sum
    ));
    $line_id++;
  }
  return $data;
}

/**
 * Returns an array containing all on-site consumption chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_onsite_chart_data($chart) {

  global $user;

  $hour_interval = !(strrpos($chart->interval, 'hour') === FALSE);
  $all_series = logger_get_onsite_chart_series($chart);
  $data = array('stacks' => array(0, 1, 0, 1));

  foreach ($all_series as $line_id => $series) {

    $name = $series['name'];

    if (!empty($name)) {
      $cells = array('Min' => 0, 'Max' => 0, 'Avg' => 0);

      if (!$hour_interval) {
        $values = empty($series['values']) ? array(0) : $series['values'];
        $min = min($values);
        $max = max($values);
        $min_time = array_search($min, $values);
        $max_time = array_search($max, $values);
        $min_complement = $line_id == 0 ? $series['labels2'][$min_time] . '%' : '';
        $max_complement = $line_id == 0 ? $series['labels2'][$max_time] . '%' : '';

        $cells['Min'] = logger_format_legend_record($min, $min_time, $chart->interval, $min_complement);
        $cells['Max'] = logger_format_legend_record($max, $max_time, $chart->interval, $max_complement);
        $cells['Sum'] = array_sum($values);
        $cells['Avg'] = $cells['Sum'] / count($values);
      }
      $data['legend'][$line_id] = logger_create_legend_line($user->name, NULL, $name, $line_id, $cells, $series['chartSeriesIds'], $series['colorIds']);
    }
    $data['series'][$user->uid][$user->name][0][$name] = $series['values'];
    $data['labels'][0][$name] = $series['labels'];
    //Format percentages
    foreach ($series['labels2'] as $time => $value) {
      $data['labels2'][0][$name][$time] = "'$value%'";
    }
  }
  return $data;
}

/**
 * Returns an array containing all on-site consumption chart series data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart series data.
 */
function logger_get_onsite_chart_series($chart) {

  module_load_include('inc', 'logger', 'logger.rrd');

  $sensors = array(CONSUMPTION_SENSOR_TYPE => array(), PRODUCTION_SENSOR_TYPE => array());
  foreach ($chart->sensors as &$sensor) {
    $type = $sensor->type_id;
    $sensors[$type][] = $sensor;
  }

  $consumed = logger_rrd_query_energy($sensors[CONSUMPTION_SENSOR_TYPE], $chart->unit, $chart->period, $chart->resolution, $chart->prices);
  $produced = logger_rrd_query_energy($sensors[PRODUCTION_SENSOR_TYPE], $chart->unit, $chart->period, $chart->resolution, $chart->prices);
  $onsite = array();
  $feedin = array();
  $supply = array();
  $agg_consumption = array();
  $agg_production = array();

  $sub_interval = logger_get_sub_interval($chart->interval);
  $sub_time_window = logger_get_default_time_window($sub_interval);
  $from = $chart->period['start'] - ($chart->period['start'] % MINUTE);

  $hour_interval = !(strrpos($chart->interval, 'hour') === FALSE);
  $last_minute = $hour_interval ? 0 : 1; //Until 23:59:59
  $extra_time = $chart->interval == 'month' ? 3 * DAY : 0; //Week starts on monday

  //For every measurement
  for ($time = $from; $time < $chart->period['end']; $time += MINUTE) {

    $start = $time + $chart->offset;
    $start -= ($start % $sub_time_window) + $chart->offset;
    $start -= $extra_time;
    $end = $start + $sub_time_window;
    $end -= $last_minute;
    $period = array('start' => $start, 'end' => $end);
    $title = logger_format_series_period($chart->interval, $period, $chart->offset);

    if (!isset($onsite[$title])) {
      $onsite[$title] = 0;
      $feedin[$title] = 0;
      $supply[$title] = 0;
      $agg_consumption[$title] = 0;
      $agg_production[$title] = 0;
    }
    if (!isset($consumed[$time])) {
      $consumed[$time] = 0;
    }
    if (!isset($produced[$time])) {
      $produced[$time] = 0;
    }

    if ($consumed[$time] < $produced[$time]) {
      $onsite[$title] += $consumed[$time];
      $feedin[$title] += $produced[$time] - $consumed[$time];
    }
    else {
      $onsite[$title] += $produced[$time];
      $supply[$title] += $consumed[$time] - $produced[$time];
    }
    $agg_consumption[$title] += $consumed[$time];
    $agg_production[$title] += $produced[$time];
  }

  $feedin_perc = array();
  $supply_perc = array();

  if ($hour_interval) {
    foreach ($onsite as $title => $value) {
      $supply[$title] += $value;
      $feedin[$title] += $value;
    }
  }
  else {
    foreach ($onsite as $time => $value) {
      $sum = $value + $feedin[$time];
      $feedin_perc[$time] = number_format($sum > 0 ? $value * 100 / $sum : 0, 0);

      $sum = $value + $supply[$time];
      $supply_perc[$time] = number_format($sum > 0 ? $value * 100 / $sum : 0, 0);
    }
  }

  return array(
    0 => array('name' => t('On-site Consumption'), 'values' => $onsite,          'labels' => $onsite, 'labels2' => $supply_perc, 'chartSeriesIds' => array(0, 1), 'colorIds' => array()),
    1 => array('name' => '',                       'values' => $onsite,          'labels' => array(), 'labels2' => $feedin_perc, 'chartSeriesIds' => array(),     'colorIds' => array()),
    2 => array('name' => t('Power Grid Supply'),   'values' => $supply,          'labels' => $supply, 'labels2' => array(),      'chartSeriesIds' => array(),     'colorIds' => array()),
    3 => array('name' => t('Power Grid Feed-in'),  'values' => $feedin,          'labels' => $feedin, 'labels2' => array(),      'chartSeriesIds' => array(),     'colorIds' => array()),
    4 => array('name' => t('Energy Consumption'),  'values' => $agg_consumption, 'labels' => array(), 'labels2' => array(),      'chartSeriesIds' => array(),     'colorIds' => array(2, 0)),
    5 => array('name' => t('Energy Production'),   'values' => $agg_production,  'labels' => array(), 'labels2' => array(),      'chartSeriesIds' => array(),     'colorIds' => array(3, 0))
  );
}

/**
 * Returns an array containing all power consumption chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_power_chart_data($chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.rrd');

  $is_visitor = user_has_role('Visitor');
  $data = array();
  $i = 0;

  foreach ($chart->sensors as &$sensor) {

    $price = $chart->prices[$sensor->type_id];
    $price = $price ? $price : $sensor->price;

    //TODO: make a single call
    if ($sensor->virtual) {
      $aggregated = logger_get_aggregated_sensors($sensor->meter);
      $measurements = logger_rrd_query_agg($aggregated, $chart->unit, $chart->period, $chart->resolution, $price);
    }
    else {
      $measurements = logger_rrd_query_sensor($sensor, $chart->unit, $chart->period, $chart->resolution, $price);
    }

    $data['series'][$sensor->uid][$sensor->username][$sensor->meter][$sensor->type] = logger_format_power_series_data($chart, $measurements);

    foreach (logger_get_appliance_ids() as $app) {
      $data['appliances'][$i][$app] = logger_rrd_query_appliance($sensor, $chart->period, $app, $chart->resolution);
    }

    //Hide usernames for Visitors
    $username = $sensor->uid != $user->uid && $is_visitor ? t('User') . ' ' . str_pad($sensor->uid, 3, '0', STR_PAD_LEFT) : $sensor->username;

    $operations = logger_create_remove_power_series_link($sensor->uid, $i, $username, $sensor->meter, $sensor->visible, $chart->context);

    $data['legend'][$i] = logger_create_legend_line($username, $sensor->function, t($sensor->type), $i,
      array('Min' => 0, 'Max' => 0, 'Avg' => 0, 'Last' => 0, 'Operations' => $operations));
    $i++;
  }
  return $data;
}

/**
 * Returns an array containing all power balance chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_balance_chart_data($chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.rrd');

  $groups = array(PRODUCTION_SENSOR_TYPE => array(), CONSUMPTION_SENSOR_TYPE => array());
  foreach ($chart->sensors as &$sensor) {
    $groups[$sensor->type_id][] = $sensor;
  }

  $type_names = array();
  $all_values = array();
  $measurements = array();
  foreach ($groups as $type_id => $sensors) {

    if (!empty($sensors)) {
      $type_names[$type_id] = $sensors[0]->type;
      $price = $chart->prices[$type_id];
      $price = $price ? $price : $sensor->price;

      $measurements[$type_id] = logger_rrd_query_agg($sensors, $chart->unit, $chart->period, $chart->resolution, $price);
    }
  }

  $measurements = logger_get_net_production_consumption($measurements, $chart->resolution);
  $type_names[PRODUCTION_SENSOR_TYPE] = 'Production Surplus';
  $type_names[CONSUMPTION_SENSOR_TYPE] = 'Production Deficit';

  $data = array();
  $i = 0;
  foreach ($measurements as $type_id => $values) {

    $type_name = t($type_names[$type_id]);
    $data['series'][$user->uid][$user->name][t('All')][$type_name] = logger_format_power_series_data($chart, $values);
    $data['legend'][$i] = logger_create_legend_line($user->name, t('All'), $type_name, $i,
      array('Min' => 0, 'Max' => 0, 'Avg' => 0, 'Last' => 0));
    $i++;
  }
  return $data;
}

function logger_get_net_production_consumption($measurements, $resolution) {

  $net_production = array();
  foreach ($measurements as $type_id => $values) {
    foreach ($values as $time => $value) {

      $net_production[$time] = isset($net_production[$time]) ? $net_production[$time] : 0;
      $net_production[$time] += $value * ($type_id == CONSUMPTION_SENSOR_TYPE ? -1 : 1);
    }
  }

  $negative = FALSE;
  $net_consumption = array();
  foreach ($net_production as $time => $value) {

    if ($value < 0 && !$negative || $value > 0 && $negative) {
      $interception_time = $time - (int) ($resolution / 2);
      $net_production[$interception_time] = 0;
      $net_consumption[$interception_time] = 0;
      $negative = !$negative;
    }

    $net_consumption[$time] = $value > 0 ? NULL : $net_production[$time];
    $net_production[$time] = $value < 0 ? NULL : $net_production[$time];
  }
  ksort($net_production);
  ksort($net_consumption);

  return array(PRODUCTION_SENSOR_TYPE => $net_production, CONSUMPTION_SENSOR_TYPE => $net_consumption);
}

/**
 * Returns an array containing all power production forecast chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_forecast_chart_data($chart) {
  
  global $user;

  $is_visitor = user_has_role('Visitor');
  $data = logger_get_power_chart_data($chart);
  $data['legend'] = array();
  $i = 0;

  foreach ($chart->sensors as &$sensor) {

    //Hide usernames for Visitors
    $username = $sensor->uid != $user->uid && $is_visitor ? t('User') . ' ' . str_pad($sensor->uid, 3, '0', STR_PAD_LEFT) : $sensor->username;

    //If this is a forecast series
    if (strpos($sensor->meter, 'Forecast') === 0) {

      $meter = substr($sensor->meter, 8);
      $forecast = pvcast_get_forecast($meter, $chart->period['start'], $chart->period['end']);

      #FIXME: move unit conversion to the pvcast module.
      $factor = 1;
      if ($chart->unit == '€/year') {
        $factor = $sensor->price * 24 * 365 / 1000;
      }
      else if ($chart->unit == 'kWh/year') {
        $factor = 24 * 365 / 1000;
      }
      foreach ($forecast['power'] as $time => $value) {
        $forecast['power'][$time] = $value * $factor;
      }

      $data['series'][$sensor->uid][$sensor->username][$sensor->meter][$sensor->type] =
        logger_format_power_series_data($chart, $forecast['power']);

      foreach ($forecast['precipitation'] as $time => $rain) {
        $sun = date_sun_info($time, $sensor->latitude, $sensor->longitude);
        $data['weather'][$i][$time] = $rain > 0 ? RAIN_WEATHER_ID : ($time > $sun['sunrise'] && $time < $sun['sunset'] ? SUN_WEATHER_ID : MOON_WEATHER_ID);
      }
      $data['temperature'][$i] = $forecast['temperature'];
    }

    $operations = logger_create_remove_power_series_link($sensor->uid, $i, $username, $sensor->meter, $sensor->visible, $chart->context);

    $data['legend'][$i] =
      logger_create_legend_line($username, $sensor->function, t($sensor->type), $i,
      array('Min' => 0, 'Max' => 0, 'Avg' => 0, 'Last' => 0, 'Operations' => $operations));

    $i++;
  }
  return $data;
}

/**
 * Returns an array containing all power production anomalies chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_anomaly_chart_data($chart) {

  global $user;

  module_load_include('inc', 'logger', 'logger.anomaly');

  $is_visitor = user_has_role('Visitor');
  $data = logger_get_power_chart_data($chart);
  $data['legend'] = array();
  $i = 0;

  foreach ($chart->sensors as &$sensor) {

    //Hide usernames for Visitors
    $username = $sensor->uid != $user->uid && $is_visitor ? t('User') . ' ' . str_pad($sensor->uid, 3, '0', STR_PAD_LEFT) : $sensor->username;

    //If this is a forecast series
    if (strpos($sensor->meter, 'Anomalies') === 0) {

      $meter = substr($sensor->meter, 9);
      $clone = clone $sensor;//FIXME: remove this line later
      $clone->meter = $meter;
      $anomalies = logger_detect_production_anomalies($clone, $chart->unit, $chart->period, $chart->resolution);

      $data['series'][$sensor->uid][$sensor->username][$sensor->meter][$sensor->type] =
        logger_format_power_series_data($chart, $anomalies);
    }

    $operations = logger_create_remove_power_series_link($sensor->uid, $i, $username, $sensor->meter, $sensor->visible, $chart->context);

    $data['legend'][$i] =
      logger_create_legend_line($username, $sensor->function, t($sensor->type), $i,
        array('Min' => 0, 'Max' => 0, 'Avg' => 0, 'Last' => 0, 'Operations' => $operations));

    $i++;
  }
  return $data;
}

/**
 * Creates a link to remove power chart series.
 *
 * @param $uid      The user id.
 * @param $username The user name.
 * @param $i        The series number.
 * @param $meter    The sensor id.
 * @param $visible  If the series is visible.
 * @param $context  The chart context.
 * @return the link code.
 */
function logger_create_remove_power_series_link($uid, $i, $username, $meter, $visible, $context) {

  global $user;

  $link = '';
  if ($uid > 0) {

    $link = '<a href="javascript: void(0)" id="hide-legend-row' . $i . '" OnClick="javascript: ';

    if ($user->uid == $uid) {
      $link .= "hideLineSeries($uid, $i, '$username', '$meter', '" . t('Hide') . "', '" . t('Show') . "', '$context');\">" .
      ($visible ? t('Hide') : t('Show'));
    }
    else {
      $link .= "removeLineSeries($uid, $i, '$username', '$meter', '" . LOGGER_TABLE_ID . "', '$context');\">" . t('Remove');
    }
    $link .= '</a>';
  }
  return $link;
}

/**
 * Returns an array containing all overview chart data.
 *
 * @param $chart  The chart object with the parameters for the data query.
 * @return the chart data.
 */
function logger_get_overview_chart_data($chart) {

  module_load_include('inc', 'logger', 'logger.rrd');

  $measurements = logger_rrd_query_agg($chart->sensors, $chart->unit, $chart->period, $chart->resolution);

  $values = logger_format_power_series_data($chart, $measurements);
  $type = $chart->sensors[0]->type; //For instance, just consumption

  $data['series'][0][t('All')][t('All')][$type] = $values;
  $data['legend'][0] = logger_create_legend_line(t('All'), t('All'), t($type), 0,
    array('Min' => 0, 'Max' => 0, 'Avg' => 0, 'Last' => 0));

  return $data;
}

/**
 * Formats power consumption chart data series.
 *
 * @param $measurements  The array of timestamp / value that form the data series.
 * @param $chart         The chart object with the format parameters.
 * @return the formatted data series.
 */
function logger_format_power_series_data($chart, $measurements) {//FIXME: rename this function

  $formatted = array($chart->period['start'] => NULL, $chart->period['end'] => NULL);
  foreach ($measurements as $timestamp => $value) {

    $decimals = (int) strstr($measurements[$timestamp], '.');
    $decimals = $decimals > 99 ? 3 : $decimals > 9 ? 2 : $decimals > 0 ? 1 : 0;
    $formatted[$timestamp] = (int) number_format($value, $decimals, '.', '');
  }
  return $formatted;
}

/**
 * Creates a line for the energy consumption chart legend.
 *
 * @param $username          The user name.
 * @param $function          The sensor function (not displayed if NULL).
 * @param $type              The sensor type.
 * @param $i                 The legend line index.
 * @param $values            The collumn values (Min, Max, Last, Avg, Sum, Operations) (optional).
 * @param $chart_series_ids  An array of chart series ids, associated with this legend line (optional).
 * @param $colorIds          An array of line colors represented by this legend line (optional).
 * @return the legend line.
 */
function logger_create_legend_line($username, $function, $type, $i, $values = array(), $chart_series_ids = array(), $colorIds = array()) {

  $line = array();
  $line['User'] = mb_wordwrap($username, 12, "<br>", TRUE);

  if ($function != NULL) {
    $line['Sensor'] = mb_wordwrap($function, 16, "<br>", TRUE);
  }

  $line['Type'] = $type;
  $line['seriesIds'] = $chart_series_ids;
  $line['colorIds'] = $colorIds;
  
  foreach ($values as $title => $value) {
    $id = strtolower("$title$i");
    $value = is_numeric($value) ? ($value == 0 ? '' : number_format($value, 2, '.', '')) : $value;
    $line[$title] = "<div id='$id'>$value</div>";
  }
  return $line;
}

/**
 * Formats a record consumption (either min or max) to be shown on a cell of
 * the chart legend.
 *
 * @param $value       The record value.
 * @param $record_time The record time.
 * @param $interval    The chart time interval name.
 * @return the formatted record.
 */
function logger_format_legend_record($value, $record_time, $interval, $complement = '') {

  $value = number_format($value, 2, '.', '') . (empty($complement) ? '' : " ($complement)");

  if ($record_time && $interval) {
    $record_time = strtok($record_time, '<');//Remove tag if it exists
    $prep = $interval == 'year' ? 'in' : 'am';
    $value = t("%value $prep %day", array('%value' => $value, '%day' => $record_time));
  }
  return $value;
}

/**
 * Returns an array containing sensors owned by the informed users.
 *
 * @param $types             The types of sensors to be returned (default: all).
 * @param $user_ids          The user ids of sensor owners (default: all).
 * @param $virtual           Whether virtual sensors can be returned (default: false).
 * @param $only_forecast     Whether only forecast sensors can be returned (default: false).
 * @param $include_visitors  Whether sensors belonging to users with role 'Visitor' can be returned (default: true).
 * @param $area              The geographical area where the sensors must be located.
 *                           (format: array('latitude' => array(min, max), 'longitude' => array(min, max))).
 * @return the array of sensors.
 */
function logger_get_sensors($types = NULL, $user_ids = NULL, $include_virtual = FALSE, $only_forecast = FALSE, $include_visitors = TRUE, $area = array()) {

  global $user;

  $query = db_select('logger_meters', 'm')
    ->fields('m', array('uid', 'meter', 'function', 'virtual', 'forecast', 'price', 'latitude', 'longitude'))
    ->isNotNull('m.function');

  $query->join('unit', 'un', 'm.unit_id = un.id');
  $query->addField('un', 'name', 'unit');

  $query->join('logger_meter_type', 't', 't.id = m.type');
  $query->addField('t', 'name', 'type');
  $query->addField('t', 'id', 'type_id');
  $query->addExpression('TRUE', 'visible');

  $query->join('logger_devices', 'd', 'd.device = m.device');
  $query->addField('d', 'type_id', 'device_type_id');

  if (user_has_role('Techniker')) {
    $query->addExpression('FALSE', 'private');
  }
  else {
    $query->join('logger_users', 'lu', 'lu.uid = m.uid');
    $query->addField('lu', 'private', 'private');
  }

  $query->join('users', 'u', 'u.uid = m.uid');
  $query->addField('u', 'name', 'username');

  if (!empty($types)) {
    $query->condition('m.type', $types, 'IN');
  }
  if (!empty($user_ids)) {
    $query->condition('u.uid', $user_ids, 'IN');
  }
  if (!$include_virtual) {
    $query->condition('m.virtual', 0);
  }
  if ($only_forecast) {
    $query->condition('m.forecast', 1);
  }
  if (!empty($area)) {
    $query
    ->condition('m.latitude', $area['latitude'], 'BETWEEN')
    ->condition('m.longitude', $area['longitude'], 'BETWEEN');
  }

  if (!$include_visitors) {

    $visitor = db_select('users_roles', 'ur')
      ->fields('ur', array('uid'))
      ->condition('ur.uid', 'm.uid');

    $visitor->join('role', 'r', 'r.rid = ur.rid');
    $visitor->condition('r.name', 'Visitor');

    $query->notExists($visitor);
  }

  $query->orderBy('u.name');
  $query->orderBy('m.function');

  $result = $query->execute();

  $sensors = array();
  foreach ($result as $sensor) {
    $sensors[] = $sensor;
  }
  return $sensors;
}

/**
 * Returns an array containing all sensors from other users, selected to be plotted on the chart.
 *
 * @param $types   The types of sensors to be returned.
 * @param $context The chart context.
 * @return the array of sensors.
 */
function logger_get_subscribed_sensors($types, $context) {

  global $user;

  $selected_sensors = logger_get_variable($context . '_selected_sensors', array());
  $uids = array($user->uid => $user->uid);
  foreach ($selected_sensors as $sensor) {
    $uids[$sensor->uid] = $sensor->uid;
  }
  $sensors = logger_get_sensors($types, $uids, TRUE);

  if ($context == 'forecast' || $context == 'anomaly') {
    foreach ($sensors as $sensor) {
      $extra = clone $sensor;
      $extra_type = $context == 'forecast' ? 'Forecast' : 'Anomalies';
      $extra->meter = $extra_type . $sensor->meter;
      $extra->function = $sensor->function . ' (' . t($extra_type) . ')';
      $sensors[] = $extra;
    }
  }

  $new_sensors = array();
  $diff = array_udiff($sensors, $selected_sensors, 'logger_compare_sensors');
  foreach ($diff as $new_sensor) {
    if ($new_sensor->uid == $user->uid) {
      $new_sensors[] = $new_sensor;
    }
  }

  $selected_sensors = array_merge($selected_sensors, $new_sensors);
  $removed_sensors = array_udiff($selected_sensors, $sensors, 'logger_compare_sensors');
  $selected_sensors = array_udiff($selected_sensors, $removed_sensors, 'logger_compare_sensors');

  if (!empty($new_sensors) || !empty($removed_sensors)) {
    logger_set_variable($context . '_selected_sensors', $selected_sensors);
  }

  return $selected_sensors;
}

function logger_compare_sensors($sensor1, $sensor2) {

  if ($sensor1->meter === $sensor2->meter) {
    if ($sensor1->function === $sensor2->function) {
      if ($sensor1->type === $sensor2->type) {
        return 0;
      }
      return ($sensor1->type > $sensor2->type) ? 1 : -1;
    }
    return ($sensor1->function > $sensor2->function) ? 1 : -1;
  }
  return ($sensor1->meter > $sensor2->meter) ? 1 : -1;
}

/**
 * Returns an array containing all sensors selected by the user to be plotted on the chart.
 *
 * @param $types   The types of sensors to be returned.
 * @return the array of sensors.
 */
function logger_get_selected_sensors($types) {

  global $user;

  $meters = logger_get_variable('selected_meters', array());
  $all_meters = array();
  $all_sensors = logger_get_sensors($types, array($user->uid));

  $sensors = array();
  foreach ($all_sensors as $sensor) {
    $all_meters[] = $sensor->meter;
    if (isset($meters[$sensor->meter]) && $meters[$sensor->meter]) {
      $sensors[] = $sensor;
    }
  }

  if (empty($sensors)) {
    $sensors = $all_sensors;
    logger_set_variable('selected_meters', $all_meters);
  }
  return $sensors;
}

/**
 * Returns an array containing the sensors aggregated by a virtual sensor.
 * 
 * @param $virtual_meter The virtual sensor id.
 * @return the array of aggregated sensors.
 */
function logger_get_aggregated_sensors($virtual_meter) {

  if ($virtual_meter) {

    $query = db_select('logger_aggregated_meters', 'a')
    ->fields('a', array('meter'))
    ->condition('a.virtual_meter', $virtual_meter, '=');

    $query->join('logger_meters', 'm', 'm.meter = a.meter');
    $query->join('logger_devices', 'd', 'd.device = m.device');
    $query->addField('d', 'type_id', 'device_type_id');

    return db_query_objects($query);
  }
  else {
    return array();
  }
}

/**
 * Returns an array of user devices' serial numbers indexed by their respective
 * hash codes.
 *
 * @return the array of devices.
 */
function logger_get_devices_options() {

  global $user;

  $devices = array();
  if ($user->uid) {

    $sql = "SELECT serial, device FROM {logger_devices} WHERE uid = :uid ORDER BY serial";
    $result = db_query($sql, array(':uid' => $user->uid));

    foreach ($result as $row) {
      $devices[$row->device] = $row->serial;
    }
  }
  return $devices;
}

function logger_theme() {

  return array(
    'logger_line_chart_area' => array(
      'variables' => array(
        'chart' => NULL,
      ),
    ),
    'logger_bar_chart_area' => array(
      'variables' => array(
        'chart' => NULL,
      ),
    ),
    'logger_overview_topic' => array(
      'variables' => array(
        'title' => NULL,
        'body' => NULL,
        'link' => NULL,
      ),
    ),
    'logger_chart_tabs' => array(
      'items' => array()
    ),
    'logger_smoothing_level' => array(
      'render element' => 'element',
    ),
    'logger_value_range' => array(
      'render element' => 'element',
    ),
    'logger_time' => array(
      'render element' => 'element',
    ),
    'logger_time_period' => array(
      'render element' => 'element',
    ),
    'logger_geo_location' => array(
      'render element' => 'element',
    ),
    'logger_color_picker' => array(
      'variables' => array(
        'chartId' => NULL,
        'indexes' => array(),
        'colors' => NULL,
        'seriesIds' => array() 
      )
    )
  );
}

/**
 * Builds a topic of the Overview page.
 *
 * @param $title  The topic title.
 * @param $body   The topic body.
 * @param $link   The topic link.
 * @return the topic.
 */
function theme_logger_overview_topic($variables) {

  $title = $variables['title'];
  $body = $variables['body'];
  $link = $variables['link'];
  $output = '';

  if ($title) {
    $output .= '<br><h3 class="node-headline">' . $title . '</h3>';
  }
  $output .= "<p> $body </p>";

  if ($link) {
    $output .= '<p>' . l(t('read more'), $link) . '</p>';
  }
  return $output;
}

/**
 * Builds the line chart area.
 *
 * @param $variables The theme variables.
 * @return the line chart area output.
 */
function theme_logger_line_chart_area($variables) {

  $chart = $variables['chart'];

  $xvalue1 = $chart->xaxis[0] * 1000;
  $xvalue2 = $chart->xaxis[1] * 1000;
  $yvalue1 = $chart->yaxis[0] + 0;
  $yvalue2 = $chart->yaxis[1] + 0;

  //In order to avoid a bug in Dygraphs
  $yvalue2 += ($yvalue2 != 0 && $yvalue2 % 10 == 0 ? 1 : 0);

  $visibility = array();
  foreach ($chart->sensors as $sensor) {
    $visibility[] .= $sensor->visible ? "true" : "false";
  }

  $chart_properties = array(
    'dateWindow' => "[$xvalue1, $xvalue2]",
    'drawCallback' => 'updateLineChartForm',
    'pointClickCallback' => 'addLineAnnotation',
    'stepPlot' => $chart->step_plot ? 'true' : 'false' ,
    'rollPeriod' => $chart->smoothing_level,
    'fillGraph' => $chart->filled ? 'true' : 'false',
    'fillAlpha' => $chart->context == 'onsite' ? 1 : 0.15, //FIXME: create a property on the chart object
    'visibility' => '[' . implode(', ', $visibility) . ']',
    'xAxisLabelFormatter' => 'Dygraph.dateAxisFormatter',
    'xValueFormatter' => 'Dygraph.dateString_',
    'xValueParser' => 'function(x) { return 1000 * parseInt(x); }',
    'xTicker' => 'Dygraph.dateTicker'
  );
  if ($chart->show_slider) {
    $chart_properties['zoomCallback'] = 'updateSliderChart';
  }

  if ($yvalue1 >= 0 && $yvalue2 > 0) {
    $chart_properties['valueRange'] = "[$yvalue1, $yvalue2]";
  }

  $options = array_merge(logger_get_power_units_options(), logger_get_energy_units_options());
  $unit = $options[$chart->unit];

  $icons = "<a href='javascript: expandLineChart();'><img src='/" . LOGGER_REL_PATH . "/img/expand.png'></a>";

  $output = logger_create_interval_menu($chart->context) .
    '<div style="float: right;">' . $icons . '</div>' .
    '<div>' . t($unit) . '</div>' .
    logger_create_dygraph($chart, TRUE, $chart_properties);

  if ($chart->show_slider) {

    $slider_properties = array(
      'gridLineColor' => '"transparent"',
      'yValueFormatter' => 'hideZero',
      'zoomCallback' => 'updateLineChart',
      'clickCallback' => 'slideLineChart',
      'underlayCallback' => 'highlightLineChart',
      'stepPlot' => $chart_properties['stepPlot'],
      'rollPeriod' => $chart_properties['rollPeriod'],
      'fillGraph' => $chart_properties['fillGraph'],
      'fillAlpha' => $chart_properties['fillAlpha'],
      'visibility' => $chart_properties['visibility'],
      'xAxisLabelFormatter' => $chart_properties['xAxisLabelFormatter'],
      'xValueFormatter' => $chart_properties['xValueFormatter'],
      'xValueParser' => $chart_properties['xValueParser'],
      'xTicker' => $chart_properties['xTicker']
    );

    $output .= logger_create_dygraph($chart, FALSE, $slider_properties, TRUE);
  }

  $output .= logger_create_chart_legend($chart);

  return $output;
}

/**
 * Builds the bar chart area.
 *
 * @param $chart   The chart object.
 * @return the chart area output.
 */
function theme_logger_bar_chart_area($variables) {

  $chart = $variables['chart'];
  $percentual = $chart->percentual ? 'true' : 'false';
  $data_labels = array();
  $data_labels2 = array();
  $series = array();
  $names = array();
  $stacks = array();

  if ($chart->data['series'] && $chart->data['labels']) {

    foreach ($chart->data['series'] as $uid => $userdata) {
      foreach ($userdata as $username => $sensors) {
        foreach ($sensors as $sensor => $sensordata) {
          foreach ($sensordata as $type => $values) {
            $series[] = implode(', ', $values);
          }
        }
      }
    }
    $names = array_keys($values);

    if (isset($chart->data['labels'])) {
      foreach ($chart->data['labels'] as $function => $typedata) {
        foreach ($typedata as $type => $values) {
          $data_labels[] = implode(', ', $values);
        }
      }
    }
    if (isset($chart->data['labels2'])) {
      foreach ($chart->data['labels2'] as $function => $typedata) {
        foreach ($typedata as $type => $values) {
          $data_labels2[] = implode(', ', $values);
        }
      }
    }
  }

  if (isset($chart->data['stacks'])) {
    $stacks = $chart->data['stacks'];    
  }

  $options = array('type' => 'file', 'scope' => 'header', 'group' => JS_LIBRARY, 'weight' => 150, 'defer' => TRUE);
  drupal_add_js(LOGGER_REL_PATH . '/js/flot/jquery.flot.min.js', $options);

  $options['weight']++;
  drupal_add_js(LOGGER_REL_PATH . '/js/flot/jquery.flot.stack.min.js', $options);

  $options['group'] = JS_DEFAULT;
  $options['weight']++;
  drupal_add_js(LOGGER_REL_PATH . '/js/charts-min.js', $options);

  $id = 'barChart';
  $menu = logger_create_interval_menu($chart->context);

  drupal_add_js("jQuery(document).ready( function() { " .
    "createBarChart('$id', " .
      "[ [ " . implode('], [', $series) . " ] ], " .
      "['" . implode("', '", $names) . "'], " .
      "['" . implode("', '", $chart->colors) . "'], " .
      "[ [ " . implode('], [', $data_labels) . " ] ], " .
      "[ [ " . implode('], [', $data_labels2) . " ] ], " .
      "[" . implode(", ", $stacks) . "], $percentual); " .
    "} );", array('type' => 'inline', 'scope' => 'footer', 'group' => JS_DEFAULT, 'weight' => 200, 'defer' => TRUE));
 
  return " $menu <div id='$id' class='chart'></div><br>" . t('Unit') . ': ' . t($chart->unit) . '<br><br>' .
    logger_create_chart_legend($chart);
}

/**
 * Creates a Dygraph chart.
 *
 * @param $chart          The chart object.
 * @param $create_labels  If a div needs to be created to show labels.
 * @param $properties     The Dygraph properties.
 * @param $slider         If the chart is a slider.
 * @return the Dygraph output.
 */
function logger_create_dygraph($chart, $create_labels, $properties = array(), $slider = FALSE) {

  $properties = array_merge($properties, array(
    'labelsDiv' => '"chartLabels"',
    'colors' => '["' . implode('","', $chart->colors) . '"]',
    'includeZero' => 'true'
  ));

  $labels_output = isset($create_labels) ? '<div id=' . $properties['labelsDiv'] . ' class="legend"></div>' : '';

  $pairs = array();
  foreach ($properties as $key => $value) {
    $pairs[] = "$key: $value";
  }
  $properties = $pairs;

  $weather = array();
  if ($slider) {
    $id = 'sliderChart';
    $cssClass = 'slider';
  }
  else {
    $id = 'lineChart';
    $cssClass = 'chart';

    if (isset($chart->data['weather'])) {
      foreach ($chart->data['weather'] as $i => $values) {
        $pairs = array();
        foreach ($values as $time => $icon) {
          $degrees = $chart->data['temperature'][$i][$time];
          $pairs[] = "[$time, $icon, $degrees]";
        }
        $weather[] = "[ $i, [" . implode (', ', $pairs) . "] ]";
      }
    }
  }

  $options = array('type' => 'file', 'scope' => 'header', 'group' => JS_LIBRARY, 'weight' => 150, 'defer' => TRUE);

  //If IE
  if (isset($_SERVER['HTTP_USER_AGENT']) && strpos(strtoupper($_SERVER['HTTP_USER_AGENT']), 'MSIE')) {
    $options['weight']++;
    drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/excanvas-min.js', $options);
  }

  $options['weight']++;
  drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/strftime-min.js', $options);

  $options['weight']++;
  drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/rgbcolor-min.js', $options);

  $options['weight']++;
  drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/dygraph-canvas-min.js', $options);

  $options['weight']++;
  drupal_add_js(LOGGER_REL_PATH . '/js/dygraph/dygraph-min.js', $options);

  $options['group'] = JS_DEFAULT;
  $options['weight']++;
  drupal_add_js(LOGGER_REL_PATH . '/js/charts-min.js', $options);

  drupal_add_js('jQuery(document).ready( function() { ' .
      'createLineChart("' . $id . '", "' . $chart->file_url . '", {' . implode(', ', $properties) . '}, [' . implode(', ', $weather) . ']); ' .
    '} );', array('type' => 'inline', 'scope' => 'footer', 'group' => JS_DEFAULT, 'weight' => 200, 'defer' => TRUE));

  return '<div id="' . $id . '" class="' . $cssClass . '"></div><br>' . $labels_output;
}

/**
 * Creates the chart intervals' horizontal menu.
 *
 * @param $context  The page where the menu is going to be placed.
 * @return the list of intervals' menus.
 */
function logger_create_interval_menu($context) {

  $items = array();

  switch ($context) {
    case 'relative':
      break;

    case 'onsite':
      $items = array(
        l(t('Hour'),    "$context/hour"),
        l(t('Day'),     "$context/24hours"),
        l(t('3 Days'),  "$context/72hours"),
        l(t('Week'),    "$context/week"));

      if (user_has_role('Techniker')) {
        $items[] = l(t('Month'),   "$context/month");
      }
      break;

    case 'energy':
      $items = array(
        l(t('Day'),     "$context/day"),
        l(t('Week'),    "$context/week"),
        l(t('Month'),   "$context/month"),
        l(t('Year'),    "$context/year"));
      break;

    case 'forecast':
      $items = array(
        l(t('3 Days'), "$context/f3days"),
        l(t('2 Days'), "$context/f2days"),
        l(t('Today'),  "$context/f1day"));
      break;

    default:
      $items = array(
        l(t('Hour'),    "$context/hour"),
        l(t('Day'),     "$context/day"),
        l(t('3 Days'),  "$context/3days"),
        l(t('Week'),    "$context/week"),
        l(t('Month'),   "$context/month"),
        l(t('Year'),    "$context/year"));
      break;
  }
  return empty($items) ? '' : theme('logger_chart_tabs', $items);
}

/**
 * Builds the chart legend.
 *
 * @param $chart  The chart object.
 * @return the chart legend table.
 */
function logger_create_chart_legend($chart) {

  if (!isset($chart->data['legend'])) {
    return '';
  }
  $data = $chart->data['legend'];

  $lines = array();
  $header = array(array('data' => ''));

  foreach ($data as $line_id => $cells) {

    $lines[$line_id] = array(array(
      'data' => theme('logger_color_picker', array(
        'chartId' => $chart->context,
        'indexes' => empty($cells['colorIds'])? array($line_id) : $cells['colorIds'],
        'colors' => $chart->colors,
        'seriesIds' => empty($cells['seriesIds']) ? array($line_id) : $cells['seriesIds']
    ))));
    unset($cells['seriesIds']);
    unset($cells['colorIds']);

    foreach ($cells as $title => $value) {

      if (is_numeric($value)) {
        $value = $value > 0 ? number_format($value, 2) : '';
        $align = 'right';
      } 
      else {
        $align = 'left';
      }

      $lines[$line_id][] = array('data' => $value, 'align' => $align);
      $header[$title] = array('data' => t($title));
    }
  }

  if (logger_is_mobile_device()) {

    $options = array('type' => 'inline', 'scope' => 'footer', 'group' => JS_DEFAULT, 'weight' => 201);

    drupal_add_js("jQuery(window).resize( function() { resizeTable('" . LOGGER_TABLE_ID . "'); resizeCharts(); } );", $options);
    drupal_add_js("jQuery(document).ready( function() { resizeTable('" . LOGGER_TABLE_ID . "'); } );", $options);
  }

  return theme_table(array('header' => $header, 'rows' => $lines, 'attributes' => array('id' => LOGGER_TABLE_ID, 'class' => 'resizable'),
    'caption' => '', 'empty' => '', 'sticky' => FALSE, 'colgroups' => array())) .
    '<p align="right">' . l(t('Save Data'), $chart->file_url) . '</p>';
}

/**
 * Returns the list of colors used in chart series.
 *
 * @param $chart_id   The chart id.
 * @return array of colors.
 */
function logger_get_series_colors($chart_id) {

  $palettes['power'] = array(
    '#0000FC', //BLUE
    '#C11700', //RED
    '#4D7060', //GREEN4
    '#B54FC6', //PINK
    '#F37E2B', //ORANGE
    '#809090', //GREY
    '#665C00', //BROWN
    '#050305', //BLACK
    '#0080FF', //SKYBLUE
    '#00FF00', //GREEN2
    '#DED00F', //BROWN2
    '#377037', //GREEN
    '#F27D79', //PINK2
    '#00ffff', //CYAN
    '#FBEB0D', //YELLOW
    '#5DA3CF', //BLUE2
    '#C0C0C0', //GRAY2
    '#BFD9D3', //GREEN5
    '#4D7060'  //GREEN4
  );
  $palettes['energy'] = array_reverse($palettes['power']);
  $palettes['overview'] = $palettes['power'];
  $palettes['relative'] = $palettes['energy'];

  $palettes['onsite'] = array(
    '#B1C800', //GREEN5
    '#B1C800', //GREEN5
    '#A8AFAF', //GRAY3
    '#1F82C0', //BLUE3
    '#A8AFAF', //GRAY3
    '#1F82C0'  //BLUE3
  );

  $palette = isset($palettes[$chart_id]) ? $palettes[$chart_id] : $palettes['power'];

  for ($i = 0; $i < count($palette); $i++) {
    $default = $palette[$i % count($palette)];
    $user_palette[$i] = logger_get_variable("series_color_$chart_id" . "_$i", $default);
  }
  return $user_palette;
}

function logger_get_appliance_ids() {

  return array(
    FRIDGE_APPLIANCE_ID,
    SHOWER_APPLIANCE_ID,
    DISH_WASHER_APPLIANCE_ID,
    KETTLE_APPLIANCE_ID
  );
}

function logger_block_info() {
  $blocks['posts']['info'] = t('Recent blog posts');
  $blocks['posts']['status'] = TRUE;
  $blocks['posts']['region'] = 'right';
  $blocks['posts']['weight'] = 3;
  $blocks['posts']['pages'] = '<front>\nlogger/\nlogger/*';
  $blocks['posts']['cache'] = 0x0008;
  return $blocks;
}

function logger_block_view($delta) {
  
  $block = array();
  if ($delta == 'posts' && user_access('access content')) {

    $sql = "
      SELECT
        n.nid,
        n.title,
        n.created
      FROM
        {node} n
      WHERE
        n.type = :type AND
        n.status = :status
      ORDER BY
        n.created DESC";

    $result = db_query_range($sql, 0, 5, array('type' => 'blogpost', ':status' => 1));
    
    $node_title_list = node_title_list($result);

    if ($node_title_list) {
      $block['subject'] = t('Recent blog posts');
      $block['content'] = $node_title_list;
      $block['content'] .= theme('more_link', array('url' => url('blog'), 'title' => t('Read the latest blog entries.')));
    }
  }
  return $block;
}

function logger_mail_alter(&$message) {

  global $base_url;

  switch ($message['id']) {
    case 'contact_page_mail':

      //Completes the user contact e-mail with a link to his list of devices
      $message['body'][] = l(t("User Devices:"), "$base_url/deployment/list?user_name=" . $message['params']['name']);
      break;
  }
}

function logger_create_chart_form($form, $submit_js, $chart) {

  $show_price = user_has_role('Expert') && strpos(" $chart->unit", '€') > 0;
  $use_sensor_prices = logger_get_variable('use_sensor_prices', 1);

  $unit_type = logger_get_unit_type($chart->unit);
  $units = $unit_type == 'power' ? logger_get_power_units_options() : logger_get_energy_units_options();

  //FIXME: the units array should be informed by a caller function
  if ($chart->context == 'balance') {
    unset($units['€/year']);
  }

  $form[$unit_type . '_unit'] = array(
    '#type' => 'select',
    '#title' => t('Unit'),
    '#description' => t('Select the chart unit.'),
    '#options' => $units,
    '#default_value' => $chart->unit,
    '#required' => TRUE,
    '#attributes' => array('onchange' => $submit_js),
    '#weight' => -99
  );

  $form['use_sensor_prices'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use sensor prices'),
    '#description' => t('Do you want the chart series to use the prices defined for each sensor?'),
    '#default_value' => $use_sensor_prices,
    '#return_value' => 1,
    '#attributes' => array('onclick' => $submit_js), //In IE, onchange does not work
    '#access' => $show_price,
    '#weight' => -98
  );

  $form['price1'] = array(
    '#type' => 'textfield',
    '#title' => t('Energy Consumption Price'),
    '#description' => t("Enter the energy consumption price."),
    '#maxlength' => 6,
    '#field_prefix' => '€ ',
    '#default_value' => $chart->prices[CONSUMPTION_SENSOR_TYPE],
    '#field_suffix' => ' / kWh',
    '#access' => $show_price && !$use_sensor_prices && in_array(CONSUMPTION_SENSOR_TYPE, $chart->types),
    '#element_validate' => array('element_validate_integer_positive'),
    '#weight' => -97
  );

  $form['price2'] = array(
    '#type' => 'textfield',
    '#title' => t('Energy Production Price'),
    '#description' => t("Enter the energy production price."),
    '#maxlength' => 6,
    '#field_prefix' => '€ ',
    '#default_value' => $chart->prices[PRODUCTION_SENSOR_TYPE],
    '#field_suffix' => ' / kWh',
    '#access' => $show_price && !$use_sensor_prices && in_array(PRODUCTION_SENSOR_TYPE, $chart->types),
    '#element_validate' => array('element_validate_integer_positive'),
    '#weight' => -96
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Refresh'),
    '#weight' => 200
  );
  return $form;
}

function logger_barchart_form($form, &$form_state, $chart) {

  global $user;

  $submit_js = 'submitBarChartForm(this)';
  $form = logger_create_chart_form($form, $submit_js, $chart);
  $meter_options = logger_get_meters_options($chart->types);
  $types_options = logger_get_sensor_types_options($user->uid);
  $selected_types = logger_get_variable('selected_sensor_types', array_keys($types_options));

  $form['aggregate_sensors'] = array(
    '#type' => 'checkbox',
    '#title' => t("Sum of sensor readings"),
    '#description' => t('Do you want to sum up all sensors?'),
    '#default_value' => logger_get_variable('aggregate_sensors', 1),
    '#return_value' => 1,
    '#attributes' => array('onclick' => $submit_js), //In IE, onchange does not work
    '#access' => $chart->context == 'energy'
  );

  $form['selected_sensor_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Sensor types'),
    '#description' => t('Select the types of sensors to be shown on the chart.'),
    '#default_value' => logger_get_variable('selected_sensor_types', array_keys($types_options)),
    '#options' => $types_options,
    '#required' => TRUE,
    '#attributes' => array('onclick' => $submit_js), //In IE, onchange does not work
    '#access' => $chart->context == 'energy'
  );

  $form['selected_meters'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Sensors'),
    '#description' => t('Select the sensors you want to plot on the chart.'),
    '#default_value' => logger_get_variable('selected_meters', array_keys($meter_options)),
    '#options' => $meter_options,
    '#required' => TRUE,
    '#attributes' => array('onclick' => $submit_js), //In IE, onchange does not work
    '#access' => $chart->context != 'energy'
  );
  return $form;
}

function logger_linechart_form($form, &$form_state, $chart) {

  global $base_path;

  $on_change_reset_js = 'submitLineChartForm(true)';
  $on_change_js = 'submitLineChartForm()';
  $form = logger_create_chart_form($form, $on_change_reset_js, $chart);
  $resolutions = $chart->context == 'forecast' ? array(HOUR => t('Hour')) : logger_get_resolutions_options();
  $meter_options = logger_get_meters_options($chart->types);

  $form['new_user'] = array(
    '#type' => 'select',
    '#title' => t('Add User'),
    '#description' => t('Select a user to be added to the chart.'),
    '#options' => logger_get_users_options(),
    '#default_value' => 0,
    '#attributes' => array('onchange' => $on_change_reset_js),
    '#access' => $chart->context == 'power',
    '#weight' => -100
  );

  $form['smoothing_level'] = array(
    '#type' => 'textfield',
    '#theme' => 'logger_smoothing_level',
    '#title' => t('Smoothing Level'),
    '#description' => t("Increase this number to smooth the series' lines and make the chart more readable."),
    '#maxlength' => 3,
    '#size' => 3,
    '#text-align' => 'center',
    '#default_value' => logger_get_variable('smoothing_level', 1),
    '#required' => TRUE,
  );

  $form['step_plot'] = array(
    '#type' => 'checkbox',
    '#title' => t('Stepped Lines'),
    '#description' => t('Do you want the chart series to use stepped lines?'),
    '#default_value' => logger_get_variable('step_plot', 0),
    '#return_value' => 1,
    '#attributes' => array('onclick' => $on_change_js), //In IE, onchange does not work
  );

  $form['filled_graph'] = array(
    '#type' => 'checkbox',
    '#title' => t('Filled Lines'),
    '#description' => t('Do you want the chart series to use filled lines?'),
    '#default_value' => logger_get_variable('filled_graph', 1),
    '#return_value' => 1,
    '#attributes' => array('onclick' => $on_change_js), //In IE, onchange does not work
  );

  $form['yvalue'] = array(
    '#type' => 'textfield',
    '#theme' => 'logger_value_range',
    '#title' => t('Value Range'),
    '#description' => t("Enter the value range shown on the Y axis, and click the Refresh button."),
    '#maxlength' => 12,
    '#size' => 12,
    '#text-align' => 'right',
  );

  $form['xvalue'] = array(
    '#type' => 'textfield',
    '#theme' => 'logger_time_period',
    '#title' => t('Time Period'),
    '#description' => t("Enter the time period shown on the X axis, and click the Refresh button."),
    '#text-align' => 'center',
  );

  $form['resolution'] = array(
    '#type' => 'select',
    '#title' => t('Time Resolution'),
    '#description' => t('Select the amount of time represented by each point on the chart.'),
    '#options' => $resolutions,
    '#default_value' => $chart->resolution,
    '#required' => TRUE,
    '#attributes' => array('onchange' => $on_change_js),
    '#access' => $chart->context != 'onsite'
  );

  $form['selected_meters'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Sensors'),
    '#description' => t('Select the sensors you want to plot on the chart.'),
    '#default_value' => logger_get_variable('selected_meters', array_keys($meter_options)),
    '#options' => $meter_options,
    '#required' => TRUE,
    '#attributes' => array('onclick' => $on_change_js), //In IE, onchange does not work
    '#access' => $chart->context == 'onsite'
  );
  return $form;
}

/**
 * Builds the chart tabs list.
 *
 * @param $items The tabs list items.
 * @return the tabs HTML code.
 */
function theme_logger_chart_tabs($items = array()) {

  $output = '<div class="tabs"><ul>';
  foreach ($items as $item) {
    $output .= "<li>$item</li>";
  }
  $output .= "</ul></div>";
  return $output;
}

/**
 * Builds the smoothing level field.
 *
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_smoothing_level($variables) {

  $element = $variables['element'];
  $id = $element['#id'];
  $value = check_plain($element['#value']);

  return
    logger_create_smoothing_button($id, '<<', -10) .
    logger_create_smoothing_button($id, '<',   -1) .

    logger_create_custom_field($element, '', $value) .

    logger_create_smoothing_button($id, '>',    1) .
    logger_create_smoothing_button($id, '>>',   10);
}

/**
 * Creates a button to update the chart smoothing level.
 *
 * @param $field_id  The smoothing level field id.
 * @param $caption   The button caption text.
 * @param $step      The smoothing steps to be triggered when the button is pressed.
 * @return the button HTML code.
 */
function logger_create_smoothing_button($field_id, $caption, $step) {
  return '<input type="button" value="' . $caption . '" ' .
    'onClick="javascript: return updateSmoothingLevel(' . "'$field_id', " . $step . ');"/>';
}

/**
 * Creates a composite field for informing geographic location.
 * 
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_geo_location($variables) {

  $element = $variables['element'];
  $coordinates = check_plain($element['#value']);
  $latitude = strtok($coordinates, ',');
  $longitude = strtok(',');

  $options = array('type' => 'inline', 'scope' => 'footer', 'group' => JS_DEFAULT, 'weight' => 202, 'defer' => TRUE);
  drupal_add_js("jQuery(document).ready(function(){createMap($latitude, $longitude);});", $options);

  $latitude_field = logger_create_custom_field($element, '_latitude', $latitude, 11, 11);
  $longitude_field = logger_create_custom_field($element, '_longitude', $longitude, 11, 11);

  return '<div>' .
    t('Latitude') . ": $latitude_field &nbsp;&nbsp;" .
    t('Longitude') . ": $longitude_field </div>" .
    '<div id="map" class="map"></div>';
}

/**
 * Builds the group of fields for informing value range.
 *
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_value_range($variables) {

  $element = $variables['element'];
  $field1 = logger_create_custom_field($element, 1, '');
  $field2 = logger_create_custom_field($element, 2, '');

  return logger_compose_range_fields($element, $field1, $field2);
}

/**
 * Builds the group of fields for informing a time.
 *
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_time($variables) {

  $element = $variables['element'];
  return logger_create_time_fields($element);
}

/**
 * Builds the group of fields for informing a time period.
 *
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code.
 */
function theme_logger_time_period($variables) {

  $element = $variables['element'];
  $field1 = logger_create_time_fields($element, 1);
  $field2 = logger_create_time_fields($element, 2);

  return logger_compose_range_fields($element, $field1, $field2);
}

/**
 * Builds a color picker component.
 *
 * @param $variables  The color picker variables.
 * @return the picker HTML code.
 */
function theme_logger_color_picker($variables) {

  drupal_add_js(LOGGER_REL_PATH . '/js/jscolor/jscolor-min.js', array('type' => 'file', 'scope' => 'header', 'group' => JS_LIBRARY, 'weight' => 150, 'defer' => TRUE));

  $chart_id = $variables['chartId'];
  $colors = $variables['colors'];
  $pickers = '';
  $created = array();

  foreach ($variables['indexes'] as $color_index) {

    $picker_id = 'series_color' . $color_index;

    //Visible color button
    $pickers .= '<input ' .
      'class="color {valueElement:' . "'$picker_id'" . '} ' .
      'type="button" ' .
      'style="width: 10px; height: 10px; color: transparent;"/><br>';

    if (!in_array($color_index, $created)) {

      //Synchronize picker colors if multiple legend lines refer to the same chart series
      $on_change = "syncColorPickers($color_index, this.value)";
      foreach ($variables['seriesIds'] as $series_id) {
        $on_change .= " && setSeriesColor('$chart_id', $series_id, this.value)";
      }

      //Hidden control button
      $pickers .= '<input
        id="' . $picker_id . '"
        type="hidden"
        value="' . $colors[$color_index % count($colors)] . '"
        onchange="javascript: ' . $on_change . ';"/>';
    }
    $created[] = $color_index;
  }
  return $pickers;
}

/**
 * Creates two fields to represent a timestamp: one for date and another for time.
 *
 * @param $element  The Drupal form field element.
 * @param $suffix   A suffix for the field id and name (optional).
 * @return the fields HTML code.
 */
function logger_create_time_fields($element, $suffix = '') {

  drupal_add_library('system', 'ui.datepicker');
  drupal_add_css(LOGGER_REL_PATH . '/style/ui.datepicker.css');

  $picker_properties = '{ ' .
    "yearRange: '-1:+0', " .
    "showAnim: 'fadeIn', " .
    "dateFormat: 'dd-mm-yy', " .
    "currentText: '" . t('Today') . "', " .
    "nextText: '" . t('Next Month') . "', " .
    "prevText: '" . t('Previous Month') . "', " .
    "dayNamesMin: [" . t("'Su','Mo','Tu','We','Th','Fr','Sa'") . "], " .
    "monthNames: ['" . t('January') . "', '" . t('February') . "', '" . t('March') . "', '" . t('April') . "', '" . t('May') . "', '" . t('June') . "', '" .
    t('July') . "', '" . t('August') . "', '" . t('September') . "', '" . t('October') . "', '" . t('November') . "', '" . t('December') . "'] }";

  $options = array('type' => 'inline', 'scope' => 'footer', 'group' => JS_DEFAULT, 'weight' => 203, 'defer' => TRUE);
  $field_id = '#edit-' . str_replace('_', '-', $element['#name']) . $suffix . 'date';
  drupal_add_js('jQuery(document).ready(function(){jQuery("' . $field_id . '").datepicker(' . $picker_properties . ');});', $options);

  $time = '';
  $date = '';
  if (isset($element['#default_value']) && $element['#default_value'] > 0) {
    $date = date('d-m-Y', $element['#default_value']);
    $time = date('H:i', $element['#default_value']);
  }

  return logger_create_custom_field($element, $suffix . 'date', $date, 10, 10) .
    logger_create_custom_field($element, $suffix . 'time', $time, 5, 5);
}

/**
 * Arranges fields to represent a range.
 *
 * @param $element  The Drupal form field element.
 * @param $field1   The field that contains the lowest value.
 * @param $field2   The field that contains the highest value.
 * @return the fields HTML code.
 */
function logger_compose_range_fields($element, $field1, $field2) {

  return '<span style="white-space:nowrap;">' .
    t('from:') . $field1 . '&nbsp;&nbsp;&nbsp;' . '</span>' .
    '<span style="white-space:nowrap;">' .
    t('to:') . '&nbsp;&nbsp;' . $field2 . '</span>';
}

/**
 * Creates a customized form field.
 *
 * @param $element     The Drupal form field element.
 * @param $suffix      A suffix for the field id and name.
 * @param $value       The field value.
 * @param $size        The field size.
 * @param $maxlength   The field maximum length.
 * @return the field HTML code.
 */
function logger_create_custom_field($element, $suffix, $value, $size = 0, $maxlength = 0) {

  $name = $element['#name'] . $suffix;
  $id = $element['#id'] . $suffix;
  $align = $element['#text-align'] . ';';
  $size = $size > 0 ? $size : $element['#size'];
  $maxlength = $maxlength > 0 ? $maxlength : $element['#maxlength'];

  $attributes = isset($element['#attributes']) ? drupal_attributes($element['#attributes']) : '';

  return '<input type="text" ' .
    'name="' . $name . '" ' .
    'id="' . $id . '" ' .
    'maxlength="' . $maxlength . '" ' .
    'size="' . $size . '" ' .
    'value="' . $value . '" ' .
    'style="text-align: ' . $align . '" ' .
    $attributes . ' />';
}

function logger_linechart_form_validate($form, &$form_state) {

  $smoothing_level = $form_state['values']['smoothing_level'];
  if (strval(intval($smoothing_level)) != strval($smoothing_level) || $smoothing_level < 1) {
    form_set_error('smoothing_level', t('The smoothing level must be an integer number greater than 0.'));
  }
  if ($form_state['values']['step_plot'] != 1 && $form_state['values']['step_plot'] != 0) {
    form_set_error('step_plot', t('The stepped lines option must be either 0 or 1.'));
  }
  if ($form_state['values']['filled_graph'] != 1 && $form_state['values']['filled_graph'] != 0) {
    form_set_error('filled_graph', t('The filled lines option must be either 0 or 1.'));
  }

  $yvalue1 = logger_get_yvalue(1);
  $yvalue2 = logger_get_yvalue(2);

  if (!($yvalue1 == '' && $yvalue2 == '') && !($yvalue2 > $yvalue1)) {
    form_set_error('yvalue', t('The value range is invalid.'));
  }

  $xvalue1 = logger_get_xvalue(1);
  $xvalue2 = logger_get_xvalue(2);

  if (!($xvalue2 > $xvalue1)) {
    form_set_error('xvalue', t('Time period is invalid.'));
  }
}

function logger_barchart_form_submit($form, &$form_state) {

  logger_chart_form_submit($form, $form_state);

  if (isset($form_state['values']['selected_meters'])) {
    logger_set_variable('selected_meters', $form_state['values']['selected_meters']);
  }
  if (isset($form_state['values']['aggregate_sensors'])) {
    logger_set_variable('aggregate_sensors', $form_state['values']['aggregate_sensors']);
  }
  if (isset($form_state['values']['selected_sensor_types'])) {
    logger_set_variable('selected_sensor_types', $form_state['values']['selected_sensor_types']);
  }
}

function logger_linechart_form_submit($form, &$form_state) {

  logger_chart_form_submit($form, $form_state);

  if (isset($form_state['values']['new_user']) && $form_state['values']['new_user'] > 0) {
    logger_add_user_series($form_state['values']['new_user'], 'power'); //FIXME: read context from form field
  }
  if (isset($form_state['values']['selected_meters'])) {
    logger_set_variable('selected_meters', $form_state['values']['selected_meters']);
  }

  logger_set_variable('step_plot', $form_state['values']['step_plot']);
  logger_set_variable('filled_graph', $form_state['values']['filled_graph']);
  logger_set_variable('smoothing_level', $form_state['values']['smoothing_level']);

  //FIXME: get rid of this redirection
  $form_state['redirect'] = array($_GET['q'], array('query' => $_REQUEST));
}

function logger_chart_form_submit($form, &$form_state) {

  if (isset($form_state['values']['energy_unit'])) {
    logger_set_variable('energy_unit', $form_state['values']['energy_unit']);
  }
  if (isset($form_state['values']['power_unit'])) {
    logger_set_variable('power_unit', $form_state['values']['power_unit']);
  }
  if (isset($form_state['values']['use_sensor_prices'])) {
    logger_set_variable('use_sensor_prices', $form_state['values']['use_sensor_prices']);
  }
  if (isset($form_state['values']['price1'])) {
    logger_set_variable('price1', $form_state['values']['price1']);
  }
  if (isset($form_state['values']['price2'])) {
    logger_set_variable('price2', $form_state['values']['price2']);
  }
}

/**
 * Returns a list of all sensor types.
 * 
 * @param $uid  The user id.
 * @return an array of sensor types.
 */
function logger_get_sensor_types_options($uid = NULL) {

  $query = db_select('logger_meter_type', 't');

  if (isset($uid)) {
    $query->join('logger_meters', 'm', 't.id = m.type');
    $query->condition('uid', $uid, '=');
  }

  $result = $query->fields('t', array('id', 'name'))
    ->distinct(TRUE)
    ->orderBy('id')
    ->execute();

  $options = array();
  foreach ($result as $type) {
    $options[$type->id] = t($type->name);
  }
  return $options;
}

/**
 * Returns a list of all meters of the informed type.
 *
 * @param $types    The sensor types.
 * @param $virtual  Whether virtual sensors should be returned.
 * @return an array of meters.
 */
function logger_get_meters_options($types, $virtual = FALSE) {

  global $user;

  $sensors = logger_get_sensors($types, array($user->uid), $virtual);
  $options = array();
  foreach ($sensors as $sensor) {
    $options[$sensor->meter] = $sensor->function;
  }
  return $options;
}

/**
 * Returns an array of energy units to be used as options of HTML select fields.
 *
 * @return the array of units.
 */
function logger_get_energy_units_options() {
  return array('kWh' => t('kWh'), '€' => t('Euro'));
}

/**
 * Returns an array of power units to be used as options of HTML select fields.
 *
 * @return the array of units.
 */
function logger_get_power_units_options() {
  return array('W' => t('Watt'), 'kWh/year' => t('kWh/year'), '€/year' => t('Euro/year'));
}

/**
 * Returns the type of an unit.
 *
 * @param $unit The unit being tested.
 * @return either energy or power.
 */
function logger_get_unit_type($unit) {

  $energy_units = logger_get_energy_units_options();
  return isset($energy_units[$unit]) ? 'energy' : 'power';
}

/**
 * Returns either the lowest or the highest value shown on the Y axis.
 *
 * @param $index Inform 1 for the lowest, 2 for the highest.
 * @return the value.
 */
function logger_get_yvalue($index) {

  return isset($_REQUEST['yvalue' . $index]) ? $_REQUEST['yvalue' . $index] : 0;
}

/**
 * Returns either the lowest or the highest value shown on the X axis.
 *
 * @param $index Inform 1 for the lowest, 2 for the highest.
 * @return the value.
 */
function logger_get_xvalue($index) {

  //Both need to be set
  if (!(isset($_REQUEST['xvalue' . $index . 'date']) && isset($_REQUEST['xvalue' . $index . 'time']))) {
    return 0;
  }

  $formatted = $_REQUEST['xvalue' . $index . 'date'] . ' ' . $_REQUEST['xvalue' . $index . 'time'];

  //Parses a datetime string formatted as dd-mm-yyyy hh:mm to a Unix timestamp.
  $str = "$formatted:00 GMT+00:00";
  $d = strtok($str, '-');
  $m = strtok('-');
  $r = strtok('-');
  $timestamp = strtotime("$m/$d/$r");
  $timestamp -= get_timezone_offset();

  return $timestamp > 0 ? $timestamp : 0;
}

/**
 * Returns the chart resolution of a time interval menu option.
 *
 * @param $interval  The time interval menu option.
 * @return the chart resolution.
 */
function logger_get_resolution($interval) {

  $resolution = isset($_REQUEST['resolution']) ? $_REQUEST['resolution'] : 0;
  if ($resolution > 0) {
    return $resolution;
  }

  $options = array(
    'hour' => 1 * MINUTE,
    'day' => 15 * MINUTE,
    '24hours' => 1 * MINUTE,
    '72hours' => 1 * MINUTE,
    '3days' => 15 * MINUTE,
    'week' => 15 * MINUTE,
    'month' => 1 * DAY,
    'year' => 1 * WEEK,
    'f3days' => 1 * HOUR,
    'f2days' => 1 * HOUR,
    'f1day' => 1 * HOUR
  );
  return $options[$interval];
}

/**
 * Returns an array of chart resolutions.
 *
 * @return the array of chart resolutions.
 */
function logger_get_resolutions_options() {

  return array(
    1 * MINUTE => 1 . ' ' . t('Minute'),
    15 * MINUTE => 15 . ' ' . t('Minutes'),
    1 * HOUR => 1 . ' ' . t('Hour'),
    1 * DAY => 1 . ' ' . t('Day'),
    1 * WEEK => 1 . ' ' . t('Week')
  );
}

/**
 * Returns the default time window associated with a time interval menu option.
 *
 * @param $interval  The time interval menu option.
 * @param $absolute  Whether the absolute value of the time window is to be returned.
 * @return the amount of seconds of the time window.
 */
function logger_get_default_time_window($interval, $absolute = TRUE) {

  $windows = array(
    'minute' => -1 * MINUTE,
    'hour' => -1 * HOUR,
    'dayquarter' => -6 * HOUR,
    'day' => -1 * DAY,
    '24hours' => -1 * DAY,
    '72hours' => -3 * DAY,
    '3days' => -3 * DAY,
    'week' => -7 * DAY,
    'month' => -30 * DAY,
    'year' => -365 * DAY,
    'f3days' => 3 * DAY,
    'f2days' => 2 * DAY,
    'f1day' => 1 * DAY
  );
  $window = $windows[$interval];
  return ($absolute ? abs($window) : $window);
}

/**
 * Returns the sub parts that compose a time interval.
 * 
 * @param $interval  The time interval.
 * @return the sub interval name.
 */
function logger_get_sub_interval($interval) {

  $windows = array(
    'hour' => 'minute',
    'dayquarter' => 'hour',
    'day' => 'dayquarter',
    '24hours' => 'hour',
    '72hours' => 'hour',
    '3days' => 'day',
    'week' => 'day',
    'month' => 'week',
    'year' => 'month',
    'f3days' => 'day',
    'f2days' => 'day',
    'f1day' => 'hour'
  );
  return $windows[$interval];
}

/**
 * Returns an array containing two timestamps representing period of time of
 * the slider chart.
 *
 * @param $interval     The time interval menu option.
 * @param $start        The initial timestamp, if known.
 * @param $end          The final timestamp, if known.
 * @param $fill_slider  Whether to expand the period to fill chart slider.
 * @return the period of time as an array.
 */
function logger_get_period($interval, $start = 0, $end = 0, $fill_slider = TRUE) {

  //If period not informed, consider default time window
  $window = $start > 0 && $end > 0 ? $end - $start : logger_get_default_time_window($interval);

  if ($fill_slider) {
    //Expand window to fill slider
    $window *= 5;
  }
  return array('start' => ($end - $window), 'end' => $end);
}

/**
 * Returns an array of fluksonian users indexed by their respective user id.
 * Only users not yet plotted on the chart are returned.
 *
 * @return the array of fluksonian users.
 */
function logger_get_users_options() {

  global $user;

  $options = array(0 => '');
  $is_visitor = user_has_role('Visitor');

  $query = db_select('users', 'u')
    ->fields('u', array('uid', 'name'))
    ->groupBy('u.uid');

  $query->join('logger_users', 'lu', 'lu.uid = u.uid');
  $query->condition('lu.private', 0);

  $query->join('logger_meters', 'm', 'm.uid = u.uid');
  $query->isNotNull('m.function')
    ->condition('m.uid', 0, '>')
    ->orderBy('u.name');

  $fluksonians = $query->execute();
  foreach ($fluksonians as $fluksonian) {

    //Hide user names for Visitors
    $username = $is_visitor ? t('User') . ' ' . str_pad($fluksonian->uid, 3, '0', STR_PAD_LEFT) : $fluksonian->name;
    $options[$fluksonian->uid] = $username;
  }
  unset($options[$user->uid]);
  //TODO: sort() produces different results in different machines

  return $options;
}

/**
 * Adds an user to the chart.
 *
 * @param $uid     The id of the user to be added.
 * @param $context The chart context.
 */
function logger_add_user_series($uid, $context) {

  global $user;

  $types = array(CONSUMPTION_SENSOR_TYPE, PRODUCTION_SENSOR_TYPE);
  $sensors = logger_get_sensors($types, array($uid), TRUE);
  $selected_sensors = logger_get_variable($context . '_selected_sensors', array());

  foreach ($sensors as $sensor) {

    if (!in_array($sensor, $selected_sensors)) {
      $selected_sensors[] = $sensor;
    }
  }
  logger_set_variable($context . '_selected_sensors', $selected_sensors);
}

/**
 * Removes a sensor from the line chart.
 *
 * @param $meter   The id of the sensor to be removed.
 * @param $context The chart context.
 */
function logger_remove_sensor_series($meter, $context) {

  $selected_sensors = logger_get_variable($context . '_selected_sensors', array());
  $remaining = array();

  foreach ($selected_sensors as $sensor) {

    if ($sensor->meter != $meter) {
      $remaining[] = $sensor;
    }
  }
  logger_set_variable($context . '_selected_sensors', $remaining);
}

/**
 * Hides a sendor series on the line chart.
 *
 * @param $meter   The id of the sensor to be hidden.
 * @param $context The chart context.
 */
function logger_hide_sensor_series($meter, $context) {

  $selected_sensors = logger_get_variable($context . '_selected_sensors', array());
  $changed = array();

  foreach ($selected_sensors as $sensor) {
    if ($sensor->meter == $meter) {
      $sensor->visible = !$sensor->visible;
    }
    $changed[] = $sensor;
  }
  logger_set_variable($context . '_selected_sensors', $changed);
}

/**
 * Returns the value of a persistent variable.
 *
 * @param $id            The variable id.
 * @param $default_value The value to be returned if the variable is not yet defined.
 * @return the variable value.
 */
function logger_get_variable($id, $default_value) {

  global $user;

  $id = "logger_$id";

  if (isset($user->uid)) {

    //Visitors must use cookies
    if (user_has_role('Visitor')) {
      return isset($_SESSION[$id]) ? $_SESSION[$id] : $default_value;
    }
    else {
      $id .= '_' . $user->uid;
      return variable_get($id, $default_value);
    }
  }
  else {

    $value = isset($_COOKIE[$id]) ? $_COOKIE[$id] : $default_value;
    if (strpos(" $value", 'ARR') == 1) {
      $value = explode(',', substr($value, 3));
    }
    return $value;
  }
}

/**
 * Sets the value of a persistent variable.
 *
 * @param $id     The variable id.
 * @param $value  The variable value.
 */
function logger_set_variable($id, $value) {

  global $user;

  $id = "logger_$id";

  if ($user->uid) {

    //Visitors must use cookies
    if (user_has_role('Visitor')) {
      $_SESSION[$id] = $value;
    }
    else {
      $id .= '_' . $user->uid;
      variable_set($id, $value);
    }
  }
  else {
    if (is_array($value)) {
      $value = 'ARR' . implode(',', $value);
    }
    setcookie($id, $value, REQUEST_TIME + WEEK, '/');
  }
}

/**
 * Returns list detected appliances at a specific moment in time.
 *
 * @param $cache_id  The cache id.
 */
function logger_get_appliances($cache_id) {

  drupal_add_http_header('Content-Type', 'application/json;');

  if (user_has_role('Expert')) {

    $cache = cache_get($cache_id, 'cache_page');

    if ($cache->data && isset($cache->data['appliances'])) {
      $detected = $cache->data['appliances'];

    } else {
      $detected = array();
    }

  } else {
    $detected = array();
  }

  print json_encode($detected);
  exit(0);  
}

function logger_form_alter(&$form, &$form_state, $form_id) {

  if ($form_id == 'user_login') {
    $form_state['#redirect'] = 'logger';
    $form['name']['#size'] = 20;
    $form['pass']['#size'] = 20;
  }
}

function logger_account_access($permission) {

  global $user;

  return $user->uid == $GLOBALS['user']->uid && user_access($permission);
}

/**
 * Access callback ensuring the sensor is accessible only to the owner.
 */
function logger_sensor_access($permission, $meter) {

  if ($GLOBALS['user']->uid == 1) {
    return TRUE;
  }

  $uid = db_select('logger_meters', 'm')
    ->fields('m', array('uid'))
    ->condition('m.meter', $meter, '=')
    ->execute()
    ->fetchField();

  return $uid == $GLOBALS['user']->uid && user_access($permission);
}

/**
 * Access callback ensuring the device is accessible only to the owner.
 */
function logger_device_access($permission, $device) {
  
  if ($GLOBALS['user']->uid == 1) {
    return TRUE;
  }

  $uid = db_select('logger_devices', 'd')
    ->fields('d', array('uid'))
    ->condition('d.device', "$device%", 'LIKE')
    ->execute()
    ->fetchField();

  if ($permission == 'activate devices') {
    $rid = get_role_id('Visitor');
    return $uid == 0 && empty($GLOBALS['user']->roles[$rid]);
  }
  else {
    return $uid == $GLOBALS['user']->uid && user_access($permission);
  }
}

/**
 * Access callback ensuring the producer pages are accessible only to users who have production sensors.
 */
function logger_producer_access($permission) {

  if ($GLOBALS['user']->uid == 1) {
    return TRUE;
  }

  $sensor = db_select('logger_meters', 'm')
    ->fields('m', array('uid'))
    ->condition('m.uid', $GLOBALS['user']->uid, '=')
    ->condition('m.type', PRODUCTION_SENSOR_TYPE)
    ->execute()
    ->fetchObject();

  return $sensor && user_access($permission);
}

/**
 * Access callback ensuring the sensor forecast page is accessible only to users who have requested forecasts.
 */
function logger_forecast_access($permission) {

  if ($GLOBALS['user']->uid == 1) {
    return TRUE;
  }

  $sensor = db_select('logger_meters', 'm')
    ->fields('m', array('uid'))
    ->condition('m.uid', $GLOBALS['user']->uid, '=')
    ->condition('m.forecast', 1, '=')
    ->execute()
    ->fetchObject();

  return $sensor && user_access($permission);
}

/**
 * Queries the databases for measurements reported by sensors of a single device.
 *
 * @param $interval The time interval.
 * @param $device   The device's hash code.
 * @param $unit     The measurement unit.
 * @return the array of sensors' measurements, formatted as [meter][function][ [timestamp, value] ].
 */
function logger_query_device_measurements($interval, $device, $unit = 'W') {

  module_load_include('inc', 'logger', 'logger.rrd');

  $sql = "SELECT meter, function, price FROM {logger_meters} WHERE device = :device";
  $sensors = db_query($sql, array(':device' => $device));

  $resolution = logger_get_resolution($interval);
  $period = logger_get_period($interval);

  $measurements = array();
  foreach ($sensors as $sensor) {

    $measurements[$sensor->meter][$sensor->function] = logger_rrd_query_sensor($sensor, $unit, $period, $resolution);
  }
  return $measurements;
}

function logger_cron() {

  $rest = REQUEST_TIME % HOUR;

  //First quarter of an hour
  if ($rest >= 45 * MINUTE) {
    logger_remove_expired_support_requests();
  }

  //Second quarter of an hour
  if ($rest < 45 * MINUTE && $rest >= 30 * MINUTE) {
    logger_bind_support_ports();
    logger_update_support_authorized_keys();
  }

  //Runs only once a day
  logger_update_pvcast_models();
}

/**
 * Removes expired device support requests.
 */
function logger_remove_expired_support_requests() {

  //Remove old requests
  $timeout = REQUEST_TIME - 2 * DAY;

  db_delete('device_support_request')
    ->condition('requested', $timeout, '<')
    ->execute();

  $sql = "
    SELECT
      device
    FROM
      {device_support_slot}
    WHERE
      device IS NOT NULL AND
      NOT EXISTS(
        SELECT
          1
        FROM
          {device_support_request} r
        WHERE
          r.device = device_support_slot.device
      )";

  $result = db_query($sql);

  foreach ($result as $device) {

    db_update('device_support_slot')
      ->fields(array(
      'device' =>  NULL,
    ))
    ->condition('device', $device->device)
    ->execute();

    logger_remove_support_key($device->device);
  }
}

/**
 * Binds device support requests with available hosts/ports for reverse SSH connections.
 */
function logger_bind_support_ports() {

  //Find devices with pending support requests
  //The clause GROUP BY is used here only as a precaution against duplicated requests
  $sql = "
    SELECT
      device
    FROM
      {device_support_request}
    WHERE
      NOT EXISTS (
        SELECT
          1
        FROM
          {device_support_slot} s
        WHERE
          s.device = device_support_request.device
      )
    GROUP BY
      device
    ORDER BY
      requested";

  $result = db_query($sql);

  $bindings = array();
  foreach ($result as $device) {

    //Find an available port
    $sql = "SELECT host, tunnel_port, username FROM {device_support_slot} WHERE device IS NULL";
    $slots = db_query_range($sql, 0, 1);

    //Only 1
    foreach ($slots as $slot) {

      db_update('device_support_slot')
        ->fields(array('device' => $device->device ))
        ->condition('host', $slot->host)
        ->condition('tunnel_port', $slot->tunnel_port)
        ->execute();

      $bindings[$slot->host] = $slot->username;

      logger_create_support_key($slot->host, $device->device);
    }
  }
}

/**
 * Builds the device support requests page.
 *
 * @return the device support requests page.
 */
function logger_support_requests_page() {

  $sql = "
    SELECT
      d.device,
      u.name AS requester,
      d.serial,
      s.host,
      s.tunnel_port,
      FROM_UNIXTIME(r.requested + u.timezone, :time_format) AS requested
    FROM
      {users} u,
      {device_support_slot} s,
      {device_support_request} r,
      {logger_devices} d
    WHERE
      d.uid = u.uid AND
      s.device = d.device AND
      d.device = r.device AND
      r.requested > 0";

  $result = db_query($sql, array(':time_format' => LOGGER_TIMESTAMP_FORMAT_SQL));

  $header = array(t('Requested'), t('Requester'), t('Serial'), t('Host'), t('Command'), t('Operations'));

  $rows = array();
  foreach ($result as $req) {

    $operations = 
      l(t('Remove'), "device/support/remove/$req->device") . '<br>' .
      l(t('Postpone'), "device/support/postpone/$req->device");

    $command = "ssh root@localhost -p $req->tunnel_port -i $req->device" . "_tech_id";

    $rows[] = array(
      'requested' => $req->requested,
      'requester' => $req->requester,
      'serial' => $req->serial,
      'host' => wordwrap($req->host, 12, "\n", TRUE),
      'command' => "<input type='text' value='$command' style='width: 140px;'>",
      'operations' => $operations,
    );
  }
  return theme_table(array('header' => $header, 'rows' => $rows, 'caption' => '', 'empty' => '', 'sticky' => FALSE,
    'attributes' => array(), 'colgroups' => array()));
}

/**
 * Builds the device support request confirmation form.
 *
 * @param $device     The device id.
 * @param $serial     The device serial number.
 * @return the device support requests page.
 */
function logger_supportrequest_form($form, &$form_state, $device, $serial) {

  $form['explanation'] = array(
    '#markup' => t('You are about to request remote support for your Flukso device (Serial Number %serial). ' .
      'If so, the device will open a reverse SSH connection with our ' .
      'server that enables our technicians to log into it ' .
      'in order to check and possibly fix configuration issues.', array('%serial' => $serial)) . '<br><br>' .

    t('This authorization expires after 2 days. You can also suspend it on the previous page.') . '<br><br>' .

    t('Please, explain the problem in the field bellow. The more details you provide, the easier ' .
      'for the technician to solve the problem.') . '<br><br>'
  );

  $form['device'] = array(
    '#type' => 'hidden',
    '#required' => TRUE,
    '#default_value' => $device
  );

  $form['serial'] = array(
    '#type' => 'hidden',
    '#required' => TRUE,
    '#default_value' => $serial
  );

  $form['description'] = array(
    '#type' => 'textarea',
    '#title' => t('Problem description'),
    '#rows' => 4
  );

  $form['question'] = array(
    '#markup' => '<br>' . t('Do you allow our technicians to log into your Flukso device?') . '<br>'
  );

  $form['actions'] = array(
    '#type' => 'actions'
  );

  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Yes')
  );

  $form['actions']['cancel'] = array(
    '#type' => 'submit',
    '#value' => t('No'),
    '#submit' => array('logger_supportrequest_form_cancel')
  );

  return $form;
}

function logger_supportrequest_form_submit($form, &$form_state) {

  $device = $form_state['values']['device'];
  $serial = $form_state['values']['serial'];
  $description = $form_state['values']['description'];

  logger_request_support($device, $serial);

  logger_send_remote_support_email($device, $serial, $description);

  $form_state['redirect'] = 'device/support/requested';
}

function logger_supportrequest_form_cancel($form, &$form_state) {

  $form_state['redirect'] = 'device/mylist';
}

/**
 * Creates a device support request.
 * Any existing request of the same device is previously removed.
 *
 * @param $device The device id.
 * @param $serial The device serial number. 
 */
function logger_request_support($device, $serial) {

  db_update('device_support_slot')
    ->fields(array(
      'device' =>  NULL,
    ))
    ->condition('device', $device)
    ->execute();

  db_delete('device_support_request')
    ->condition('device', $device)
    ->execute();

  db_insert('device_support_request')
    ->fields(array(
      'device' => $device,
      'requested' => REQUEST_TIME 
    ))
    ->execute();
}

/**
 * Builds a page to inform the user that his support request has been registered.
 */
function logger_support_requested_page() {

  return t('Thank you! Your support request has been registered.' .
      'Our technicians are going to contact you as soon as possible via email.') . '<br><br>' .

      l(t('Return to the devices page.'), 'device/mylist');
}

/**
 * Removes the a device support request and its port association, and returns
 * to the user devices page.
 *
 * @param $device The device id.
 */
function logger_suspend_support($device) {

  logger_free_support_slot($device);

  drupal_goto("device/mylist");
}

/**
 * Removes the port association of a device support request and returns
 * to the support requests page.
 *
 * @param $device The device id.
 */
function logger_postpone_support($device) {

  logger_free_support_slot($device, FALSE);

  drupal_goto('device/support/requests');
}

/**
 * Removes the a device support request and its port association, and returns
 * to the support requests page.
 *
 * @param $device The device id.
 */
function logger_remove_support($device) {

  logger_free_support_slot($device);

  drupal_goto('device/support/requests');
}

/**
 * Removes the association of a port with a device support request.
 * Optionally also removes the request.
 *
 * @param $device          The device id.
 * @param $delete_request  Whether the support request needs to be removed.
 */
function logger_free_support_slot($device, $delete_request = TRUE) {

  db_update('device_support_slot')
    ->fields(array(
      'device' =>  NULL,
    ))
    ->condition('device', $device)
    ->execute();

  if ($delete_request) {
    db_delete('device_support_request')
      ->condition('device', $device)
      ->execute();
  }

  logger_remove_support_key($device);
}

/**
 * Send an email to the mySmartGrid ticket system.
 *
 * @param $device      The device id.
 * @param $serial      The device serial number.
 * @param $description The device problem description.
 */
function logger_send_remote_support_email($device, $serial, $description) {

  global $user;
  global $base_url;

  $variables = array(
    "!device" => $device,
    "%serial" => $serial,
    "%description" => $description,
    "%username" => $user->name,
    "!base_url" => $base_url
  );

  $subject = t('Remote Support') . ' - ' . t('Device') . ": $serial";
  $body = t(
    'Dear technician,' . '<br><br>' .
    'The user %username has requested remote support for the device %serial.' . '<br><br>' .
    "Problem description:<br> %description <br><br>" .
    "Click <a href='!base_url/deployment/checkup/device/!device '>here</a> to see the device status page." . '<br><br>' .
    'Best regards' . '<br>' .
    'mySmartGrid System',
    $variables
  );

  jobqueue_send_email('msg-support@itwm.fhg.de', $subject, $body);
}

/**
 * Generates a private DSS key to be used by a device to open reverse
 * SSL connections that enable remote support.
 *
 * @param $host   The host to be connected by the device.
 * @param $device The device id.
 */
function logger_create_support_key($host, $device) {
  exec(LOGGER_DEVICE_CERT_PATH . "/gen-keys.sh $host $device");
}

/**
 * Removes a private DSS key used by a device to open reverse SSL connections
 * that enable remote support.
 *
 * @param $device The device id.
 */
function logger_remove_support_key($device) {
  rmfiles(LOGGER_DEVICE_CERT_PATH . "/*/$device*");
}

/**
 * Creates the file authorized_keys that contains a list of device DSS keys
 * authorized to open reverse SSL connections for remote support.
 */
function logger_update_support_authorized_keys() {

  $query = db_select('device_support_slot', 's')
    ->fields('s', array('host', 'port'));
  $query->groupBy('host');
  $query->groupBy('port');
  $accounts = $query->execute();

  foreach ($accounts as $account) {
    exec(LOGGER_DEVICE_CERT_PATH . "/gen-authorized-keys.sh $account->host $account->port");
  }
}

/**
 * Updates PVCast plants with sensor measurements.
 */
function logger_update_pvcast_models() {

  module_load_include('inc', 'logger', 'logger.rrd');

  $last = variable_get('logger_last_pvcast_model_update', 0);
  $now = REQUEST_TIME;

  if ($now - $last >= DAY) {
    $sensors = logger_get_sensors(array(PRODUCTION_SENSOR_TYPE), NULL, FALSE, TRUE);
    $period = logger_get_period('day', $now - 4 * WEEK, $now, FALSE);

    foreach ($sensors as $sensor) {
      $measurements = logger_rrd_query_sensor($sensor, 'W', $period, HOUR);
      if (!empty($measurements)) {
        pvcast_update_model($sensor->meter, $measurements);
      }
    }
    variable_set('logger_last_pvcast_model_update', $now - ($now % HOUR));
  }
}

function logger_xmlrpc() {
  return array(
    array(
      'logger.auth', // External method name.
      'logger_auth', // Drupal callback function to run + api version 1
      array('string', 'array'), // Return value's type, then any parameter types (accept, auth)
      'Authenticate a device'   , // Description.
    ),
    array(
      'logger.heartbeat',
      'logger_heartbeat',
      array('array', 'array', 'array'),
      'Send a heartbeat to the logger.',
    ),
    array(
      'logger.measurementAdd',
      'logger_measurement_add',
      array('string', 'array', 'array'),
      'Submit measurements to the logger.',
    ),
    array(
      'logger.brownout',
      'logger_brownout',
      array('string', 'array', 'array'),
      'Send a brownout message to the logger.',
    ),
  );
}

/**
 * Authenticates a device version 1.
 * 
 * @return the authentication response.
 */
function logger_auth($auth) {

  return logger_authenticate_hmac_sha1($auth) ? 'authenticated!' :

    xmlrpc_error(-31000, t('Authentication failed.'));
}

/**
 * Forwards device heartbeat message to the RESTful API.
 *
 * @param $auth    The authentication data.
 * @param $monitor The device properties.
 * @return the heartbeat response.
 */
function logger_heartbeat($auth, $monitor) {

  return logger_forward_api_request($auth, 'device', $auth['device'], $monitor);
}

/**
 * Forwards device measurement messages to the RESTful API.
 * 
 * @param $auth  The authentication data.
 * @param $logs  The measurements array.
 * @return the measurement response.
 */
function logger_measurement_add($auth, $logs) {

  $keys = array_keys($logs);
  $meter = $keys[0];

  $values = array();
  foreach ($logs[$meter] as $timestamp => $value) {
    $values[] = array($timestamp, $value);
  }

  return logger_forward_api_request($auth, 'sensor', $meter, array('measurements' => $values), $logs);
}

/**
 * Forwards brownout event messages to the RESTful API.
 *
 * @param $auth     The authentication data.
 * @param $message  The event message.
 * @return the event response.
 */
function logger_brownout($auth, $message) {

  return logger_forward_api_request($auth, 'event', BROWNOUT_EVENT_ID, $message);
}

/**
 * Forwards XMLRPC API requests to the RESTful API.
 *
 * @param $auth         The authentication data.
 * @param $object       The entity being affected by the invocation.
 * @param $id           The object id.
 * @param $body         The request body, as a PHP object.
 * @param $signed_body  The body of the XMLRPC request that has been signed (for authentication).
 * @return the server response.
 */
function logger_forward_api_request($auth, $object, $id, $body, $signed_body = NULL) {

  $signed_body = isset($signed_body) ? $signed_body : $body;

  if (logger_authenticate_hmac_sha1(&$auth, $signed_body)) {

    $url = variable_get('logger_msg_service_url') . "/$object/$id";
    $body = json_encode($body);

    $response = drupal_http_request($url, array(
      'method' => 'POST',
      'data' => $body,
      'headers' => array(
        'X-Version' => '1.0',
        'X-Digest' => hash_hmac('sha1', $body, $auth['key'])
      )));

    if (isset($response->error)) {

      //watchdog('logger.forward', "Error forwarding to %url. %error", array('%url' => $url, '%error' => $response->error), WATCHDOG_ERROR);

      return xmlrpc_error(-32601, t('Server error.') . ' ' . $response->error);
    }
    else {
      return json_decode($response->data);
    }
  }
  else {
    return xmlrpc_error(-31000, t('Authentication failed.'));
  }
}

/**
 * Authenticates a device version 1.
 *
 * @param $auth     The authentication data.
 * @param $message  The message string.
 * @return TRUE if the authentication succeeds, FALSE otherwise.
 */
function logger_authenticate_hmac_sha1($auth, $message) {

  //Check API version
  if ($_REQUEST['version'] != 1) {
    xmlrpc_error(-32601, t('Server error. Requested method version (@version) not specified.', array("@version" => $_REQUEST['version'])));
    return FALSE;
  }    

  $auth['key'] = db_select('logger_devices', 'd')
    ->fields('d', array('sha'))
    ->condition('device', $auth['device'])
    ->execute()
    ->fetchField();

  $hash = hash_hmac('sha1', $auth['timestamp'] . ':' . logger_serialise($message) . ':' . $auth['key'], $auth['key']);

  if ($auth['signature'] == $hash && $auth['timestamp'] > REQUEST_TIME - 300) {
    return TRUE;
  }
  else {
    watchdog('logger.auth', 'HMAC-SHA1 authentication failed for device: %device', array('%device' => $auth['device']), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Converts an array into a string.
 * 
 * @param data The data to be serialized.
 * @return the resulting string.
 */
function logger_serialise($data) {

  if (is_array($data)) {

    $sequence = '';
    foreach ($data as $key => $value) {
      $sequence .= (string) $key . logger_serialise($value);
    }
    return $sequence;
  }
  else {
    return (string) $data;
  }
}
