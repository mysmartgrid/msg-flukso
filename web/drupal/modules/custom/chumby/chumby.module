<?php

/**
 * @file
 * This module provides personalized images to update the chumby.
 *
 * Copyright (c) 2010 Fraunhofer Institut ITWM (www.itwm.fraunhofer.de)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

define('CHUMBY_REL_PATH', drupal_get_path('module', 'chumby'));
define('CHUMBY_PATH', DRUPAL_ROOT . '/' . CHUMBY_REL_PATH);


function chumby_permission() {
  return array(
    'chumby image' => array(
      'title' => t('chumby image'),
      'description' => t('Generate chumby image.'),
    ),
  );
}

function chumby_settings_access($permission, $account) {
  return ($account->uid == $GLOBALS['user']->uid && user_access($permission));
}

function chumby_menu() {

  $items['chumby'] = array(
    'title' => "Download chumby image",
    'description' => 'Shows the chumby image page.',
    'page callback' => 'chumby_image_page',
    'page arguments' => array(1),
    'access arguments' => array('chumby image'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Builds the chumby image page.
 * @param $filename  The image file name.
 * @param $sensor    The sensor function name.
 * @return the chumby image page.
 */
function chumby_image_page($filename = NULL) {

  $form = drupal_get_form('chumby_image_form');
  $output = drupal_render($form);
 
  if ($filename) {
 
    $lines = array(
      array(
        'time' => date('d-m-Y H:i'),
        'file' => "$filename.zip",
        'operations' => l(t('Download'), CHUMBY_REL_PATH . "/files/$filename.zip"))
    );

    $headers = array(t('Generation Time'), t('Image File'), t('Operations'));
    $output .= theme_table(array('header' => $headers, 'rows' => $lines, '', 'attributes' => array(),
      'caption' => '', 'colgroups' => array(), 'sticky' => FALSE, 'empty' => ''));
  }
  return $output;
}

function chumby_image_form($form, &$form_state) {

  global $user;

  $sql = 'SELECT meter, function FROM {logger_meters} WHERE uid = :uid AND function IS NOT NULL';
  $result = db_query($sql, array(':uid' => $user->uid));

  $sensors = array();
  foreach ($result as $flukso) {
    $sensors[$flukso->meter] = $flukso->function;
  }

  $form['visualization'] = array(
    '#type' => 'checkboxes',
    '#options' => array(
      'text' => t('currentpower'),
      'tacho' => t('energietacho'),
      'lightbulb' => t('Gluehlampe'),
      'graph' => t('EnergyGraph'),
    ),
    '#title' => t('Visualizations'),
    '#description' => t('Visualizations that should be available'),
  );

  $form['sensor'] = array(
    '#type' => 'select',
    '#options' => $sensors,
    '#title' => t('Sensor'),
    '#description' => t('Sensors from which values should be displayed.'),
  );

  $form['auto'] = array(
    '#type' => 'checkbox',
    '#title' => t('Autoconfigure IP'),
    '#description' => t('Automatically find the flukso in the local network. Normally this is the way you want to go.'),
    '#default_value' => '1',
    '#attributes' => array('onChange' => 'document.getElementById("edit-ip").disabled = document.getElementById("edit-auto").checked'),
  );

  $form['ip'] = array(
    '#type' => 'textfield',
    '#title' => t('ip address'),
    '#description' => t('The local ip address of the flukso.'),
    '#disabled' => TRUE,
  );

  $form['consumption'] = array(
    '#type' => 'fieldset',
    '#title' => t('consumption'),
    '#description' => t('average borders for high, normal and low energy consumption in Watt'),
    '#collapsable' => TRUE,
    '#collapsed' => FALSE,
  );

  $form['consumption']['low'] = array(
    '#type' => 'textfield',
    '#title' => t('low'),
    '#default_value' => '200',
  );

  $form['consumption']['normal'] = array(
    '#type' => 'textfield',
    '#title' => t('normal'),
    '#default_value' => '500',
  );

  $form['consumption']['high'] = array(
    '#type' => 'textfield',
    '#title' => t('high'),
    '#default_value' => '1500',
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t("Submit"),
  );
  return $form;
}

function chumby_image_form_validate($form, &$form_state) {

  // check if any visualization is selected.
  $temp = TRUE;
  foreach ( $form_state['values']['visualization'] as $value ) {
    $temp &= ($value == '0');
  }

  if ($temp) {
    form_set_error('visualization', t('Please choose at least one visualization.'));
  }

  if (!$form_state['values']['auto']) {
    // check if a valid ip address was entered.
    if (filter_var($form_state['values']['ip'], FILTER_VALIDATE_IP) == FALSE) {
      form_set_error('ip', t('Please enter a valid IP address.'));
    }
  }

  // check if a valid number was entered as low value.
  if ($form_state['values']['low'] == "" || filter_var($form_state['values']['low']) == FALSE) {
    form_set_error('low', t('Please enter a number value.'));
  }

  // check if a valid number was entered as normal value and if the normal value is larger than the low value.
  if ($form_state['values']['normal'] == "" || filter_var($form_state['values']['normal']) == FALSE) {
    form_set_error('normal', t('Please enter a number value.'));
  }
  elseif ($form_state['values']['normal'] < $form_state['values']['low']) {
    form_set_error('normal', t('The normal value should be higher than the low value.'));
  }

  // check if a valid number was entered as high value and if the high value is larger than the normal value.
  if ($form_state['values']['high'] == "" || filter_var($form_state['values']['high']) == FALSE) {
    form_set_error('high', t('Please enter a number value.'));
  }
  elseif ($form_state['values']['high'] < $form_state['values']['normal']) {
    form_set_error('normal', t('The high value should be higher than the normal value.'));
  }
}

function chumby_image_form_submit($form, &$form_state) {

  $image_id = md5(uniqid(rand(), TRUE));
  $tmp_path = CHUMBY_PATH . "/tmp/$image_id";
  $success = FALSE;

  if (!file_exists($tmp_path)) {

    mkdir($tmp_path, 0777, TRUE);

    $success =
      rcopy(CHUMBY_PATH . '/template', $tmp_path) &&

      chumby_create_daemonconfig($form_state['values'], $tmp_path) &&

      chumby_create_profile($form_state['values']['visualization'], $tmp_path) &&

      rzip($tmp_path, CHUMBY_PATH . "/files/$image_id.zip");

    rrmdir($tmp_path);
  }

  $form_state['redirect'] = "chumby/$image_id" ;

  if (!$success) {
    drupal_set_message(t("Operation failed! Please try again later!"));
  }
}

/**
 * Creates a lua deamon config file.
 *
 * @param $values    Daemon configuration properties.
 * @param $tmp_path  The directory where the daemonconfig file will be created.
 * @return  TRUE on success, FALSE on failure.
 */
function chumby_create_daemonconfig($values, $tmp_path) {

  $ip = isset($values['auto']) ? '' : $values['ip'];
  $low = $values['low'];
  $mid = $values['normal'];
  $high = $values['high'];

  $sensor = $values['sensor'];
  $token = db_query("SELECT token FROM {logger_tokens} WHERE meter = :meter", array(':meter' => $sensor))->fetchField();

  $daemonconfig = fopen($tmp_path . '/daemonconfig.lua', 'w');
  if ($daemonconfig) {

    require CHUMBY_PATH . '/daemonconfig.php';

    fwrite($daemonconfig, $config);
    fclose($daemonconfig);
    return TRUE;
  }
  return FALSE;
}

/**
 * Creates a chumby image profile.
 *
 * @param $widgets   The array of selected widgets.
 * @param $tmp_path  The directory where the profile file will be created.
 * @return  TRUE on success, FALSE on failure.
 */
function chumby_create_profile($widgets, $tmp_path) {

  $profile = fopen($tmp_path . '/profile.xml', 'w');
  if ($profile) {

    require CHUMBY_PATH . '/profile-head.php';
    fwrite($profile, $profile_head);

    foreach ($widgets as $key => $value) {

      if ($value != '0') {

        require CHUMBY_PATH . "/$key" . '_widget.php';
        fwrite($profile, $widget);
      }
    }

    require CHUMBY_PATH . '/' . 'profile-tail.php';
    fwrite($profile, $profile_tail);
    fclose($profile);
    return TRUE;
  }
  return FALSE;
}

/**
 * Copies a file or directory recursively.
 *
 * @param   $source       The source path
 * @param   $destination  The destination path
 * @return  TRUE on success, FALSE on failure.
 */
function rcopy($source, $destination) {
  
  //TODO: move this function to a library.

  if (is_link($source)) {
    return symlink(readlink($source), $destination);
  }
  if (is_file($source)) {
    return copy($source, $destination);
  }
  if (!is_dir($destination)) {
    mkdir($destination);
  }
 
  $dir = dir($source);
  while (false !== $entry = $dir->read()) {
    if ($entry == '.' || $entry == '..') {
      continue;
    }
    rcopy("$source/$entry", "$destination/$entry");
  }
  $dir->close();
  return TRUE;
}

/**
 * Removes a directory recursively.
 *
 * @param $dir The directory to be removed.
 */
function rrmdir($dir) {

  //TODO: move this function to a library.

  if (is_dir($dir)) {
    $objects = scandir($dir);
    foreach ($objects as $object) {
      if ($object != "." && $object != "..") {
        if (filetype($dir."/".$object) == "dir") 
          rrmdir($dir."/".$object);
        else
          unlink($dir."/".$object);
      }
    }
    reset($objects);
    rmdir($dir);
  }
} 

/**
 * Compresses files and directories into a zip file recursively.
 *
 * @param $source  The files to be compressed.
 * @destination    The zip file location.
 * @return TRUE on success, FALSE on failure.
 */
function rzip($source, $destination) {

  //TODO: move this function to a library.

  if (!extension_loaded('zip') || !file_exists($source)) {
    return FALSE;
  }

  $zip = new ZipArchive();
  if (!$zip->open($destination, ZIPARCHIVE::CREATE)) {
    return FALSE;
  }

  $source = str_replace('\\', '/', realpath($source));

  if (is_dir($source) === TRUE) {
    $files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($source), RecursiveIteratorIterator::SELF_FIRST);

    foreach ($files as $file) {
        $file = str_replace('\\', '/', realpath($file));

        if (is_dir($file) === TRUE) {
          $dir = str_replace($source . '/', '', $file . '/');

          //FIXME: remove this test
          if (strpos($dir, '/') > 0) {
            $zip->addEmptyDir($dir);
          }
        }
        else if (is_file($file) === TRUE) {
          $zip->addFromString(str_replace($source . '/', '', $file), file_get_contents($file));
        }
    }
  }
  else if (is_file($source) === TRUE) {
    $zip->addFromString(basename($source), file_get_contents($source));
  }
  return $zip->close();
}

function chumby_cron() {
   $mask = "/files/*.zip";
   array_map("unlink", glob($mask));
}
