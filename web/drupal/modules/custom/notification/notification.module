<?php

/**
 * @file
 * This module manages Flukso devices' event notifications.
 *
 * Copyright (c) 2010 Fraunhofer Institut ITWM (www.itwm.fraunhofer.de)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//DEBUG
error_reporting(E_ALL);
ini_set('display_errors', TRUE);
ini_set('display_startup_errors', TRUE);

//Constants
define('NO_COMMUNICATION_EVENT_ID',        1);
define('COMMUNICATION_RESTORED_EVENT_ID',  3);
define('PEAK_CONSUMPTION_EVENT_ID',        4);

define('SUMMARY_REPORT_EVENT_ID',          10);
define('FORECAST_REPORT_EVENT_ID',         11);
define('SYSTEM_ERROR_EVENT_ID',            999);

//Message events
define('MESSAGE_RECEIVED_EVENT_ID',         100);
define('HEARTBEAT_RECEIVED_EVENT_ID',       101);
define('MEASUREMENT_RECEIVED_EVENT_ID',     102);
define('CORRUPTED_MESSAGE_EVENT_ID',        103);
define('BROWNOUT_EVENT_ID',                 104);
define('FIRMWARE_UPGRADED_EVENT_ID',        105);
define('FAILED_FIRMWARE_UPGRADE_EVENT_ID',  106);

//Anomalies
define('PRODUCTION_ANOMALY_EVENT_ID',       202);

define('NOTIFICATION_REL_PATH', drupal_get_path('module', 'notification'));
define('NOTIFICATION_PATH', DRUPAL_ROOT . '/' . NOTIFICATION_REL_PATH);

define('NOTIFICATION_TIMESTAMP_FORMAT', 'd-m-Y H:i');


function notification_init() {
  drupal_add_js(NOTIFICATION_REL_PATH . '/js/notification.js');
}

function notification_permission() {
  return array(
    'list event notifications' => array(
      'title' => t('list event notifications'),
      'description' => t('Access the event notifications list page.'),
    ),
    'view event notifications' => array(
      'title' => t('view event notifications'),
      'description' => t('Access the event notification edition page.'),
    ),
    'save event notifications' => array(
      'title' => t('save event notifications'),
      'description' => t('Either edit or save an event notification.'),
    ),
    'delete event notifications' => array(
      'title' => t('delete event notifications'),
      'description' => t('Delete an event notification.'),
    ),
    'list event logs' => array(
      'title' => t('list event logs'),
      'description' => t('Access the device event logs page.'),
    ),
    'delete event logs' => array(
      'title' => t('delete event logs'),
      'description' => t('Delete device event log entries.'),
    ),
  );
}

function notification_settings_access($permission, $account) {
  return ($account->uid == $GLOBALS['user']->uid && user_access($permission));
}

/**
 * Access callback ensuring the notification is accessible only to the device owner.
 */
function notification_device_access($permission, $device) {

  $rid = get_role_id('Techniker');
  if (!empty($GLOBALS['user']->roles[$rid])) {
    return TRUE;
  }

  $uid = db_select('logger_devices', 'd')
    ->fields('d', array('uid'))
    ->condition('d.device', "$device", '=')
    ->execute()
    ->fetchField();

  return $uid == $GLOBALS['user']->uid && user_access($permission);
}

function notification_menu() {

  $items['notification/list'] = array(
    'title' => 'Event Notifications',
    'page callback' => 'notification_list_page',
    'access arguments' => array('list event notifications'),
    'type' => MENU_NORMAL_ITEM
  );

  $items['notification/delete'] = array(
    'title' => $items['notification/list']['title'],
    'page callback' => 'notification_remove',
    'page arguments' => array(2, 3, 4, 5),
    'access callback' => 'notification_device_access',
    'access arguments' => array('delete event notifications', 2),
    'type' => MENU_CALLBACK
  );

  $items['notification/register'] = array(
    'title' => 'Event Notification Registration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notification_registration_form'),
    'access arguments' => array('view event notifications'),
    'type' => MENU_CALLBACK
  );

  $items['notification/edit'] = array(
    'title' => 'Event Notification Edition',
    'page callback' => 'notification_edition_page',
    'page arguments' => array(2, 3, 4, 5),
    'access callback' => 'notification_device_access',
    'access arguments' => array('view event notifications', 2),
    'type' => MENU_CALLBACK
  );

  $items['event/log/list'] = array(
    'title' => 'Device History',
    'page callback' => 'notification_eventlog_page',
    'page arguments' => array(3),
    'access callback' => 'notification_device_access',
    'access arguments' => array('list event logs', 3),
    'type' => MENU_CALLBACK
  );

  $items['event/log/clear'] = array(
    'title' => $items['event/log/list']['title'],
    'page callback' => 'notification_eventlog_clear',
    'page arguments' => array(3),
    'access callback' => 'notification_device_access',
    'access arguments' => array('delete event logs', 3),
    'type' => MENU_CALLBACK
  );

  $items['newsletter'] = array(
    'title' => 'Newsletter',
    'page callback' => 'notification_newsletter_page',
    'access callback' => TRUE,
    'type' => MENU_NORMAL_ITEM
  );
  return $items;
}

/**
 * Event notification deletion callback.
 *
 * @param $device    The monitored device.
 * @param $event_id  The event id.
 * @param $limit_up  The event's threshold.
 * @param $unit_id   The unit id.
 * @return the events list page.
 */
function notification_remove($device, $event_id, $limit_up, $unit_id) {

  notification_delete($device, $event_id, $limit_up, $unit_id);
  return notification_list_page();
}

/**
 * Removes all notifications and event log entries related to a device.
 * FIXME: use a hook
 * 
 * @param $device The device id.
 */
function notification_remove_by_device($device) {

  db_delete('event_log')
    ->condition('device', $device)
    ->execute();

  db_delete('notification')
    ->condition('device', $device)
    ->execute();
}

/**
 * Builds the event notification edition page.
 *
 * @param $device    The monitored device.
 * @param $event_id  The event id.
 * @param $limit_up  The event's threshold.
 * @param $unit_id   The unit id.
 * @return the event notification edition page.
 */
function notification_edition_page($device, $event_id, $limit_up, $unit_id) {

  $sql = "
    SELECT
      e.id AS event_id,
      e.name AS event_name,
      n.device,
      d.serial,
      n.emails,
      n.min_interval,
      n.limit_up,
      n.unit_id
    FROM
      {event} e,
      {notification} n,
      {logger_devices} d
    WHERE
      d.device = :device AND
      d.device = n.device AND
      n.event_id = e.id AND
      e.id = :event_id AND
      n.limit_up = :limit_up AND
      n.unit_id = :unit_id";

  $notification = db_query($sql, array(':device' => $device, ':event_id' => $event_id, ':limit_up' => $limit_up, ':unit_id' => $unit_id))->fetchObject();

  $form = drupal_get_form('notification_edition_form', $notification);

  return drupal_render($form);
}

/**
 * Builds the events list page.
 *
 * @return the events list page.
 */
function notification_list_page() {

  global $user;

  $query = db_select('logger_devices', 'd')
    ->fields('d', array('serial', 'device'))
    ->condition('d.uid', $user->uid, '=');

  $query->join('notification', 'n', 'n.device = d.device');
  $query->join('users', 'u', 'u.uid = d.uid');
  $query->join('event', 'e', 'e.id = n.event_id');
  $query->join('unit', 'un', 'un.id = n.unit_id');

  $query->addField('e', 'name', 'event_name');
  $query->addField('n', 'emails');
  $query->addField('n', 'last_sent');
  $query->addField('n', 'limit_up');
  $query->addField('un', 'id', 'unit_id');
  $query->addField('un', 'symbol', 'unit');
  $query->addField('e', 'id', 'event_id');

  $header = array(
    array(
      'data' => t('Device'),
      'field' => 'serial',
      'sort' => 'ASC',
    ),
    array(
      'data' => t('Event'),
      'field' => 'event_name',
    ),
    array(
      'data' => t('Sent'),
      'field' => 'last_sent',
    ),
    array(
      'data' => t('Target e-mails'),
      'field' => 'emails',
    ),
    array('data' => t('Operation')),
  );

  $query->extend('TableSort')->orderByHeader($header);

  $result = $query->execute();

  $rows = array();
  foreach ($result as $object) {

    $event_name = t($object->event_name) . ($object->unit_id == 0 ? '' :
      '<br>(' . $object->limit_up . ' ' . t($object->unit) . ')');

    $id = $object->device . '/' . $object->event_id . '/' . $object->limit_up . '/' . $object->unit_id;

    $emails = implode("<br>", tokenize_string($object->emails));

    $row = array();
    $row['serial'] = $object->serial;
    $row['event_name'] = $event_name;
    $row['last_sent'] = $object->last_sent > 0 ? date(NOTIFICATION_TIMESTAMP_FORMAT, $object->last_sent) : NULL;
    $row['emails'] = $emails;
    $row[] = l(t('Remove'), "notification/delete/$id") . '<br>' .
             l(t('Edit'),   "notification/edit/$id");

    $rows[] = $row;
  }

  $table_id = 'notification-list-table';
  $handler = "function() { resizeLegend('$table_id'); }";
  drupal_add_js("$(window).resize( $handler );", array('type' => 'inline', 'scope' => JS_DEFAULT));
  drupal_add_js("$(document).ready(  $handler );", array('type' => 'inline', 'scope' => JS_DEFAULT));

  $caption = '<p>' . l(t('Register Notification'), 'notification/register') . '<br><br></p>';

  return theme_table(array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => $table_id, 'class' => 'resizable'),
    'caption' => $caption, 'empty' => '', 'sticky' => FALSE, 'colgroups' => array()));
}

/**
 * Builds the event log page.
 *
 * @param $device  The device id.
 * @return the event log page.
 */
function notification_eventlog_page($device) {

  $serial = db_select('logger_devices', 'd')
    ->fields('d', array('serial'))
    ->condition('d.device', $device, '=')
    ->execute()
    ->fetchField();

  $query = db_select('event_log', 'l')
    ->fields('l', array('time'))
    ->condition('l.device', $device, '=')
    ->orderBy('l.time', 'DESC');
  $query->join('event', 'e', 'e.id = l.event_id');
  $query->addField('e', 'name');

  $entries = $query->execute();

  $rows = array();
  foreach ($entries as $entry) {
    $rows[] = array(
      'time' => date(NOTIFICATION_TIMESTAMP_FORMAT, $entry->time),
      'name' => t($entry->name)
    );
  }

  $header = array(
    array('data' => t('Time')),
    array('data' => t('Event')),
  );

  $caption = '<p>' . t('Serial Number') . ": $serial</p><p>" .
    l(t('Clear'), "event/log/clear/$device") . '</p>';

  return theme_table(array('header' => $header, 'rows' => $rows, 'attributes' => array(), 'caption' => $caption,
    'colgroups' => array(), 'sticky' => TRUE, 'empty' => '')) .

    theme_pager(array('tags' => NULL, 'element' => 0, 'parameters' => array(), 'quantity' => 100));
}

/**
 * Processes the event log deletion request.
 *
 * @param $device The device id.
 * @return the event log page.
 */
function notification_eventlog_clear($device) {

  db_delete('event_log')
    ->condition('device', $device)
    ->execute();

  return notification_eventlog_page($device);
}

/**
 * Removes log entries older than 3 days since last device event.
 */
function notification_eventlog_clear_old() {

  $query = db_select('event_log', 'l')
    ->fields('l', array('device'))
    ->groupBy('l.device');
  $query->addExpression('MAX(l.time)', 'last_time');

  $logs = $query->execute();  

  foreach ($logs as $log) {

    db_delete('event_log')
      ->condition('device', $log->device, '=')
      ->condition('time', $log->last_time - 3 * DAY, '<')
      ->execute();
  }
}

/**
 * Logs the "brownout" event.
 *
 * @param $device  The device where the event occurred.
 */
function notification_log_brownout($device) {

  notification_log_event(BROWNOUT_EVENT_ID, $device);
}

/**
 * Logs the "heartbeat received" event.
 *
 * @param $device  The device where the event occurred.
 */
function notification_log_heartbeat_received($device) {

  notification_log_event(HEARTBEAT_RECEIVED_EVENT_ID, $device);
}

/**
 * Logs the "measurement received" event.
 *
 * @param $device  The device where the event occurred.
 */
function notification_log_measurement_received($device) {

  notification_log_event(MEASUREMENT_RECEIVED_EVENT_ID, $device);
}

/**
 * Logs the "corrupted message" event.
 *
 * @param $device  The device where the event occurred.
 */
function notification_log_corrupted_message($device) {

  notification_log_event(CORRUPTED_MESSAGE_EVENT_ID, $device);
}

/**
 * Logs an event.
 *
 * @param $event_id  The event id.
 * @param $device    The device where the event occurred.
 */
function notification_log_event($event_id, $device) {

  db_insert('event_log')
    ->fields(array(
      'device' => $device,
      'event_id' => $event_id,
      'time' => REQUEST_TIME,
    ))
    ->execute();
}

/**
 * Builds the newsletter registration page.
 *
 * @return the newsletter registration page.
 */
function notification_newsletter_page() {

  $output = '<div><p>' .
    t('We would also like to keep up to date via email. Please use the form below to sign up for our newsletter.') .
    '<br><br></p></div>';

  $form = drupal_get_form('notification_newsletter_form');
  $output .= drupal_render($form);

  $output .= '<div><p><br><br><br>' .
    t('Of course, we do not share this information with anyone at any given time. If you want to unsubscribe, please click the appropriate link found at the end of each newsletter.') .
    '</p></div>';

  $output .= '<div><p><br>' .
    t('Latest publications:');

  $sql = '
    SELECT
      n.nid
    FROM
      {node} n,
      {users} u,
      {users_roles} ur
    WHERE
      n.type = :type AND
      n.title LIKE :title AND
      n.uid = u.uid AND
      u.uid = ur.uid AND
      ur.rid = :uid
    ORDER BY
      n.created DESC';

  $results = db_query_range($sql, 0, 3,
    array(':type' => "blogpost", ':title' => "Newsletter %/%", ':uid' => 8)); //Posted by a Blogger

  foreach ($results as $result) {

    $blog = node_load($result->nid);
    $output .= '&nbsp;&nbsp;&nbsp;' . l($blog->title, 'node/' . $blog->nid);
  }
  $output .= '</p></div>';

  return $output;
}

function notification_registration_form($form, &$form_state) {

  global $user;

  $form['device'] = array(
    '#type' => 'select',
    '#title' => t('Serial Number'),
    '#description' => t('Select the serial number of the monitored device.'),
    '#options' => logger_get_devices_options(),
  );

  $form['emails'] = array(
    '#type' => 'textarea',
    '#title' => t('E-mails'),
    '#description' => t('Enter the e-mails to which the notification will be sent. The emails must be specified either in multiple lines or separated by space.'),
    '#rows' => 3,
    '#resizable' => FALSE,
    '#default_value' => $user->mail,
    '#element_validate' => array('notification_emails_validate'),
  );

  $form['events'] = array(
    '#type' => 'fieldset',
    '#title' => t('Events'),
    '#prefix' => '<br><table width="100%">',
    '#suffix' => '</table>',
  );

  $form['events'] += notification_create_event_fields(NO_COMMUNICATION_EVENT_ID, 2, HOUR_UNIT_ID,
    'Here you can set the maximum message delay. Beyond this limit, the device is considered faulty.');

  $form['events'] += notification_create_event_fields(COMMUNICATION_RESTORED_EVENT_ID, 2, HOUR_UNIT_ID,
    'Here you can set the maximum period of time acceptable for a device to be offline. Beyond this limit, when the first message is received, the communication is considered reestablished.');

  $form['events'] += notification_create_event_fields(CORRUPTED_MESSAGE_EVENT_ID, NULL, NULL,
    'A message containing invalid data, produced when the device is malfunctioning or not properly installed.');

  $form['events'] += notification_create_event_fields(PEAK_CONSUMPTION_EVENT_ID, 5000, WATT_UNIT_ID,
    'Here you can set the maximum electricity consumption. Beyond this limit, the device is considered faulty.');

  $form['events'] += notification_create_event_fields(SUMMARY_REPORT_EVENT_ID, 1, WEEK_UNIT_ID,
    'Here you can set the period of time in which you want to receive summary reports.');

  if (user_has_role('PV Producer')) {

    $form['events'] += notification_create_event_fields(FORECAST_REPORT_EVENT_ID, 1, DAY_UNIT_ID,
      'Here you can set the period of time in which you want to receive energy production forecast reports.');

    $form['events'] += notification_create_event_fields(PRODUCTION_ANOMALY_EVENT_ID, NULL, NULL,
      'An anomalous series of measurements, produced when the PV plant is malfunctioning or not properly installed.');
  }

  $form['min_interval'] = array(
    '#type' => 'select',
    '#title' => t('Amount of Notifications'),
    '#description' => t('How often do you want to receive notifications, when the same event occurs several times consecutively?'),
    '#default_value' => 0,
    '#required' => TRUE,
    '#options' => notification_get_frequency_options(),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );
  return $form;
}

/**
 * Creates the group of fields used to specify properties of an event.
 * 
 * @param $event_id              The event id.
 * @param $default_limit_up      The default limit up.
 * @param $default_unit_id       The default unit id.
 * @param $limit_up_description  The limit up description.
 * @return the array of fields. 
 */
function notification_create_event_fields($event_id, $default_limit_up, $default_unit_id, $limit_up_description) {

  $fields = array();
  $fields["event_id$event_id"] = array(
    '#title' => check_plain(notification_get_event_name($event_id)),
    '#type' => 'checkbox',
    '#default_value' => FALSE,
    '#prefix' => '<tr><td>',
    '#suffix' => '</td>'
  );

  if ($default_unit_id) {

    $fields["event_id$event_id"]['#attributes'] = array(
      'onchange' => "selectEvent($event_id, $default_limit_up, $default_unit_id, this)"
    );

    $fields["limit_up$event_id"] = array(
      '#type' => 'textfield',
      '#theme' => 'notification_event_limit_up',
      '#description' => t($limit_up_description),
      '#maxlength' => 9,
      '#size' => 12,
      '#prefix' => '<td>',
      '#suffix' => '</td></tr>',
      '#related_event_id' => $event_id,
      '#unit_id' => $default_unit_id,
      '#unit_options' => notification_get_units_options($event_id),
      '#element_validate' => array('notification_limit_up_validate'),
      '#attributes' => array('onfocus' => "changeLimitUp($event_id, this)")
    );
  }
  else {
    $fields["eventdesc$event_id"] = array(
      '#type' => 'markup',
      '#markup' => t($limit_up_description),
      '#prefix' => '<td><div class="form-item"><div class="description">',
      '#suffix' => '</div></div></td></tr>'
    );
  }
  return $fields;
}

function notification_edition_form($form, &$form_state, $notification) {

  $form['device'] = array(
    '#type' => 'hidden',
    '#required' => TRUE,
    '#default_value' => $notification->device,
  );

  $form['event_id'] = array(
    '#type' => 'hidden',
    '#default_value' => $notification->event_id,
  );

  $form['old_limit_up'] = array(
    '#type' => 'hidden',
    '#default_value' => $notification->limit_up,
  );

  $form['old_unit_id'] = array(
    '#type' => 'hidden',
    '#default_value' => $notification->unit_id,
  );

  $form['event_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Event'),
    '#required' => TRUE,
    '#default_value' => t($notification->event_name),
    '#attributes' => array('readOnly' => 'true'),
  );

  $form['serial'] = array(
    '#type' => 'textfield',
    '#title' => t('Serial Number'),
    '#required' => TRUE,
    '#default_value' => $notification->serial,
    '#attributes' => array('readOnly' => 'true'),
  );

  $form['emails'] = array(
    '#type' => 'textarea',
    '#title' => t('E-mails'),
    '#description' => t('Enter the e-mails to which the notification will be sent. The emails must be specified either in multiple lines or separated by space.'),
    '#rows' => 3,
    '#resizable' => FALSE,
    '#required' => TRUE,
    '#default_value' => $notification->emails,
    '#element_validate' => array('notification_emails_validate'),
  );

  $form['limit_up'] = array(
    '#type' => 'textfield',
    '#theme' => 'notification_event_limit_up',
    '#required' => TRUE,
    '#maxlength' => 9,
    '#size' => 12,
    '#prefix' => '<table border="0"><tr><td>',
    '#suffix' => '</td></tr></table>',
    '#default_value' => $notification->limit_up,
    '#unit_id' => $notification->unit_id,
    '#unit_options' => notification_get_units_options($notification->event_id),
    '#element_validate' => array('notification_limit_up_validate'),
  );

  switch ($notification->event_id) {
    case NO_COMMUNICATION_EVENT_ID:
      $form['limit_up']['#title'] = t('Maximum Delay');
      $form['limit_up']['#description'] = t('Here you can set the maximum message delay. Beyond this limit, the device is considered faulty.');
      break;

    case COMMUNICATION_RESTORED_EVENT_ID:
      $form['limit_up']['#title'] = t('Maximum Delay');
      $form['limit_up']['#description'] = t('Here you can set the maximum period of time acceptable for a device to be offline. Beyond this limit, when the first message is received, the communication is considered reestablished.');
      break;

    case PEAK_CONSUMPTION_EVENT_ID:
      $form['limit_up']['#title'] = t('Maximum Consumption');
      $form['limit_up']['#description'] = t('Here you can set the maximum electricity consumption. Beyond this limit, the device is considered faulty.');
      break;

    case SUMMARY_REPORT_EVENT_ID:
      $form['limit_up']['#title'] = t('Frequency');
      $form['limit_up']['#description'] = t('Here you can set the period of time in which you want to receive summary reports.');
      break;

    case FORECAST_REPORT_EVENT_ID:
      $form['limit_up']['#title'] = t('Frequency');
      $form['limit_up']['#description'] = t('Here you can set the period of time in which you want to receive forecast reports.');
      break;
      
    default:
      unset($form['limit_up']);
  }

  $form['min_interval'] = array(
    '#type' => 'select',
    '#title' => t('Amount of Notifications'),
    '#description' => t('How often do you want to receive notifications, when the same event occurs several times consecutively?'),
    '#required' => TRUE,
    '#options' => notification_get_frequency_options(),
    '#default_value' => $notification->min_interval,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );
  return $form;
}

function notification_newsletter_form($form) {

  $form['email'] = array(
    '#type' => 'textfield',
    '#title' => t('E-mail'),
    '#description' => t('Enter your e-mail.'),
    '#maxlength' => 64,
    '#size' => 20,
    '#required' => 1,
    '#element_validate' => array('notification_email_validate'),
  );

  $form['firstname'] = array(
    '#type' => 'textfield',
    '#title' => t('First Name'),
    '#description' => t('Enter your first name.'),
    '#maxlength' => 20,
    '#required' => 1,
    '#size' => 20,
  );

  $form['lastname'] = array(
    '#type' => 'textfield',
    '#title' => t('Last Name'),
    '#description' => t('Enter your last name.'),
    '#maxlength' => 20,
    '#required' => 1,
    '#size' => 20,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t("Subscribe"),
  );
  return $form;
}

function notification_email_validate($field, $form_state) {
  if (!valid_email_address($form_state['values']['email'])) {
    form_error($field, t('Invalid e-mail address.'));
  }
}

function notification_emails_validate($field, $form_state) {

  $emails = tokenize_string($form_state['values']['emails']);

  if (count($emails) > 10) {
    form_error($field, t('Inform at most 10 e-mails.'));
  }

  foreach ($emails as $email) {
    if (!valid_email_address($email)) {

      form_error($field, t('Invalid e-mail address.'));
      return;
    }
  }
}

function notification_limit_up_validate($field, $form_state) {

  //Check if it has just one field event_id, or multiple
  $event_id = isset($_REQUEST["event_id"]) ? $_REQUEST["event_id"] : NULL;
  $related_event_id = '';
 
  if (!$event_id) {
    $related_event_id = $field['#related_event_id'];
    $event_id = $related_event_id;
  }

  //If selected
  if (isset($_REQUEST["event_id$related_event_id"])) {

    $limit_up = $_REQUEST["limit_up$related_event_id"];
    $unit_id = $_REQUEST["unit_id$related_event_id"];

    $factor = db_select('unit', 'u')
      ->fields('u', array('factor'))
      ->condition('u.id', $unit_id, '=')
      ->execute()
      ->fetchField();

    $converted_limit = $limit_up * $factor;

    system("echo $event_id >> /tmp/test.txt");
    if (($event_id == NO_COMMUNICATION_EVENT_ID || $event_id == COMMUNICATION_RESTORED_EVENT_ID) && $converted_limit < 30 * MINUTE) {

      form_error($field, t('Delay time can not be less than 30 minutes.'));
    }
    elseif ($event_id == PEAK_CONSUMPTION_EVENT_ID && $converted_limit <= 0) {

      form_error($field, t('Peak consumption can not be lesser than 0 watt / min.'));
    }
    elseif ($event_id == SUMMARY_REPORT_EVENT_ID && $converted_limit < DAY) {

      form_error($field, t('The minimum period for the summary report is 1 day.'));
    }
    elseif ($event_id == FORECAST_REPORT_EVENT_ID && ($converted_limit > 3 * DAY || $converted_limit < DAY)) {

      form_error($field, t('The period for the forecast report must be between 1 and 3 days.'));
    }
  }
}

function notification_registration_form_validate($form, &$form_state) {

  if (!user_access('save event notifications')) {
    form_set_error('', t('Operation not allowed.'));
  }
}

function notification_edition_form_validate($form, &$form_state) {
  notification_registration_form_validate($form, $form_state);
}

function notification_registration_form_submit($form, &$form_state) {

  notification_register_event($_REQUEST, NO_COMMUNICATION_EVENT_ID);
  notification_register_event($_REQUEST, CORRUPTED_MESSAGE_EVENT_ID);
  notification_register_event($_REQUEST, COMMUNICATION_RESTORED_EVENT_ID);
  notification_register_event($_REQUEST, PEAK_CONSUMPTION_EVENT_ID);
  notification_register_event($_REQUEST, SUMMARY_REPORT_EVENT_ID);
  notification_register_event($_REQUEST, FORECAST_REPORT_EVENT_ID);
  notification_register_event($_REQUEST, PRODUCTION_ANOMALY_EVENT_ID);

  $form_state['redirect'] = 'notification/list';
}

function notification_edition_form_submit($form, &$form_state) {

  notification_edit_event($_REQUEST);
  $form_state['redirect'] = 'notification/list';
}

function notification_newsletter_form_submit($form, &$form_state) {

  $email     = $form_state['values']['email'];
  $firstname = $form_state['values']['firstname'];
  $lastname  = $form_state['values']['lastname'];

  $url = 'http://www.eor.de/fileadmin/verwaltung/mysmartgrid.php' .
    '?email=' . urlencode($email) .
    '&firstname=' . urlencode($firstname) .
    '&surname=' . urlencode($lastname);

  //For testing, uncomment the following line
  //$url .= '&test=1';

  $request = drupal_http_request($url);
  $response = $request->data;

  if ($response == "RECORD_CREATED") {

    drupal_set_message(t('Almost Finished... We need to confirm your email address. To complete the subscription process, please click the link in the email we just sent you.'));
  }
  elseif ($response == "RECORD_UPDATED") {

    drupal_set_message(t('The e-mail address was already present in the database. The user data has been updated.'));
  }
  else {
    drupal_set_message(t('Our apologies. The newsletter subscription is temporarily unavailable. Please, try again later.'));

    notification_send_system_error_email('newsletter', $response, urlencode($url));
  }
}

/**
 * Registers an event notification.
 * 
 * @param $values    the array of field values describing the event notification.
 * @param $event_id  the event id.
 */
function notification_register_event($values, $event_id) {

  $selected = isset($values["event_id$event_id"]) ? $values["event_id$event_id"] : NULL;

  if ($selected) {

    $device = $values['device'];
    $limit_up = isset($values["limit_up$event_id"]) ? $values["limit_up$event_id"] : 0;
    $unit_id = isset($values["unit_id$event_id"]) ? $values["unit_id$event_id"] : 0;

    $emails = $values['emails'];
    $min_interval = $values['min_interval'];
    $values = array('emails' => $emails, 'min_interval' => $min_interval);

    $notification = notification_get($device, $event_id, $limit_up, $unit_id);

    if ($notification) {
      notification_update($device, $event_id, $limit_up, $unit_id, $values);
    }
    else {
      notification_insert($device, $event_id, $emails, $min_interval, $limit_up, $unit_id);
    }
  }
}

/**
 * Updates an event notification.
 * 
 * @param the array of field values describing the new state of the event notification.
 */
function notification_edit_event($values) {

  $device = $values['device'];
  $event_id = $values["event_id"];
  $old_limit_up = $values["old_limit_up"];
  $old_unit_id = $values["old_unit_id"];

  $emails = $values['emails'];
  $limit_up = isset($values["limit_up"]) ? $values["limit_up"] : 0;
  $unit_id = isset($values["unit_id"]) ? $values["unit_id"] : 0;
  $min_interval = $values['min_interval'];
  $values = array(
    'limit_up' => $limit_up,
    'unit_id' => $unit_id,
    'emails' => $emails,
    'min_interval' => $min_interval
  );

  $notification = notification_get($device, $event_id, $limit_up, $unit_id);
  if ($notification && ($old_limit_up != $limit_up || $old_unit_id != $unit_id)) {
    notification_delete($device, $event_id, $limit_up, $unit_id);
  }
  notification_update($device, $event_id, $old_limit_up, $old_unit_id, $values);
}

/**
 * Returns an event name.
 *
 * @param $event_id  The event id.
 * @return the event name.
 */
function notification_get_event_name($event_id) {

  $name = db_select('event', 'e')
    ->fields('e', array('name'))
    ->condition('e.id', $event_id, '=')
    ->execute()
    ->fetchField();

  return t($name);
}

/**
 * Returns an array of units associated with the informed event, indexed by their respective ids.
 * 
 * @param $event_id The event id.
 * @return the array of units.
 */
function notification_get_units_options($event_id) {

  $sql = "
    SELECT
      un.id,
      un.name
    FROM
      {unit} un,
      {event_unit} eu
    WHERE
      eu.event_id = :event_id AND
      eu.unit_id = un.id
    ORDER BY
      un.id";

  $result = db_query($sql, array(':event_id' => $event_id));

  $units = array();
  foreach ($result as $row) {
    $units[$row->id] = t($row->name);
  }
  return $units;
}

/**
 * Returns an array of notification frequencies indexed by their respective
 * time intervals in minutes.
 *
 * @return the array of frequencies.
 */
function notification_get_frequency_options() {
  return array(
    0 => t('No limit, notify every single event'),
    30 * MINUTE => t('2 notifications per hour'),
    1 * HOUR => t('1 notification per hour'),
    12 * HOUR => t('2 notifications per day'),
    1 * DAY => t('1 notification per day'),
  );
}

/**
 * Deletes an event notification.
 *
 * @param $device    The monitored device.
 * @param $event_id  The event id.
 * @param $limit_up  The event's threshold.
 * @param $unit_id   The unit id.
 */
function notification_delete($device, $event_id, $limit_up, $unit_id) {

  db_delete('notification')
    ->condition('device', $device)
    ->condition('event_id', $event_id)
    ->condition('limit_up', $limit_up)
    ->condition('unit_id', $unit_id)
    ->execute();
}

/**
 * Registers an event notification.
 *
 * @param $device        The monitored device.
 * @param $event_id      The event id.
 * @param $emails        The notification e-mail.
 * @param $min_interval  The minimum time interval between consecutive notifications of the same event.
 * @param $limit_up      The event's threshold.
 * @param $unit_id       The unit id.
 */
function notification_insert($device, $event_id, $emails, $min_interval, $limit_up, $unit_id) {

  db_insert('notification')
    ->fields(array(
      'device' => $device,
      'event_id' => $event_id,
      'emails' => $emails,
      'min_interval' => $min_interval,
      'base_time' => REQUEST_TIME,
      'limit_up' => $limit_up,
      'unit_id' => $unit_id,
      'last_sent' => 0
    ))
    ->execute();
}

/**
 * Updates an event notification.
 *
 * @param $device         The monitored device.
 * @param $event_id       The event id.
 * @param $limit_up       The event's threshold.
 * @param $unit_id        The event unit id.
 * @param $field_values   The array of fields and their new values.
 */
function notification_update($device, $event_id, $limit_up, $unit_id, $field_values) {

  db_update('notification')
    ->fields($field_values)
    ->condition('device', $device)
    ->condition('event_id', $event_id)
    ->condition('limit_up', $limit_up)
    ->condition('unit_id', $unit_id)
    ->execute();  
}

/**
 * Gets an event notification.
 *
 * @param $device         The monitored device.
 * @param $event_id       The event id.
 * @param $limit_up       The event's threshold.
 * @param $unit_id        The event unit id.
 * @return the notification, if one was found.
 */
function notification_get($device, $event_id, $limit_up, $unit_id) {
  return db_select('notification', 'n')
    ->fields('n', array('device', 'event_id', 'limit_up', 'unit_id'))
    ->condition('device', $device)
    ->condition('event_id', $event_id)
    ->condition('limit_up', $limit_up)
    ->condition('unit_id', $unit_id)
    ->execute()
    ->fetchObject();
}

function notification_theme() {

  return array(
    'notification_event_limit_up' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Builds the event limit up field.
 * 
 * @param $variables  The theme variables, containing the field element.
 * @return the field HTML code. 
 */
function theme_notification_event_limit_up($variables) {
  $element = $variables['element'];
  $attributes = '';

  //TODO: make this theme more generic
  $event_id = '';
  if (isset($element['#related_event_id'])) {
    $event_id = $element['#related_event_id'];
    $attributes = drupal_attributes(array('onfocus' => "changeLimitUp($event_id, this)"));
  }
  _form_set_class($element, array('form-select'));

  $default_value = isset($element['#default_value']) ? $element['#default_value'] : '';

  $field1 = '<input type="text" name="limit_up' . $event_id . '" size="10" id="edit-limit-up' . $event_id . '"' .
    'value="' . $default_value . '" style="text-align: right;" ' . $attributes . ' />';

  $options = '';
  if (isset($element['#unit_options'])) {
    foreach ($element['#unit_options'] as $key => $choice) {
      $selected = ($element['#unit_id'] == $key) ? ' selected="selected"' : '';
      $options .= '<option value="' . $key . '"' . $selected . '>' . $choice . '</option>';
    }
  }

  $field2 = '<select name="unit_id' . $event_id . '" id="edit-unit-id' . $event_id . '">' . $options . '</select>';

  return "&nbsp;&nbsp; $field1 &nbsp;&nbsp;&nbsp;$field2";
}

function notification_cron() {

  notification_send_no_communication_emails();
  notification_send_corrupted_message_emails();
  notification_send_communication_restored_emails();
  notification_send_peak_consumption_emails();
  notification_send_summary_report_emails();
  notification_send_forecast_report_emails();
  notification_send_production_anomaly_emails();
  notification_eventlog_clear_old();
}

function notification_compose_base_query($event_id) {
  
  $query = db_select('notification', 'n')
    ->fields('n', array('device', 'event_id', 'limit_up', 'unit_id', 'emails', 'base_time', 'last_sent'))
    ->condition('n.event_id', $event_id, '=')
    ->where('n.last_sent + n.min_interval < :now', array(':now' => REQUEST_TIME))
    ->groupBy('n.device')
    ->groupBy('n.limit_up')
    ->groupBy('n.unit_id');
  
  $query->join('event', 'ev', 'ev.id = n.event_id');
  $query->join('logger_devices', 'd', 'd.device = n.device');
  $query->join('unit', 'un', 'un.id = n.unit_id');
  $query->join('users', 'u', 'u.uid = d.uid'); 

  $query->addField('d', 'serial');
  $query->addField('u', 'timezone');
  $query->addField('un', 'factor');
  $query->addField('un', 'name', 'unit_name');
  $query->addField('ev', 'name', 'event_name');

  return $query;  
}

/**
 * Sends e-mails notifying users of "No Communication" events.
 */
function notification_send_no_communication_emails() {

  $args = array(':now' => REQUEST_TIME);
  $query = notification_compose_base_query(NO_COMMUNICATION_EVENT_ID)
    ->where('n.last_sent + n.limit_up * un.factor < :now', $args)
    ->where('n.base_time + n.limit_up * un.factor < :now', $args);

  $result = $query->execute();

  $notifiables = array();
  while ($notifiable = $result->fetchAssoc()) {

    $log_query = db_select('event_log', 'l');
    $log_query->addExpression('MAX(l.time)', 'max_time');
    $log_query->condition('l.event_id', MESSAGE_RECEIVED_EVENT_ID, '>')
      ->condition('l.device', $notifiable['device'], '=')
      ->havingCondition('max_time', REQUEST_TIME - $notifiable['limit_up'] * $notifiable['factor'], '<');

    $max_time = $log_query->execute()->fetchField();
    
    if ($max_time) {

      $notifiable['since_time'] = $max_time;
      $notifiable['event_time'] = REQUEST_TIME;
      $notifiables[] = $notifiable;
    }
  }

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  $message = notification_compose_error_email(
    "Your Flukso device (serial number: %serial) has not been sending " .
    "data for more than %limit_up %unit_name, since %since_time.",

    "Check your WLAN configuration and make sure that it remains active for " .
    "at least 1 hour per day. The device might be working fine, but it is " .
    "failing to send the heartbeats over the internet.");

  notification_send_emails($message, $notifiables);
}

/**
 * Sends e-mails notifying users of "Communication Restored" events.
 */
function notification_send_communication_restored_emails() {

  $query = notification_compose_base_query(COMMUNICATION_RESTORED_EVENT_ID)
    ->where('n.last_sent + n.limit_up * un.factor < :now', array(':now' => REQUEST_TIME));

  $result = $query->execute();

  $notifiables = array();
  while ($notifiable = $result->fetchAssoc()) {

    $msg_query = db_select('event_log', 'l')
      ->fields('l', array('time'))
      ->condition('l.event_id', MESSAGE_RECEIVED_EVENT_ID, '>')
      ->condition('l.device', $notifiable['device'], '=')
      ->condition('l.time', $notifiable['base_time'] + $notifiable['limit_up'] * $notifiable['factor'], '>');

    $recent_msg_query = db_select('event_log', 'p')
      ->where('p.time < l.time')
      ->condition('p.time', $notifiable['base_time'], '>')
      ->condition('p.device', $notifiable['device'], '=')
      ->condition('p.event_id', MESSAGE_RECEIVED_EVENT_ID, '>');
    $recent_msg_query->addExpression('1');

    $msg_query->notExists($recent_msg_query);

    $time = $msg_query->execute()->fetchField();

    if ($time) {
      $notifiable['event_time'] = $time;
      $notifiable['since_time'] = $notifiable['base_time'];
      $notifiable[] = $notifiable;
    }
  }

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  $message = notification_compose_email(
    "A message has finally been received from your Flukso device " .
    "(serial number: %serial) at %event_time.  It had not been sending data " .
    "for more than %limit_up %unit_name, since %since_time. " .
    "This problem has already been fixed.",

    "Click <a href='!base_url/event/log/list/!device '>here</a> " .
    "to check the latest events of your Flukso device.");

  notification_send_emails($message, $notifiables, FALSE);

  //Update notification base times

  $query = db_select('notification', 'n')
    ->fields('n', array('device', 'limit_up', 'unit_id'))
    ->condition('n.event_id', COMMUNICATION_RESTORED_EVENT_ID, '=')
    ->groupBy('n.device')
    ->groupBy('n.limit_up')
    ->groupBy('n.unit_id');

  $query->join('event_log', 'l', 'l.device = n.device');
  $query->addExpression('MAX(l.time)', 'last_msg_time');
  $query->condition('l.event_id', COMMUNICATION_RESTORED_EVENT_ID, '>');
  $query->where('n.base_time < l.time');

  $logs = $query->execute();

  foreach ($logs as $log) {

    notification_update($log->device, COMMUNICATION_RESTORED_EVENT_ID, $log->limit_up, $log->unit_id, 
      array('base_time' => $log->last_msg_time));
  }
}

/**
 * Sends e-mails notifying users of "Corrupted Message" events.
 */
function notification_send_corrupted_message_emails() {

  $query = notification_compose_base_query(CORRUPTED_MESSAGE_EVENT_ID);

  $query->join('event_log', 'l', 'l.device = n.device AND l.event_id = n.event_id');
  $query->addField('l', 'time', 'event_time');
  $query->where('l.time > n.base_time');

  $result = $query->execute();

  $notifiables = array();
  while ($notifiable = $result->fetchAssoc()) {
    $notifiables[] = $notifiable;    
  }

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  $message = notification_compose_error_email(
    "Your Flukso device (serial number: %serial) has sent either a " .
    "measurement or a heartbeat with corrupted data at %event_time.");

  notification_send_emails($message, $notifiables);
}

/**
 * Sends e-mails notifying users of the occurrence of Peak Consumption events.
 */
function notification_send_peak_consumption_emails() {

  $query = notification_compose_base_query(PEAK_CONSUMPTION_EVENT_ID);
  $query->addField('n', 'base_time', 'since_time');

  $query->join('logger_meters', 'm', 'm.device = d.device');
  $query->condition('m.type', CONSUMPTION_SENSOR_TYPE, '=');
  $query->condition('m.virtual', 0, '=');
  
  $result = $query->execute();

  $notifiables = array();
  while ($notifiable = $result->fetchAssoc()) {

    $violations = notification_query_peak_consumption_violations($notifiable);
    if ($violations) {

      $notifiable['violations'] = $violations['list'];
      $notifiable['event_time'] = $violations['timestamp'];
      $notifiables[] = $notifiable;
    }
  }

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  $message = notification_compose_email(
    "Your Flukso device (serial number: %serial) has registered peaks of " .
    "power consumption above the limit of %limit_up %unit_name.<br><br>" .

    "The following list shows the measurements above the limit.<br><br>" .
    "!violations <br><br>");

  notification_send_emails($message, $notifiables);
}

/**
 * Sends summary report e-mails.
 */
function notification_send_summary_report_emails() {

  require_once LOGGER_PATH . "/logger.rrd.inc";

  $query = notification_compose_base_query(SUMMARY_REPORT_EVENT_ID);

  $types = array(CONSUMPTION_SENSOR_TYPE, PRODUCTION_SENSOR_TYPE);
  $offset = "IF(un.id = :week_unit_id, 4 * :day, 0)";
  $since_time = "n.base_time - ((n.base_time - $offset) % un.factor)";
  $until_time = "$since_time + n.limit_up * un.factor";

  $args = array(
    ':now' => REQUEST_TIME,
    ':delay' => 12 * HOUR,
    ':day' => DAY,
    ':week_unit_id' => WEEK_UNIT_ID
  );

  $query->addExpression($since_time, 'since_time', $args);
  $query->addExpression($until_time, 'until_time', $args);
  $query->addExpression(':now', 'event_time', $args);
  $query->where(":now > $until_time + :delay", $args);

  $result = $query->execute();

  $notifiables = array();
  while ($notifiable = $result->fetchAssoc()) {

    $tz_offset = get_timezone_offset($notifiable['timezone']);
    $notifiable['since_time'] -= $tz_offset;
    $notifiable['until_time'] -= $tz_offset;

    $lines = array();

    $total_cost = array(
      CONSUMPTION_SENSOR_TYPE => 0,
      PRODUCTION_SENSOR_TYPE => 0
    );
    $total_energy = array(
      CONSUMPTION_SENSOR_TYPE => 0,
      PRODUCTION_SENSOR_TYPE => 0
    );

    date_default_timezone_set($notifiable['timezone']);

    $period = array(
      'start' => $notifiable['since_time'],
      'end' => $notifiable['until_time']);

    $sensors_query = db_select('logger_meters', 'm')
      ->fields('m', array('meter', 'function', 'price'))
      ->condition('m.device', $notifiable['device'], '=')
      ->isNotNull('m.function')
      ->condition('m.type', $types, 'IN')
      ->condition('m.virtual', 0, '=');
    $sensors_query->addField('m', 'type', 'type_id');

    $sensors = $sensors_query->execute();
    
    foreach ($sensors as $sensor) {

      $energy = number_format(logger_rrd_query_energy(array($sensor), 'kWh', 'month', $period, DAY), 2, '.', '');
      $cost = number_format($energy * $sensor->price, 2, '.', '');

      $lines[$sensor->type_id] = (isset($lines[$sensor->type_id]) ? $lines[$sensor->type_id] : '') .
        '<tr>' .
        '<td>' . $notifiable['serial'] . '</td>' .
        '<td>' . $sensor->function . '</td>' .
        '<td>' . $energy . '</td>' .
        '<td>' . $cost . '</td></tr>';

      $total_cost[$sensor->type_id] += $cost;
      $total_energy[$sensor->type_id] += $energy;
    }

    $notifiable['until_time'] -= 1; //Display 23:59:59

    $notifiable['tables'] =
      notification_compose_summary_report_table(CONSUMPTION_SENSOR_TYPE, $lines, $total_cost, $total_energy) .
      notification_compose_summary_report_table(PRODUCTION_SENSOR_TYPE, $lines, $total_cost, $total_energy);

    $notifiables[] = $notifiable;
  }

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  $message = notification_compose_email(
    "This is a summary report of your energy consumption and production " .
    "for the period between %since_time and %until_time.<br><br>" .
    '!tables');

  notification_send_emails($message, $notifiables);
}

/**
 * Composes the summary report table.
 * 
 * @param $type         The sensor type.
 * @param $lines        The table lines.
 * @param $total_cost   The total cost to be shown on the bottom line.
 * @param $total_energy The total consumption/production to be shown on the bottom line.
 * @return the summary report table.
 */
function notification_compose_summary_report_table($type, $lines, $total_cost, $total_energy) {

  if (!isset($lines[$type])) {
    return '';
  }

  $title = $type == CONSUMPTION_SENSOR_TYPE ? 'Energy Consumption' : 'Energy Production';

  return "<label class='highlight'>" . t($title) . "</label><br><br>" .
    "<table class='summary'><thead><tr>" .

      "<th>" . t('Device') . "</th>" . 
      "<th>" . t('Sensor') . "</th>" . 
      "<th>" . t('Energy') . " (kWh)</th>" . 
      "<th>" . t('Cost') . ' (' . t('Euro') . ")</th>" .

    "</tr></thead><tbody>" .

      $lines[$type] .

    "</tbody><tfoot><tr>" .

      "<td></td>" . 
      "<td>" . t('Total') . "</td>" . 
      "<td>" . $total_energy[$type] . "</td>" . 
      "<td>" . $total_cost[$type] . "</td>" .

    "</tr></tfoot></table><br><br>";
}

/**
 * Sends forecast report e-mails.
 */
function notification_send_forecast_report_emails() {

  $query = notification_compose_base_query(FORECAST_REPORT_EVENT_ID);

  $query->join('logger_meters', 'm', 'm.device = d.device');
  $query->condition('m.forecast', 1, '=');
  $query->condition('m.virtual', 0, '=');
  $query->addField('m', 'meter');
  $query->addField('m', 'function');

  $since_time = ":now - (:now % :day) + :day";
  $until_time = "$since_time + n.limit_up * un.factor";

  $args = array(
    ':now' => REQUEST_TIME,
    ':day' => DAY
  );

  $query->addExpression($since_time, 'since_time', $args);
  $query->addExpression($until_time, 'until_time', $args);
  $query->addExpression(':now', 'event_time', $args);
  $query->where('n.last_sent + n.limit_up * un.factor < :now', $args);

  $result = $query->execute();

  $notifiables = array();
  while ($notifiable = $result->fetchAssoc()) {

    $notifiable['chart'] = notification_create_forecast_chart($notifiable);
    if ($notifiable['chart']) {

      $tz_offset = get_timezone_offset($notifiable['timezone']);
      $notifiable['since_time'] -= $tz_offset;
      $notifiable['until_time'] -= $tz_offset;
      $notifiables[] = $notifiable;
    }
  }

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  $message = notification_compose_email(
    "This is the forecast of the energy production of your photovoltaic plant for the period between %since_time and %until_time.<br><br>" .
    '!chart');

  notification_send_emails($message, $notifiables, FALSE);
}

/**
 * Creates a forecast report chart.
 * 
 * @param $notification  The forecast report notification object.
 * @return the chart image in binary format.
 */
function notification_create_forecast_chart($notifiable) {

  //TODO: improve the quality of the chart
  global $base_url;

  $lib_path = libraries_get_path('pChart.1.27d');
  include("$lib_path/pChart/pData.class");
  include("$lib_path/pChart/pChart.class");

  $content = NULL;
  $file_path = NOTIFICATION_REL_PATH . '/tmp/' . $notifiable['meter'] . '.png';
  $forecast = pvcast_get_forecast($notifiable['meter'], $notifiable['since_time'], $notifiable['until_time']);

  if (!empty($forecast)) {

    date_default_timezone_set($notifiable['timezone']); 

    $values = array();
    $days = array();
    foreach ($forecast as $timestamp => $value) {
      $values[] = $value;
      $hour = date('G', $timestamp);
      $hours[] = $hour % 12 == 0 ? date('d.m.Y G:i', $timestamp) : NULL;
    }

    $dataset = new pData;
    $dataset->AddPoint($values, "Serie1");
    $dataset->AddSerie("Serie1");
    $dataset->AddPoint($hours, 'XLabel');
    $dataset->SetAbsciseLabelSerie("XLabel");
    $dataset->SetYAxisName(t('watt'));

    $chart = new pChart(700, 230);
    $chart->setColorPalette(0, 0, 0, 255);
    $chart->setFontProperties("$lib_path/Fonts/tahoma.ttf", 8);
    $chart->setGraphArea(70, 30, 680, 200);
    $chart->drawScale($dataset->GetData(), $dataset->GetDataDescription(), SCALE_NORMAL, 150, 150, 150, TRUE, 0, 2);
    $chart->drawGrid(4, TRUE, 230, 230, 230, 50);
    $chart->drawLineGraph($dataset->GetData(), $dataset->GetDataDescription());
    $chart->setFontProperties("$lib_path/Fonts/tahoma.ttf", 10);
    $chart->drawTitle(60, 22, t('Device') . ': ' . $notifiable['serial'] . ' ' . t('Sensor') . ': ' . $notifiable['function'], 50, 50, 50, 585);
    $chart->Render($file_path);

    $content = file_get_contents("$base_url/$file_path");
  }
  return $content;
}

/**
 * Sends e-mails notifying users of 'Production Anomaly' events.
 */
function notification_send_production_anomaly_emails() {

  $query = notification_compose_base_query(PRODUCTION_ANOMALY_EVENT_ID);
  $query->join('logger_meters', 'm', 'm.device = d.device');
  $query->fields('m', array('uid', 'meter', 'price', 'function', 'latitude', 'longitude'));
  $query->condition('m.type', PRODUCTION_SENSOR_TYPE);

  $result = $query->execute();

  $notifiables = array();
  while ($notifiable = $result->fetchAssoc()) {

    $notifiable['event_time'] = REQUEST_TIME;
    $notifiable['anomalies'] = notification_query_production_anomalies($notifiable);

    if (!empty($notifiable['anomalies'])) {
      $notifiables[] = $notifiable;
    }
  }

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  $message = notification_compose_error_email(
    "Your Flukso device (serial number: %serial) has sent the following anomalous measurements.<br><br>" .
    "!anomalies", "Check your PV installation.");

  notification_send_emails($message, $notifiables);
}

/**
 * Notifies the administrator of the occurrence of a system error.
 *
 * @param $context     The page or function where the error occurred.
 * @param $error_code  The error code.
 * @param $url         The URL that triggered the error (if any).
 */
function notification_send_system_error_email($context, $error_code, $url) {

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  $error_descriptions = array(
    'newsletter' => array(
      'ERROR_INVALID_DATA' => 'Invalid e-mail address.',
      'ERROR_INSERT_FAILED' => 'Error while inserting the record in mySQL database.',
      'ERROR_UPDATE_FAILED' => 'Error while updating the record in mySQL database.'
    )
  );

  $description = isset($error_descriptions[$context][$error_code]) ? t($error_descriptions[$context][$error_code]) : '';

  $notifiables = array(
    array(
      'event_id' => SYSTEM_ERROR_EVENT_ID,
      'event_time' => REQUEST_TIME,
      'emails' => 'notifications@mysmartgrid.de',
      'url' => $url,
      'error_code' => $error_code,
      'description' => $description
    )
  );

  $message = notification_compose_email(
    "The following system error has been reported.",

    "Error code: %error_code<br>" .
    "Description: %description<br>" .
    "Related URL: %url");

  notification_send_emails($message, $notifiables, FALSE);
}

/**
 * Composes an e-mail that notifies a general event.
 *
 * @param $description  The event description.
 * @param $complement   Complementary information about the error.
 * @return the e-mail message.
 */
function notification_compose_email($description, $complement = "") {

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  if ($complement && strpos($complement, '<') != 0) {
    $complement = "<p>$complement</p>";
  }

  return 
    "<p class='logo'>!logo</p>" .
    "<p class='highlight'>Dear user<br></p>" .

    "<p>$description</p>" .
    $complement .

    "<p>If you want to stop receiving this notification, please remove it from your " .
    "<a href='!base_url/notification/list'>event notifications list</a>.</p>" .
    "<p><br>" .
    "Best Regards,<br><br>" .
    "mySmartGrid Team</p>";
}

/**
 * Composes an e-mail that notifies an error event.
 *
 * @param $description    The error description.
 * @param $recommendation The recommendation for the user of how to solve the problem.
 * @return the e-mail message.
 */
function notification_compose_error_email($description, $recommendation = NULL) {

  $recommendation = $recommendation == NULL ? '' : "<li><p>$recommendation</p>";

  //ATTENTION: Any change in the following message requires its translations to be redefined.
  return notification_compose_email($description,

    "<p>In order to identify and solve the problem, please take the following actions.</p>" .
    "<ul>" .
      $recommendation .

      "<li><p>Click " .
      "<a href='!base_url/event/log/list/!device '>here</a> " .
      "to check the latest events of your Flukso device.</p>" .

      "<li><p>Check if the device complies with the " .
      "<a href='!base_url/content/installationsanleitung-des-fluksos'>Flukso installation instructions</a>. " .
      "It might be improperly installed or misconfigured.</p>" .

      "<li><p>Visit our <a href='!base_url/content/h&#228;ufige-fragen-und-antworten'>FAQ</a>, " .
      "and read the answers to questions made by other users in similar situations.</p>" .

      "<li><p>In case the problem persists, please send an e-mail to msg-support@itwm.fhg.de.</p>" .
    "</ul>");
}

/**
 * Sends event notification e-mails to notifiable users.
 *
 * @param $message           The e-mail message.
 * @param $notifiables       The array of notifiable users.
 * @param $update_base_time  Whether the base_time field must be updated or not (optional).
 */
function notification_send_emails($message, $notifiables, $update_base_time = TRUE) {

  global $base_url;

  $variables = array(
    '!base_url' => $base_url,
    '!logo' => "<img src='cid:logo'/>",
    '!chart' => "<img src='cid:chart'/>"
  );

  $css = file_get_contents(NOTIFICATION_PATH . "/style/email.css");
  $theme_path =  drupal_get_path('theme', 'msgweb');
  $file_path = "$base_url/$theme_path/logo.png";
  $logo = file_get_contents($file_path);
  $attachments = array();
  $attachments[0] = array(
    'cid' => 'logo',
    'file_name' => 'logo.png',
    'content_type' => 'image/png',
    'content' => $logo,
    'size' => strlen($logo)
  );

  foreach ($notifiables as $notifiable) {

    if (isset($notifiable['chart'])) {
      $attachments[1] = array(
        'cid' => 'chart',
        'file_name' => 'chart.jpg',
        'content_type' => 'image/jpeg',
        'content' => $notifiable['chart'],
        'size' => strlen($notifiable['chart'])
      );
      unset($notifiable['chart']);
    }

    if (isset($notifiable['unit_name'])) {
      $notifiable['unit_name'] = format_plural($notifiable['limit_up'], $notifiable['unit_name'], $notifiable['unit_name'] . 's');
    }

    date_default_timezone_set($notifiable['timezone']);

    $base_time = $notifiable['event_time'];
    $notifiable['event_time'] = date(NOTIFICATION_TIMESTAMP_FORMAT, $notifiable['event_time']);

    if (isset($notifiable['since_time'])) {
      $notifiable['since_time'] = date(NOTIFICATION_TIMESTAMP_FORMAT, $notifiable['since_time']);
    }

    if (isset($notifiable['until_time'])) {
      $notifiable['until_time'] = date(NOTIFICATION_TIMESTAMP_FORMAT, $notifiable['until_time']);
    }

    foreach ($notifiable as $key => $value) {

      $variables["%$key"] = $value;
      $variables["!$key"] = $value;
    }

    $subject = t('Event Notification') . ' - ' . t($notifiable['event_name']) . ' (' . $notifiable['serial'] . ')';
    $body = "<body>" .
      "<style type='text/css'>$css</style>" .
      "<table class='outer'><tr><td>" .
      "<table class='email-box'><tr><td>" .

      t($message, $variables) .

      "</td></tr></table></p>" .
      "</td></tr></table></body>";

    jobqueue_send_email($notifiable['emails'], $subject, $body, $attachments);

    if (isset($notifiable['device'])) {

      $times = array('last_sent' => REQUEST_TIME);

      if ($update_base_time) {
        $times['base_time'] = $base_time;
      }

      notification_update($notifiable['device'], $notifiable['event_id'], $notifiable['limit_up'], $notifiable['unit_id'], $times);
    }
  }
}

/**
 * Returns a list of measurements that violate the Peak Consumption limit.
 *
 * @param $notifiable  The user notifiable of the Peak Consumption Event.
 * @return an array containing the latest timestamp and the HTML list of measurements.
 */
function notification_query_peak_consumption_violations($notifiable) {

  $list = NULL;
  $measurements = logger_query_device_measurements('hour', $notifiable['device']);

  foreach ($measurements as $meter => $data) {
    foreach ($data as $function => $values) {
      $sublist = NULL;

      foreach ($values as $timestamp => $value) {

        if ($value > $notifiable['limit_up'] && $timestamp > $notifiable['since_time']) {

          date_default_timezone_set($notifiable['timezone']);

          $sublist = $sublist ? $sublist : t('Sensor') . ': ' . $function . '<br> ';
          $sublist .= date(NOTIFICATION_TIMESTAMP_FORMAT, $timestamp) . ' - ' .
            number_format($value, 2, '.', '') . ' ' . t('watt') . '<br> ';
        }
      }
      $list .= $sublist;
    }
  }
  return $list ? array('timestamp' => $timestamp, 'list' => $list) : NULL;
}

/**
 * Returns a list of anomalous power production measurements.
 *
 * @param $notifiable  The user notifiable of the Production Anomaly Event.
 * @return the HTML list of measurements.
 */
function notification_query_production_anomalies($notifiable) {

  require_once LOGGER_PATH . "/logger.anomaly.inc"; 

  $period = array('start' => $notifiable['base_time'], 'end' => time());
  $anomalies = logger_detect_production_anomalies((object) $notifiable, 'watt', $period, MINUTE);

  $list = '';
  foreach ($anomalies as $timestamp => $value) {

    date_default_timezone_set($notifiable['timezone']);

    $list = $list ? $list : t('Sensor') . ': ' . $notifiable['function'] . '<br> ';
    $list .= date(NOTIFICATION_TIMESTAMP_FORMAT, $timestamp) . ' - ' .
      number_format($value, 2, '.', '') . ' ' . t('watt') . '<br> ';
  }
  return $list;
}

function notification_create_chart($file_path) {

  $path = libraries_get_path('pChart.1.27d');

  // Standard inclusions
  include("$path/pChart/pData.class");
  include("$path/pChart/pChart.class");

  // Dataset definition
  $DataSet = new pData;
  $DataSet->ImportFromCSV("$path/Sample/bulkdata.csv",",",array(1,2,3),FALSE,0);
  $DataSet->AddAllSeries();
  $DataSet->SetAbsciseLabelSerie();
  $DataSet->SetSerieName("January","Serie1");
  $DataSet->SetSerieName("February","Serie2");
  $DataSet->SetSerieName("March","Serie3");
  $DataSet->SetYAxisName("Average age");
  $DataSet->SetYAxisUnit("s");

  // Initialise the graph
  $Test = new pChart(700,230);
  $Test->setFontProperties("Fonts/tahoma.ttf",8);
  $Test->setGraphArea(70,30,680,200);
  $Test->drawFilledRoundedRectangle(7,7,693,223,5,240,240,240);
  $Test->drawRoundedRectangle(5,5,695,225,5,230,230,230);
  $Test->drawGraphArea(255,255,255,TRUE);
  $Test->drawScale($DataSet->GetData(),$DataSet->GetDataDescription(),SCALE_NORMAL,150,150,150,TRUE,0,2);
  $Test->drawGrid(4,TRUE,230,230,230,50);

  // Draw the 0 line
  $Test->setFontProperties("Fonts/tahoma.ttf",6);
  $Test->drawTreshold(0,143,55,72,TRUE,TRUE);

  // Draw the line graph
  $Test->drawLineGraph($DataSet->GetData(),$DataSet->GetDataDescription());
  $Test->drawPlotGraph($DataSet->GetData(),$DataSet->GetDataDescription(),3,2,255,255,255);

  // Finish the graph
  $Test->setFontProperties("Fonts/tahoma.ttf",8);
  $Test->drawLegend(75,35,$DataSet->GetDataDescription(),255,255,255);
  $Test->setFontProperties("Fonts/tahoma.ttf",10);
  $Test->drawTitle(60,22,"example 1",50,50,50,585);
  $Test->Render($file_path);
}
